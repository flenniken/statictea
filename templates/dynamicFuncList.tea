## Create a list of dictionaries, one dictionary per statictea
## function.  Statictea code file for the functionsList.nim template.

## The nimble task dyfuncs runs the template.

get-starts = func(ix: int, entry: dict, starts: dict, entries: list) bool
  ## Collect the a function's start line and number of lines.
  start = entry.line

  # Calculate the number of lines by the difference between the
  # current start line and the next one.
  next-entry = get(entries, add(ix,1), dict())
  next = get(next-entry, "line", start)
  numLines = sub(next, start)

  key = concat("k", string(start))
  # Skip dups that can happen in the included code.
  if(exists(starts, key), return(false))
  starts[key] = numLines
  return(false)

get-entry = func(ix: int, entry: dict, newList: list, state: dict) bool
  ## Add the Statictea functions to the new list.

  # Add entries that are functions that begin with "fun_", skip the
  # others.
  if((entry.type != "skFunc"), return(false))
  if(not(startsWith(entry.name, "fun_")), return(false))

  newEntry = dict()
  newEntry.funcName = entry.name

  # Remove the formatting from the description.
  desc = get(entry, "description", "")
  newEntry.docComment = replaceRe(desc, state.patterns)

  newEntry.lineNum = entry.line
  newEntry.numLines = state.starts[concat("k", string(entry.line))]
  newList &= newEntry
  return(false)

# Make a dictionary mapping a function's start line to its number of lines.
starts = dict()
listLoop(s.entries, starts, get-starts, s.entries)

# Define replacement patterns to remove formatting from the doc
# comments (descriptions).
patterns = list( +
  "~~~~", "~~~", +
  "@@", "", +
  "@{", "[", +
  "}@", "]", +
  "@!", "|", +
  "[ ]*@:", "\n", +
  "@\\.", "*", +
  "&quot;", "\"", +
  "&gt;", ">", +
  "&lt;", "<", +
  "&amp;", "&")

# Create a list of dictionaries, one dictionary per statictea function.
state = dict()
state.patterns = patterns
state.starts = starts
entries = []
listLoop(s.entries, entries, get-entry, state)

# Sort the entries by function name. Use insensitive compare so
# function cmp_ comes before cmpV.
o.entries = sort(entries, "ascending", "insensitive", "funcName")
