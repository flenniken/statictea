# $ # StaticTea template for generating the function doc section
# $ # for the readme.
# $ #
# $ #
# $ #
# $ block
# $ : # Define replacement patterns to undo HTML formatting.
# $ : g.patterns = list( +
# $ :   "~~~~", "#+END_SRC", +
# $ :   "~~~", "#+BEGIN_SRC", +
# $ :   "\\* ", "- ", +
# $ :   "@@", "", +
# $ :   "@{", "[", +
# $ :   "}@", "]", +
# $ :   "[ ]*@:", "\n", +
# $ :   "@\\.", "*", +
# $ :   "&quot;", "\"", +
# $ :   "&gt;", ">", +
# $ :   "&lt;", "<", +
# $ :   "&amp;", "&")
# $ : # Sort the json entries by name.
# $ : g.sortedEntries = sort(s.entries, "ascending", "sensitive", "name")
# $ endblock
# $ #
# $ block
# $ : # Create a list of functions to show.
# $ :
# $ : t.repeat = len(g.sortedEntries)
# $ : entry = get(g.sortedEntries, t.row, dict())
# $ :
# $ : # Use the skProc entries, skip the rest.
# $ : # if((entry.type != "skProc"), warn(format("skip {entry.name} of type {entry.type}")))
# $ : if((entry.type != "skProc" and entry.type != "skFunc"), return("skip"))
# $ :
# $ : # Use the procs that start with "fun" and skip the others.
# $ : pos = find(entry.name, "fun", -1)
# $ : if((pos == -1), return("skip"))
# $ :
# $ : # Remove the fun prefix and the trailing code from the name and lower case it.
# $ : # funCmp_iii => cmp
# $ : nameLength = add(find(entry.name, "_", len(entry.name)), -3)
# $ : capName = case(pos, list(0, slice(entry.name, 3, nameLength)), entry.name)
# $ : name = concat(lower(slice(capName, 0, 1)), slice(capName, 1))
# $ : if0( exists(entry, "description"), warn(entry.name))
# $ : if0( exists(entry, "description"), warn(entry.type))
# $ : if0( exists(entry, "description"), warn(capName))
# $ : if0( exists(entry, "description"), warn(name))
# $ : if0( exists(entry, "description"), warn(format("missing description for: {entry.name}")))
# $ :
# $ : # Remove the HTML formatting from the description.
# $ : desc = if( exists(entry, "description"), replaceRe(entry.description, g.patterns), "")
# $ :
# $ : # Use the first sentence for the short description.
# $ : shortFuncDesc = slice(desc, 0, add(find(desc, ".", -1), 1))
# $ : description = replaceRe(desc, g.patterns)
# $ :
# $ : newEntry = dict()
# $ : newEntry.name = name
# $ : newEntry.shortFuncDesc = shortFuncDesc
# $ : newEntry.description = description
# $ : g.entries &= newEntry
# $ endblock
# $ #
# $ #
# $ #
# $ nextline
# $ : t.repeat = if(exists(g, "entries"), len(g.entries), 0)
# $ : entry = g.entries[t.row]
- [[#{entry.name}][{entry.name}]] -- {entry.shortFuncDesc}

# $ #
# $ # Generate the function sections.
# $ #
# $ block
# $ : t.repeat = if(exists(g, "entries"), len(g.entries), 0)
# $ : entry = g.entries[t.row]
[[#contents][èŒ¶]]

** {entry.name}
:PROPERTIES:
:CUSTOM_ID: {entry.name}
:END:

{entry.description}

# $ endblock
