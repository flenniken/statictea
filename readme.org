* StaticTea

** A template processor and language.

StaticTea combines a template with data to produce a result.

Example template:

#+BEGIN_SRC
<!--$ nextline -->
hello {name}
#+END_SRC

The associated json data:

#+BEGIN_SRC
{"name": "world"}
#+END_SRC

The result:

#+BEGIN_SRC
hello world
#+END_SRC

** Advantages

You develop templates as if they were static pages.  You can
view, edit and validate your templates with its normal tools.

The template designer has full control over the presentation.
You can change the lok without changing the server.

** How it Works

The variable content comes from the server unformatted. You
format it in the template with commands.

You mark replacement text with brackets and by preceding command
lines.

The commands are encoded as comments to match the prticular
template type.

You can share common template fragments between templates.


** Commands

StaticTea commands:

- nextline - make substitutions in the next line
- block — make substitutions in the next block of lines
- replace — replace block with a variable
- # — comment
- : - continue line, used for continuation lines
- endblock - end of block
- endreplace - end of replace block

example command lines:

#+BEGIN_SRC
<!--$ nextline -->
<!--$ block t.list = teaProducingCountries; tea="Darjeeling" -->
<!--$ replace t.replaceContent = header -->
<!--$ # this is a comment command -->
#+END_SRC

** Statements

You use a statement to create or assign a variable.

A statement consists of a variable, an equal sign, and a right
hand side. The right side is either another variable, a
function or a literal. Here are some examples:

#+BEGIN_SRC
t.list = teaList
nameLen = t.len(name)
tea = "Earl Grey"
num = 5
#+END_SRC

You define variables for the replacement block or to control how
the block behaves.

Statements go on the the nextline, block or replace commands.

You can use multiple statements separated with semicolons.

If you need more space, you can continue the line with the "\\"
character at the end.

Statements are executed from left to right. No statements are
allowed on the end commands.

*** Nextline Command

The nextline command tells the template system that the next line
in the file has variable content.

The content comes from text in the line and variables wrapped
with brackets.

The following example contains some text and two variables, the
drink and drinkType variables.

template:

#+BEGIN_SRC
<!--$ nextline -->
Drink {drink} -- {drinkType} is my favorite.
#+END_SRC

json:

#+BEGIN_SRC
{
  "drink": "tea",
  "drinkType": "Earl Grey""
}
#+END_SRC

result:

#+BEGIN_SRC
Drink tea -- Earl Grey is my favorite.
#+END_SRC

*** Block Command

The block command targets multiple lines for replacement. The
block starts after the command and continues until the endblock
line is found. It behaves like the nextline command except with
multiple lines.

The content comes from text in the block and variables wrapped
with brackets.

In the following example the block has two lines. The block
contains three replacement variables, weekday, name and time.

template:

#+BEGIN_SRC
<!--$ block -->
Join our tea party on {weekday} at
{name}'s house at {time}.
<!--$ endblock -->
#+END_SRC

json:

#+BEGIN_SRC
{
  "weekday": "Friday",
  "name": "John",
  "time": "5:00 pm"
}
#+END_SRC

result:

#+BEGIN_SRC
Join our tea party on Friday at
John's house at 5:00 pm.
#+END_SRC

*** Replace Command

The replace command replaces the replacement block with a
variable's value. You set the block content by assigning the
t.replaceContent variable.

The lines in the block mirror the variable so you can
test the template as if it was a static file.

The command is useful for sharing common template lines between
templates and it has the special property that you can update the
replacement block to keep it in sync with the variable.

You can assign t.replaceContent the special "tempTesting" value and the
block content is used as is.  This is good for testing changes
you want to make to the shared value.

The following example shares a common header between templates.

template:

#+BEGIN_SRC
<!--$ replace t.replaceContent=s.header -->
<!--$ endreplace -->
#+END_SRC

json:

#+BEGIN_SRC
{
  "header": "<!doctype html>\n<html lang="en">\n"
}
#+END_SRC

result:

#+BEGIN_SRC
<!doctype html>
<html lang="en">
#+END_SRC

The above example doesn’t work as a static template because the
template is missing the header lines.

You can fix this by adding the header lines inside the replace
block. The inside lines do not appear in the result, just the
data from the json variable.

template:

#+BEGIN_SRC
<!--$ replace t.replaceContent=s.header -->
<!doctype html>
<html lang="en">
<!--$ endreplace -—>
#+END_SRC

The template replacement block may get out of sync with the
variable.  You can update the replacement block to match the
variable with the update option.

The following example updates the mytea.html template's
replacement blocks to match their variables in the shared.json
file:

#+BEGIN_SRC
statictea --update --shared shared.json --template mytea.html
#+END_SRC

The shared variable may contain replacement content too.  Here is
another header example:

template:

#+BEGIN_SRC
<!--$ replace t.replaceContent=s.header -->
<!DOCTYPE html>
<html lang="{languageCode}" dir="{languageDirection}">
<head>
<meta charset="UTF-8"/>
<title>{title}</title>
<--$ endreplace -->
#+END_SRC

json:

#+BEGIN_SRC
{
"languageCode": "en",
"languageDirection": "ltr",
"title": "Teas in England"
}
#+END_SRC

result:

#+BEGIN_SRC
<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8"/>
<title>Teas in England</title>
#+END_SRC

*** Comment Command

You can comment templates.  Comments are line based and use the #
character. They do not appear in the result.

template:

#+BEGIN_SRC
<!--$ # How you make tea. -->
There are five main groups of teas:
white, green, oolong, black, and pu'erh.
You make Oolong Tea in five time
intensive steps.
#+END_SRC

result:

#+BEGIN_SRC
There are five main groups of teas, white, green, oolong, black,
and pu'erh. You make Oolong Tea in five time intensive steps.
#+END_SRC

*** Continue Command

You can continue a long command line with the "\\" character at
the end before the postfix. The following continuation line must
be a continue command.

The continuation command allows you to continue adding
statements as if it is one long line. You can continue the
continue command too, if you need more space.

The template's command line plus continuation lines length is
limited, see limits.

In the following example the nextline command continues on a
second line and third line.

template:

#+BEGIN_SRC
<!--$ nextline \-->
<!--$ : tea = 'Earl Grey' \-->
<!--$ : tea2 = 'Masala chai' -->
{tea}, {tea2}
#+END_SRC

result:

#+BEGIN_SRC
Earl Grey, Masala chai
#+END_SRC

Note: only the endblock command ends a block command. All text
until the endblock is part of the replacement block. This
includes other commands. For example:

template:

#+BEGIN_SRC
<!--$ block -->
<!--$ # this is not a comment, just text -->
fake nextline
<!--$ nextline -->
<!--$ endblock -->
#+END_SRC

result:

#+BEGIN_SRC
<!--$ # this is not a comment, just text -->
fake nextline
<!--$ nextline -->
#+END_SRC

*** Endblock Command
*** Endreplace Command

** Types

StaticTea variables types:

- strings
- integers
- floats
- dictionary
- list

*** Strings

You define a string with single or double quotes. You use strings
in statements. The strings you define are limited to 60
characters. See limits.

If you pass a string to a function taking a number, the string
is converted to an integer. It's an error when the string doesn't
look like a number.

example strings:

- "this is a string"
- 'using single quotes'
- "You can store black teas longer than green teas."
- "100"

example usage:

#+BEGIN_SRC
<!--$ nextline message=t.if(admin, 'Earl Grey', 'Jasmine') -->
<h2>{message}</h2>
#+END_SRC

json:

#+BEGIN_SRC
{
  "admin": 1
}
#+END_SRC

result:

#+BEGIN_SRC
<h2>Earl Grey</h2>
#+END_SRC

*** Integers

Integers are 32 bit signed numbers. If you need bigger numbers,
use floats or strings. When you pass an integer to a
function that takes a string, the number is converted to a
string.

Example numbers:

#+BEGIN_SRC
12345
0
-8823
42
#+END_SRC

*** Floats
*** Dictionaries
*** Lists

** Variables

You use variables for block content and to control how a command
works.

You specify variables in json files or you create them in
template statements.

The server or shared json dictionary keys become the variable
names and their values becomes part of the template when they are
used.

Internally two json namespaces exist, one for the server json and
one for the shared json.  You access the shared json variables
with the "s." prefix. No prefix for the the server variables.

Variables defined in the template are local to the block where
they are defined. Local variables take precedence over the
json variables.

The variables are processed from left to right, so the last one
takes precedence when there are duplicates.

example variables:

#+BEGIN_SRC
mytea
s.name
t.list
#+END_SRC

** System Variables

The built in system variables control how the replacement block
works.

- t.list - controls whether the block repeats
- t.maxLines - maximum lines before endblock or endreplace
- t.replaceContent - content of the replace block
- t.result - where the result goes
- t.server - dictionary containing the server variables
- t.shared - dictionary containing the shared variables

*** t.list

The t.list variable determines whether the current replacement
block repeats or not. It repeats once for each item in the list.
By default the block is output once.  An empty list means don't
show the block at all.

The list must be a list of dictionaries. Each dictionary contains
local variables you use in the block. The command variables get
re-evaluated for each item in the list which allows you to format
them for the block.

For the following example, tea_list is assigned to the t.list
variable which outputs the block five times.

template:

#+BEGIN_SRC
<!--$ nextline t.list = tea_list -->
  * {tea}
#+END_SRC

json:

#+BEGIN_SRC
{
"tea_list": [
    {"tea": "Black"},
    {"tea": "Green"},
    {"tea": "Oolong"},
    {"tea": "Sencha"},
    {"tea": "Herbal"}
  ]
}
#+END_SRC

result:

#+BEGIN_SRC
  * Black
  * Green
  * Oolong
  * Sencha
  * Herbal
#+END_SRC

The following example builds a select list of tea companies where
one company is selected.

template:

#+BEGIN_SRC
<h4>Tea Companies</h3>
<select>
<!--$ nextline t.list=companyList; \-->
<!--$ : current=t.if(selected, ' selected="selected"', "") -->
  <option{current}>{company}</option>
</select>
#+END_SRC

json:

#+BEGIN_SRC
{
"companyList": [
    {"company": "Lipton"},
    {"company": "Tetley"},
    {"company": "Twinings, "selected": 1"},
    {"company": "American Tea Room"},
    {"company": "Argo Tea"},
    {"company": "Bigelow Tea Company"}
  ]
}
#+END_SRC

result:

#+BEGIN_SRC
<h3>Tea Companies</h3>
<select>
  <option>Lipton</option>
  <option>Tetley</option>
  <option selected="selected">Twinings</option>
  <option>Argo Tea</option>
  <option>American Tea Room</option>
  <option>Bigelow Tea Company</option>
</select>
#+END_SRC

*** t.maxLines

The t.maxLines variable determines the maximum lines in a block.

StaticTea reads lines looking for the endblock or endreplace
commands.  By default, if it is not found in 10 lines, the 10
lines are used for the block and a warning is output.

You can increase this value to support blocks with more lines by
setting the t.maxLines system variable.

#+BEGIN_SRC
<!--$ block t.maxLines=20 -->
#+END_SRC

*** t.replaceContent

The t.replaceContent variable defines what goes in the replace
block. The assigned value replaces the whole replace block.  The
default is "", which mean the block is replaced with nothing.

The variable only applies to the replace command.

See the replace command section for an example.

*** t.result

The t.result variable determines where the replacement blocks's
result goes, either the results file, standard error or
nowhere. By default it goes to the result file.

Result variable options:

- "result" - send the replacement block to the result file (default)
- "skip" - skip the block
- "stderr" - send the block to standard error

Skip Example:

The skip case is good for building test lists.

When you view the following template fragment in a browser it
shows one item in the list.

template:

#+BEGIN_SRC
<h3>Tea</h3>
<ul>
<!--$ nextline t.list = teaList -->
  <li>{tea}</li>
</ul>
#+END_SRC

To create a static page that has more products for better testing
you could use the skip option like this:

template:

#+BEGIN_SRC
<h3>Tea</h3>
<ul>
<!--$ nextline t.list = teaList -->
  <li>{tea}</li>
<!--$ block t.result = 'skip' -->
  <li>Black</li>
  <li>Green</li>
  <li>Oolong</li>
  <li>Sencha</li>
  <li>Herbal</li>
<!--$ endblock -->
</ul>
#+END_SRC

json:

#+BEGIN_SRC
{
  "teaList": [
    {"tea": "Chamomile"},
    {"tea": "Chrysanthemum"},
    {"tea": "White"},
    {"tea": "Puer"}
  ]
}
#+END_SRC

result:

#+BEGIN_SRC
<h3>Tea</h3>
<ul>
  <li>Chamomile</li>
  <li>Chrysanthemum</li>
  <li>White</li>
  <li>Puer</li>
</ul>
#+END_SRC

*** t.server

The t.server variable contains the server json variables.

*** t.shared

The t.shared variable contains the shared json variables

** Functions

StaticTea has many built in functions you can call to format your
varibles for output.  Functions take zero or more input parameters
and return a value that you assign to a variable.

You use functions on a command line and you use the resulting
variables in its replacement block.

The following example assigns the numberVars variable to the
number of variables in the t.server dictionary then it uses the
variable in its replacement block.

#+BEGIN_SRC
<!--$ nextline numberVars = t.len(t.server) -->
The server json contains {numberVars} variables.
#+END_SRC

List of functions:

- t.bignum() -- add commas to big numbers for readability
- t.case() -- generalized if function
- t.cmp() -- spaceship compare function <=>
- t.concat() -- concatenate strings
- t.exists() -- whether a variables exists
- t.find() -- find a substring in a string
- t.format() -- format a string
- t.if() -- if function
- t.len() -- length of string
- t.row() -- special function that returns the current row
- t.substr() -- extract a substring from a string by indexes
- t.version() -- the current version and version checker

*** t.bignum

#+BEGIN_SRC
var = t.bignum(num, ",")
#+END_SRC

*** t.case

The t.case function is a generalized if statement.  You use it to
preform different actions depending on a condition.

It requires at least two parameters, the condition and the "else"
case.

The rest of the parameters you specify in pairs, the first is the
case value and the second is the return value when the condition
matches that case.

When none of the cases match the condition, the else case is
used.

For the example below the abbr variable is set to an abbreviation
depending on the type of tea.

template:

#+BEGIN_SRC
<--$ nextline \-->
<--$ : abbr = t.case( \-->
<--$ : tea, "unknown",  \-->
<--$ : 'Darjeeling', "Darj",  \-->
<--$ : "Earl Gray", "EG") -->
The abbreviation for {tea} is {abbr}.
#+END_SRC

json:

#+BEGIN_SRC
{
  "tea": "Darjeeling"
}
#+END_SRC

result:

#+BEGIN_SRC
The abbreviation for Darjeeling is Darj.
#+END_SRC

The t.if statement is shorthand for a simple t.case:

#+BEGIN_SRC
t.if(cond, v1, v2)
#+END_SRC
is equivalent to:
#+BEGIN_SRC
t.case(cond, v2, 1, v1)
#+END_SRC


*** t.cmp

The t.cmp function compares two variables, either numbers or
strings, and returns whether the first parameter is less than,
equal to or greater than the second parameter. It returns -1 for
less, 0 for equal and 1 for greater than.

The example below shows the best selling tea between Earl Grey
and Oolong. If Oolong out sells Earl Grey it's the best,
otherwise it's Earl Gray.  Eary Grey wins ties.

template:

#+BEGIN_SRC
<!--$ nextline sold = t.cmp(earlgrey, oolong); \-->
<!--$ : bestSelling = t.case(sold, earlgreyName, 1, oolongName) -->
The best selling tea this week is {bestSelling}.
#+END_SRC

json:

#+BEGIN_SRC
{
  earlgrey: 500,
  oolong: 300,
  earlgreyName: "Earl Grey, Twinings",
  oolongName: "Oolon, Mighty Leaf Tea"
}
#+END_SRC

result:

#+BEGIN_SRC
The best selling tea this week is Earl Grey, Twinings.
#+END_SRC

*** t.concat()

The t.concat function concatenates strings. You can specify 0 or
more parameters. Examples:

#+BEGIN_SRC
t.concat() => ""
t.concat("Tea") => "Tea"
t.concat("Tea", "Time") => "TeaTime"
t.concat("Tea", " ",  "Time") => "Tea Time"
#+END_SRC

*** t.exists

The t.exists returns 1 when a variable exists, else it returns 0.

template:

#+BEGIN_SRC
<--$ block a = "apple"; \-->
<--$ : ax = t.exists(a); \-->
<--$ : bx = t.exists(b) -->
t.exists(a) => {ax}
t.exists(b) => {bx}
<--$ endblock -->
#+END_SRC

result:

#+BEGIN_SRC
t.exists(a) => 1
t.exists(b) => 0
#+END_SRC

*** t.find()

The t.find function searches a string for substring and returns
its position when found. When not found it returns -1.

template:

#+BEGIN_SRC
<--$ nextline \-->
<--$ pos = t.find("Tea time at 4:00.", "time") -->
{pos}
#+END_SRC

result:

#+BEGIN_SRC
4
#+END_SRC

*** t.get

You use the t.get function to access list or dictionary
values. It takes three parameters. The first is the list or
dictionary to use. The second is the key name for dictionaries or
the index for lists. The third is the default value when the item
doesn't exist.

#+BEGIN_SRC
var = t.get(t.server, "tea", "Earl Grey")
var2 = t.get(t.list, 2, ???)
#+END_SRC

*** t.if

You use the if function to select a value based on a condition.

The if function has three parameters. The first parameter is the
condition, the second is the 1 case and the third is the else
case. When the condition is 1, the second parameter is returned,
else the third parameter is returned.

The following example uses the template system to show how it
works.

template:

#+BEGIN_SRC
<--$ block \-->
<--$ var1=t.if(1, 'dog', 'cat'), \-->
<--$ var2=t.if(0, 'dog', 'cat'), -->

t.if(1, 'dog', 'cat') => {var1}
t.if(0, 'dog', 'cat') => {var2}
<--$ endblock -->
#+END_SRC

result:

#+BEGIN_SRC

t.if(1, 'dog', 'cat') -> dog
t.if(0, 'dog', 'cat') -> cat
#+END_SRC

*** t.format

The t.format function is a powerful way to format your
variables. You can left, right or center the variable.  You can
specify the number of digits after the decimal point and other
things. For all the details see: https://nim-lang.org/docs/strformat.html.

template:

#+BEGIN_SRC
<--$ nextline -->
Kathleen spent ${cost:.2f} on tea for Steve's birthday.
#+END_SRC

json:

#+BEGIN_SRC
{
  "cost": 52.436789
}
#+END_SRC

result:

#+BEGIN_SRC
Kathleen spent $52.44 on tea for Steve's birthday.
#+END_SRC

*** t.len

The t.len function returns the number of characters in a string,
the number of elements in a list or the number of elements in a
dictionary.

#+BEGIN_SRC
<!--$ block \-->
<!--$ : length = t.len("Tetley"); \-->
<!--$ : listLen = t.len(tea_list); \-->
<!--$ : serverLen = t.len(t.server) -->
The Tetley name has {length} characters.
The tea list has {listlen} elements.
The server json dictionary has {serverLen} elements.
<!--$ endblock -->
#+END_SRC

json:

#+BEGIN_SRC
{
"tea_list": [
    {"tea": "Black"},
    {"tea": "Green"},
    {"tea": "Oolong"},
    {"tea": "Sencha"},
    {"tea": "Herbal"}
  ]
}
#+END_SRC


result:

#+BEGIN_SRC
The Tetley name has 6 characters.
The tea list has 5 elements.
The server json dictionary has 1 elements.
#+END_SRC

*** t.row

The special row function returns the current row for lists. The
function takes a parameter which specifies the starting
point. You can use it in replacement blocks.

- t.row(0) — returns 0, 1, 2,...
- t.row(1) — returns 1, 2, 3,...
- t.row(N) — returns N, N+1, N+2,... where N is some integer.

Here is an example using the row variable.

template:

#+BEGIN_SRC
<!--$ nextline t.list=companies -->
  <li id="r{t.row(0)}>{t.row(1)}. {teaCompany}</li>
#+END_SRC

json:

#+BEGIN_SRC
{
  "companies": [
    {"teaCompany": "Mighty Leaf Tea"},
    {"teaCompany": "Numi Organic Tea"},
    {"teaCompany": "Peet's Coffee & Tea"},
    {"teaCompany": "Red Diamond"}
  ]
}
#+END_SRC

result:

#+BEGIN_SRC
  <li id="r0">1. Mighty Leaf Tea</li>
  <li id="r1">2. Numi Organic Tea</li>
  <li id="r2">3. Peet's Coffee & Tea</li>
  <li id="r3">4. Red Diamond</li>
#+END_SRC

*** t.substr

The t.substr function extracts a substring from a string by
indexes. The last parameter is optional. The first parameter is
the string to operate on, the second is the starting index of the
substring to extract and the third is the ending index (one past
it). The third parameter defaults to one past the end of the
string. The end minus the start is equal to the length of the
substring.

#+BEGIN_SRC
Earl Grey
0123456789
#+END_SRC

template:

#+BEGIN_SRC
<--$ nextline \-->
<--$ : sub1 = t.substr("Earl Grey", 5) \-->
<--$ : sub2 = t.substr("Earl Grey", 0, 4) -->
sub1 = {sub1}, sub2 = {sub2}
#+END_SRC

result:

#+BEGIN_SRC
sub1 = Grey, sub2 = Earl
#+END_SRC

*** t.version

You use the version function to get the current version of
StaticTea or to verify that the version you are running works
with your template.

The version function takes 0, 1 or 2 parameters. The first parameter
is the minimum version supported and the second parameter is the
maximum version supported.

The default minimum is 0.0.0 and the default maximum is anything.

If the current version is below the minimum or above the maximum,
the function outputs a message to standard error.

You can use the function multiple times for fine grain checking.

StaticTea uses [[https://semver.org/][Semantic Versioning]] with the added restriction
that each version component is limited to three digits and all
components have at least one digit.

Below is typical useage:

template:

#+BEGIN_SRC
<--$ nextline version=t.version("1.20.3", "3.4.005") -->
<-- StaticTea current version is: {version}. -->
#+END_SRC

result:

#+BEGIN_SRC
<-- StaticTea current version is: 1.9.0. -->
#+END_SRC

If the current version is not between the min and max, a message
is output to standard error.  Example messages:

stdout:

#+BEGIN_SRC
tea.html(45): w22: The current version 4.0.2 is greater than the maximum
allowed verion of 3.4.5.

tea.html(45): w23: The current version 1.0.0 is less than the minumum
allowed verion of 1.2.3.
#+END_SRC

** Prefix Postfix

You make the template commands look like comments tailored for
your template file type. This allows you to edit the template
using its native editor and run other native tools.  For example,
you can edit a StaticTea html template with an html editor and
validate it online with w3.org (https://validator.w3.org).

Comment syntax varies depending on the type of template file and
sometimes depending on the location within the file. StaticTea
supports several varieties and you can specify others.

You want to distinguish StaticTea commands from normal comments
when you create your own. The convention is to add a $ as the
last character of the prefix and only use $ with StaticTea
commands and space for normal comments.

Built in Prefixes:

- '<!--$' '-->' - for html
- '/!--$' '--*\slash{}' - for javascript in html
- '&lt;!--$' '--&gt;' - for html textarea elements
- '#$' - for bash scripts and others
- ';$' - for config files and others

You can define other comment types on the command line using the
prepost option one or more times.

You separate the prefix from the postfix with one space and the
postfix is optional.

examples:

#+BEGIN_SRC
--prepost="@$ |"
--prepost="[comment$ ]"
--prepost="#[ ]#"
#+END_SRC

** Json Files

There are two types of json files the server json and the shared
json.

The server json comes from the server and shouldn't contain any
presentation data so the template designers have full control of
the presentation. You include zero, one or more server files
with the server option. The variables get added to the t.server
dictionary.

You use the shared json to share common template lines and other
presentation information. You can include zero, one or more
shared files with the shared option. You reference them with the
"s." namespace prefix. The variables get added to the t.shared
dictionary.

When you specify multiple files on the command line, they get
added to the dictionary from left to right so the last duplicate
variable wins.

** Json Dictionaries

You have access to the server and shared dictionaries with the
t.server and t.shared system variables.

The json null values get converted to the string "null". Json
True and False get converted to ints 1 and 0.

template:

#+BEGIN_SRC
<!--$ block \-->
<!--$ : serverElements = t.len(t.server) \-->
<!--$ : jsonElements = t.len(t.shared) -->
The server has {serverElements} elements
and the shared json has {jsonElements}.
<!--$ endblock -->
#+END_SRC

json:

#+BEGIN_SRC
{
  "tea1": "Black",
  "tea2": "Green",
  "tea3": "Oolong",
  "tea4": "Sencha",
  "tea5": "Herbal"
}
#+END_SRC

result:

#+BEGIN_SRC
The server has 5 elements
and the shared json has 0.
#+END_SRC

** Warning Messages

When StaticTea detects a problem, a warning message is written to
standard error, the problem is skipped, and processing
continues.

For example, if a variable in a replacement block is used but it
doesn't exist, the bracketed variable remains as is in the
result, and a message is output to standard error. There are many
other potential warnings.

It’s good style to change your template or json so no messages
get output.

Each warning message shows the file and line number where the problem
happened. Each warning has an associated number which doesn't
change. Don't count on the message text remaining constant
between versions of StaticTea.

example messages:

- tea.html(45): w1: Unknown server variable: teaMaster.
- tea.html(45): w2: The postfix is missing.
- tea.html(45): w3: The command line doesn't have a valid
  command, found: blocker.
- tea.html(45): w4: Unknown system variable: t.asdf.
- tea.html(45): w5: Server json file not found: server.json.
- tea.html(45): w6: Unable to parse server.json.

The statictea program returns 0 when no message gets
output to standard error, else it returns 1.

Example of running statictea when a variable is missing:

template:

#+BEGIN_SRC
<!--$ nextline -->
You're a {webmaster}, I'm a {teaMaster}!
#+END_SRC

json:

#+BEGIN_SRC
{
  "webmaster": "html wizard"
}
#+END_SRC

stderr:

#+BEGIN_SRC
template.html(2): w1: Unknown server variable: teaMaster
#+END_SRC

result:

#+BEGIN_SRC
You're a html wizard, I'm a {teaMaster}!
#+END_SRC

You can write your own warning messages using the system t.result
set to stderr. In the following example a warning message is
written to standard error when the server admin variable is
missing. When it is not missing nothing gets output.

template:

#+BEGIN_SRC
<--$ nextline t.result = t.if( \-->
<--$ : t.exists(admin), "skip", "stderr") -->
warning: the admin variable is missing
#+END_SRC

** Run StaticTea

You run StaticTea from the command line. The example below shows
a typical invocation which specifies four file arguments, the
server json, the shared json, the template and the result.

- Warning messages go to standard error.
- If you don't specify the result argument, the result goes to standard out.
- If you specify "stdin" for the template, the template comes
  from stdin.

#+BEGIN_SRC
statictea --server server.json --shared shared.json --template template.html --result result.html
#+END_SRC

*** Options

The StaticTea command line options:

- help - show the help, usage and options.
- version - outputs the version number.
- server - the server json file(s), you can specify multiple.
- shared - the shared json file(s), you can specify multiple.
- template - the template file.
- result - the result file.
- update - update the template replace blocks.
- prepost - add a command prefix and postfix, you can specify multiple.

** StaticTea as a Filter

You can use the statictea command as a filter and pipe template
lines to it and see the result output on the screen.

Below is an example you can copy and paste into your terminal. It
creates a template.txt file containing two lines, then it creates
the server.json file containing one line, then it runs statictea
using those files and the result goes to the screen.

#+BEGIN_SRC
# create template file
cat <<EOF >template.txt
<!--$ nextline -->
hello {name}
EOF

# create server json file
cat <<EOF >server.json
{"name": "world"}
EOF

statictea --template template.txt --server server.json
#+END_SRC

If you copy and paste those lines to your terminal on Linux, it will look
like:

#+BEGIN_SRC
$ cat <<EOF >template.txt
> <!--$ nextline -->
> hello {name}
> EOF
$
$ cat <<EOF >server.json
> {"name": "world"}
> EOF
$
$ statictea --template template.txt --server server.json
hello world
#+END_SRC

The following example pipes template.txt to statictea. The result
goes to the screen.

#+BEGIN_SRC
cat template.txt | statictea --template stdin --server server.json

hello world
#+END_SRC

** Limits

There is no limit on the size of the template. However there are
several limits on variables and commands.

Having limit can seem restrictive but there are many reasons for
them.

- It makes testing the easier since you can test at the limit as
well as over the limit for warning messages.
- It's easier to optimize memory usage to a known value then for
  the general unlimited case.
- Engineering does not need to spend time supporting unlimited
  cases that are not used much.
- The users know and automatically stay within ranges for good
  performance.

You can overwride the t.maxLine limit but not others. Here are
the limits:

- t.maxLines - number of lines before the end block
  command. Useful when you forget to end the block. You can
  override this with bigger or smaller values.  Default 10.
- max command line length - 4096 characters.
- max variable name length - 100 characters.
- max literal string length - 256 characters.
- max json file size - xxx bytes.
- max number of items in a list - 500 items.  Use multiple lists
  if you need more.

** Encoding and Line Endings

Templates are utf-8 encoded or its ascii subset.  Three line
endings are supported on all platforms: LF, CR LF, or CR.
The template syntax only uses ascii.

** Ellipsize

You can "ellipsize" a string when it gets long. The following
example ellipsizes when a name is longer than 10 characters.

#+BEGIN_SRC
<!--$ # If the name is longer than 10 characters, -->
<!--$ # clip it to 7 and add "...".               -->
<!--$ nextline                                   \-->
<!--$ : cmp = t.cmp(len(name), 10);              \-->
<!--$ : name = t.case(cmd, name                  \-->
<!--$ : 1, t.concat(substr(name, 0, 7), "..."))   -->
#+END_SRC

** System Defaults

You can use the system variables in a replacement block to see
their default values. The following example shows the default
values of some of the system variables.

template:

#+BEGIN_SRC
<!--$ block -->
default t.list = {t.list}
default t.replaceContent = {t.replaceContent}
default t.maxLines = {t.maxLines}
<!--$ endblock -->
#+END_SRC

result:

#+BEGIN_SRC
default t.list = 0
default t.replaceContent = ""
default t.maxLines = 10
#+END_SRC

** Tea Info

Tea is the most popular manufactured drink consumed in the world,
equaling all others – including coffee, soft drinks, and alcohol
– combined. -- Wikipedia -- Macfarlane, Alan; Macfarlane, Iris
(2004). The Empire of Tea. The Overlook Press. p. 32. ISBN
978-1-58567-493-0.

** TODO support functions as parameters
** TODO use system variables instead of limits dictionary
** TODO Is leading whitespace prefixes needed?
** TODO document bracketed replacements to generalize them to include a format specifier
** TODO add example adding an s or not.
