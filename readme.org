#+TITLE: StaticTea
A template processor and language.

StaticTea produces a file from a template and json data.

Example hello world html template:

#+BEGIN_SRC
<!--$ nextline -->
hello {s.name}
#+END_SRC

The associated json data:

#+BEGIN_SRC
{"name": "world"}
#+END_SRC

The result:

#+BEGIN_SRC
hello world
#+END_SRC

[[#contents][èŒ¶]] (table of contents at the bottom)

* Advantages
:PROPERTIES:
:CUSTOM_ID: advantages
:END:

You can view, edit and validate your templates with its normal
tools as if they were static pages and at the same time share
common template fragments between templates.

The template designer has full control over the presentation
providing a clear separation of concerns. They can change the
look without changing the server.

[[#contents][èŒ¶]]

* How it Works
:PROPERTIES:
:CUSTOM_ID: how-it-works
:END:

You create a template and add command lines around your variable
content. This defines the replacement blocks.

In the replacement blocks you add variables in brackets for
substitutions.

In the commands you format the variables for the replacement
blocks.

You specify the commands so they look like comments for your
template type.

[[#contents][èŒ¶]]

* Commands
:PROPERTIES:
:CUSTOM_ID: commands
:END:

A StaticTea command marks a replacement block in the template and
it provides a place for your code statements.

- [[#nextline-command][nextline]] -- make substitutions in the next line
- [[#block-command][block]] â€”- make substitutions in the next block of lines
- [[#replace-command][replace]] -â€” replace the block with a variable
- [[#endblock-command][endblock]] -- end the block and replace commands
- : ([[#continue-command][continue]]) -- continue a command
- # ([[#comment-command][comment]]) -- code comment

[[#contents][èŒ¶]]

** Nextline Command
:PROPERTIES:
:CUSTOM_ID: nextline-command
:END:

The nextline command targets the line following it for
replacement. The targeted line is called the replacement block.

The following example's replacement block contains two variables,
drink and drinkType.

template:

#+BEGIN_SRC
<!--$ nextline -->
Drink {s.drink} -- {s.drinkType} is my favorite.
#+END_SRC

server json:

#+BEGIN_SRC
{
  "drink": "tea",
  "drinkType": "Earl Grey"
}
#+END_SRC

result:

#+BEGIN_SRC
Drink tea -- Earl Grey is my favorite.
#+END_SRC

[[#contents][èŒ¶]]

** Block Command
:PROPERTIES:
:CUSTOM_ID: block-command
:END:

The block command targets multiple lines for replacement. The
replacement block starts after the command and continues until
the endblock line is found. It behaves like the nextline command
except with multiple lines.

In the following example the block has three lines. The block
contains three replacement variables, weekday, name and time.

template:

#+BEGIN_SRC
<!--$ block -->
Join our tea party on
{s.weekday} at {s.name}'s
house at {s.time}.
<!--$ endblock -->
#+END_SRC

server json:

#+BEGIN_SRC
{
  "weekday": "Friday",
  "name": "John",
  "time": "5:00 pm"
}
#+END_SRC

result:

#+BEGIN_SRC
Join our tea party on
Friday at John's
house at 5:00 pm.
#+END_SRC

[[#contents][èŒ¶]]

** Replace Command
:PROPERTIES:
:CUSTOM_ID: replace-command
:END:

The replace command's replacement block gets replaced with the
t.content variable. Here is a simple example:

template:

#+BEGIN_SRC
<!--$ replace t.content=h.header -->
<!--$ endblock -->
#+END_SRC

shared json:

#+BEGIN_SRC
{
  "header": "<!doctype html>\n<html lang=\"en\">\n"
}
#+END_SRC

result:

#+BEGIN_SRC
<!doctype html>
<html lang="en">
#+END_SRC

The above example generates the correct result but it doesnâ€™t
work as a static template because the template is missing the
header lines.

You can add lines to the replace command's replacement block to
mirror the t.content variable so you can develop and test the
template as if it was a static file.

The replace command allows you to share common template lines between
templates and at the same time work with them as static pages.

Since you are duplicating content in the replacement block, when
you want to edit the shared text it will get out of sync. You can
update your templates using the [[#update-option][Update Option]].

If you don't assign the t.content variable, a warning is
generated, and the command behaves like a block command.  This is
good for testing changes you want to make to the shared value.

The following example uses a common header from the shared json data
and it mirrors it in the replacement block.

template:

#+BEGIN_SRC
<!--$ replace t.content=h.header -->
<!doctype html>
<html lang="en">
<!--$ endblock -â€”>
#+END_SRC

The shared variable may contain replacement content too.  Here is
an example of that:

template:

#+BEGIN_SRC
<!--$ replace t.content=h.header -->
<!DOCTYPE html>
<html lang="{s.languageCode}" dir="{s.languageDirection}">
<head>
<meta charset="UTF-8"/>
<title>{s.title}</title>
<--$ endblock -->
#+END_SRC

server json:

#+BEGIN_SRC
{
"languageCode": "en",
"languageDirection": "ltr",
"title": "Teas in England"
}
#+END_SRC

shared json:

#+BEGIN_SRC
{
  "header": "<!DOCTYPE html>
<html lang=\"{s.languageCode}\" dir=\"{s.languageDirection}\">
<head>
<meta charset=\"UTF-8\"/>
<title>{s.title}</title>\n"
}
#+END_SRC

result:

#+BEGIN_SRC
<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8"/>
<title>Teas in England</title>
#+END_SRC

[[#contents][èŒ¶]]

** Comment Command
:PROPERTIES:
:CUSTOM_ID: comment-command
:END:

You can comment templates with the comment command.  Comments
are line based and use the # character. They do not appear in the
result.

template:

#+BEGIN_SRC
<!--$ # The main tea groups. -->
There are five main groups of teas:
white, green, oolong, black, and pu'erh.
You make Oolong Tea in five time
intensive steps.
#+END_SRC

result:

#+BEGIN_SRC
There are five main groups of teas:
white, green, oolong, black, and pu'erh.
You make Oolong Tea in five time
intensive steps.
#+END_SRC

You can also comment in statements with # to the end of the line,
see the [[#syntax][Syntax]] section.


[[#contents][èŒ¶]]

** Continue Command
:PROPERTIES:
:CUSTOM_ID: continue-command
:END:

The continue command allows you to continue adding statements to
the nextline, block and replace commands.

In the following example the nextline command continues on a
second line and third line.

template:

#+BEGIN_SRC
$$ nextline
$$ : tea = "Earl Grey"
$$ : tea2 = "Masala chai"
{tea}, {tea2}
#+END_SRC

result:

#+BEGIN_SRC
Earl Grey, Masala chai
#+END_SRC

[[#contents][èŒ¶]]

** Endblock Command
:PROPERTIES:
:CUSTOM_ID: endblock-command
:END:

The endblock command ends the replacement block for the block and
replace commands. Only the endblock command ends them. All text
until the endblock is part of the replacement block. This
includes lines that look like commands. For example:

template:

#+BEGIN_SRC
<!--$ block -->
<!--$ # this is not a comment, just text -->
fake nextline
<!--$ nextline -->
<!--$ endblock -->
#+END_SRC

result:

#+BEGIN_SRC
<!--$ # this is not a comment, just text -->
fake nextline
<!--$ nextline -->
#+END_SRC

[[#contents][èŒ¶]]

* Replacement Block
:PROPERTIES:
:CUSTOM_ID: replacement-block
:END:

A replacement block is a group of contiguous lines in a template
between a command and its endblock. For the nextline command the
block is one line.

The block contains any number of bracketed variables for
substitution. Each variable gets replaced with its value.

You can repeat the block to make lists and other repeating
content. You control how many times the block repeats with the
t.repeat variable.  The t.row counts the number of times the
block has repeated and you use its value to customize each
repeated block.  See [[#trow][t.row]] for an example.

[[#contents][èŒ¶]]

* Statements
:PROPERTIES:
:CUSTOM_ID: statements
:END:

You create a new variable with a statement. A statement is an
expression consisting of a variable, an operator and a right hand
side.

The operator is an equal sign or an "&=". The equal sign appends
to a dictionary and the &= appends to a list.

The right hand side is either a variable, a string, a
number, list or a function.

Here are a few example statements:

#+BEGIN_SRC
tea = "Earl Grey"
num = 5
t.repeat = 2
b &= 3
nums = [1, 2, 3]
nameLen = len(s.name)
name = concat(substr(s.name, 0, 7), "...")
#+END_SRC

Statements are allowed on the nextline, block, continue and
replace commands.

All operations are done with functions. For example, to add 1 to
t.row you use the add function.

#+BEGIN_SRC
num = add(t.row, 1)
#+END_SRC

Statements are executed from top to bottom. You can use the warn
function to exit a statement early and use the return function to
exit a command early.

You can loop at the replacement block level and run the command's
statements multiple times using t.repeat, and vary the output using
t.row. Here is an example that loops three times and outputs 0, 1, 2.

template:

#+BEGIN_SRC
$$ nextline t.repeat = 3
{t.row}
#+END_SRC

result:

#+BEGIN_SRC
0
1
2
#+END_SRC

You have control over where the replacement block goes, either
the result file, standard out, standard error, or the log file
using the t.output variable.

If there is a syntax error or a function generates a warning, the
statement is skipped.

You can continue a long statement on the next line by using a "+"
character at the end.

You can have a bare if function on a statement which is an
exception to the rule, see [[#if-functions][If Functions]].

[[#contents][èŒ¶]]

* Syntax
:PROPERTIES:
:CUSTOM_ID: syntax
:END:

A template consists of command lines and non-command lines.  The
command lines are line oriented and they have the same form and
they are limited to 1024 bytes. There are no restrictions on the
non-command lines in a template.

Each command line is a comment to match the template type. The
beginning comment characters are called the prefix and the
optional ending comment characters are called the postfix. For
example, in an html template the prefix is "<!--$" and the
postfix is "-->". See [[#prefix-postfix][Prefix Postfix]] for more information.

From left to right a command line consists of:

- a prefix at column 1.
- a command name
- an optional statement
- an optional comment
- an optional plus continuation character
- an optional postfix
- the end of line, either \r\n or \n.

Here is a chart showing line components and where spaces
are allowed:

#+BEGIN_SRC
prefix
|     command  [statement]
|     |        |   [comment]
|     |        |   |       [continuation]
|     |        |   |       |[postfix]
|     |        |   |       ||  [newline]
|     |        |   |       ||  |
<!--$ nextline a=5 # set a +-->
     |        |            |
     |        |      no spaces at the end
     |        one required space
     optional spaces
#+END_SRC

The chart below shows a nextline command with three continuation
commands and three statements: a = 5, b = "tea" and c = "The Earl
of Grey".

#+BEGIN_SRC
prefix
|     command  statement
|     |        |         continuation
|     |        |         |
|     |        |         |postfix
|     | +------+         ||  newline
|     | |      |         ||  |
<!--$ nextline a = 5      -->
<!--$ : b = "tea"         -->
<!--$ : c = "The Earl of +-->
<!--$ : Grey"             -->
#+END_SRC

A statement starts one space after the command. You can use more
spaces but they are part of the statement. This is important when
you wrap quoted strings with a continuation.

Space isn't allowed before the prefix, after the continuation or
after the postfix or between the function name and its opening
parentheses. Here are a few single line examples:

#+BEGIN_SRC
$$ nextline
$$ nextline a=5
$$ nextline a = 5
$$ nextline num = len(s.tea_list)
$$ nextline  num = len( s.tea_list )
$$nextline
$$   nextline
#+END_SRC

The statements may flow between lines by using the continuation
plus character. The following two nextline commands are
equivalent:

#+BEGIN_SRC
<!--$ nextline com = "Bigelow Tea Company" -->

<!--$ nextline com = "Big+-->
<!--$ : elow Tea Company" -->
#+END_SRC

You can have blank statements that do nothing.

#+BEGIN_SRC
$$ nextline
$$ :
$$ : a = 5
$$ : # comment
#+END_SRC

[[#contents][èŒ¶]]

* Variables
:PROPERTIES:
:CUSTOM_ID: variables
:END:

You use variables to add variable content to your template in its
replacement blocks. A string variable gets replaced with its
value, the other variable types get replaced with their json
equivalent.

In the example below, "name" and "teas" are variables that are
defined in the command. Both variables are used in the
replacement block.

Template:

#+BEGIN_SRC
$$ block
$$ : name = "Eary Grey"
$$ : teas = list("Black", "Green", "Oolong")
Popular tea: {name}
Available kinds: {teas}
$$ endblock
#+END_SRC

Result:

#+BEGIN_SRC
Popular tea: Earl Grey
Available kinds: ["Black","Green","Oolong"]
#+END_SRC

You use variables in the t dictionary ("tea" variables), to
control where the output goes, how many times it repeats and
other aspects controlling a command.

A variable name starts with a letter followed by letters, digits
and underscores limited to a total of 64 ASCII characters. Some
single letters are reserved for important dictionaries, see the
next section.

#+BEGIN_SRC
a = 5
last_letter = "z"
nameLen = len(s.name)
#+END_SRC

Local variables and writable tea variables are cleared after
processing each replacement block.

You can append a new variable to a list or dictionary but you
cannot change an existing variable.

[[#contents][èŒ¶]]

* Dot Names
:PROPERTIES:
:CUSTOM_ID: dot-names
:END:

A dot name is a fully qualified variable name where variables are
connected with dots.

The server json variables are stored in the s dictionary. You
reference them with "s.", for example:

#+BEGIN_SRC
s.name
s.address
#+END_SRC

You can combine up to five variable names together to make a dot
name. For example:

#+BEGIN_SRC
s.tea.black.earlgrey.vanilla
#+END_SRC

A local variable is stored in the l (local) dictionary. L is
implied for an unqualified name.

All variables are stored in one of the reserved one letter top
level dictionaries f - u. Five are currently used: g, h, l, s, t.

You can use the unreserved letters a, b, c, d, e and v, w, x, y, z
for your variable names.

Reserved single letter variables:

- f -- Reserved
- g -- [[#global-variables][Global Variables]]
- h -- [[#json-variables][Shared Json Variables]]
- i, j, k -- Reserved
- l -- [[#local-variables][Local Variables]]
- m, n, o, p, q, r -- Reserved
- s -- [[#json-variables][Server Json Variables]]
- t -- [[#tea-variables][Tea Variables]]
- u -- Reserved

[[#contents][èŒ¶]]

** Json Variables
:PROPERTIES:
:CUSTOM_ID: json-variables
:END:

You pass variables to the template in json files where the top
level item is a dictionary.

The variables are defined by the top level dictionary items. Each
item's key is the name of a variable and the item's value is
the variables' value.

There are two types of json files, the server json and the shared
json. The server file populates the s dictionary and the
shared file populates the h dictionary.

You can use multiple server and shared json files by specifying
multiple files on the command line. The files are processed
left to right.

The json null values get converted to the 0. Json True and False
get converted to 1 and 0.

To give full control of the presentation to the template
designers, the server json shouldn't contain any presentation
data.

The shared json is created and maintained by the template
designer for sharing common template fragments and other
presentation needs.

[[#contents][èŒ¶]]

** Local Variables
:PROPERTIES:
:CUSTOM_ID: local-variables
:END:

You create local variables with template statements.  They are
local to the command where they are defined. You do not have to
specify a prefix for local variables but you can use l. They are
stored in the l dictionary. The local variables are cleared and
recalculated for each repeated block.

#+BEGIN_SRC
a = 5
pot = "black"
l.tea = "earl grey"
#+END_SRC

[[#contents][èŒ¶]]

** Global Variables
:PROPERTIES:
:CUSTOM_ID: global-variables
:END:

Like local variables, you create global variables with template
statements.  All commands have access to them and they are stored
in the g dictionary.

#+BEGIN_SRC
g.names &= entry.name
#+END_SRC

[[#contents][èŒ¶]]

** Tea Variables
:PROPERTIES:
    :CUSTOM_ID: tea-variables
    :END:

The tea variables control how the replacement block works and
they provide information about the system.  They are stored in
the t dictionary.

Tea variables:

- [[#targs][t.args]] -- arguments passed on the command line
- [[#tcontent][t.content]] -- content of the replace block
- [[#tmaxrepeat][t.maxRepeat]] -- maximum number of times to repeat the block
- [[#tmaxlines][t.maxLines]] -- maximum number of replacement block lines allowed
  before the endblock
- [[#toutput][t.output]] -- where the block output goes
- [[#trepeat][t.repeat]] -- how many times the block repeats
- [[#trow][t.row]] -- the current index number of a repeating block
- [[#tversion][t.version]] -- the StaticTea version number

[[#contents][èŒ¶]]

*** t.args
:PROPERTIES:
:CUSTOM_ID: targs
:END:

The read only t.args variable contains the arguments passed to
statictea on the command line.

For example using the command line below results in a t.args
value shown:

#+BEGIN_SRC
statictea -l -s server.json -j shared.json \
  -s server2.json -j shared2.json \
  -p 'abc$,def' -p '$$' \
  -t template.html -r result.html

t.args => {
  "help":0,
  "version":0,
  "update":0,
  "log":1,
  "serverList":["server.json","server2.json"],
  "sharedList":["shared.json","shared2.json"],
  "resultFilename":"result.html",
  "templateFilename":"template.html",
  "logFilename":"",
  "prepostList":[["abc$","def"],["$$",""]]
}
#+END_SRC

[[#contents][èŒ¶]]

*** t.content
:PROPERTIES:
:CUSTOM_ID: tcontent
:END:

The t.content variable determines the content used for the
replace command's whole replacement block.

#+BEGIN_SRC
t.content = h.header
#+END_SRC

You use [[#update-option][Update Option]] to keep the template's blocks in sync with
their variables.

When t.content is not set, the command behaves like a block
command except a warning message is output. This is good for
testing changes you want to make to the shared value and the
warning reminds you to set the variable when you're done testing.

The variable only applies to the replace command. See the
[[#replace-command][replace command]] section for an example.

[[#contents][èŒ¶]]

*** t.maxRepeat
:PROPERTIES:
:CUSTOM_ID: tmaxrepeat
:END:

The t.maxRepeat variable determines the maximum times a block can
repeat.  The default is 100. You can increase it to repeat more
times. You cannot assign a number to t.repeat bigger than
maxRepeat.

It prevents the case where you mistakenly assign a giant number,
and it allows you to design your template to work well for the
expected range of blocks.

[[#contents][èŒ¶]]

*** t.maxLines
:PROPERTIES:
:CUSTOM_ID: tmaxlines
:END:

The t.maxLines variable determines the maximum lines in a
replacement block.

StaticTea reads lines looking for the endblock.  By default, if
it is not found in 50 lines, the 50 lines are used for the block
and a warning is output. This catches the case where you forget
the endblock command. You can increase or decrease the value.

#+BEGIN_SRC
<!--$ block t.maxLines=200 -->
#+END_SRC

[[#contents][èŒ¶]]

*** t.output
:PROPERTIES:
    :CUSTOM_ID: toutput
    :END:

The t.output variable determines where the block output goes.  By
default it goes to the result file.

- "result" -- to the result file (default)
- "stdout" -- to standard out
- "stderr" -- to standard error
- "log" -- to the log file
- "skip" -- to the bit bucket

[[#contents][èŒ¶]]

*** t.repeat
    :PROPERTIES:
    :CUSTOM_ID: trepeat
    :END:

The t.repeat variable is an integer that tells how many times to
repeat the block. A value of 0 means don't show the block at
all. If you don't set it, the block repeats one time.

Each time the block repeats the local variables get cleared then
recalculated.

The t.row variable counts the number of times the block repeats
and is used with t.repeat to customize each block.

You cannot assign a number bigger than t.maxRepeat to
t.repeat. You can set t.maxRepeat to anything you want, the
default is 100.

When you set t.repeat to 0, the command exits.  The commands'
statements following are not run. This makes a difference when
the command has side effects, like setting global variables. You
can move the "t.repeat = 0" line around to compensate.

For the following example, the number of items in teaList is
assigned to the t.repeat variable which outputs the block five
times.

template:

#+BEGIN_SRC
<!--$ nextline t.repeat = len(s.teaList) -->
<!--$ : tea = get(s.teaList, t.row) -->
 * {tea}
#+END_SRC

server json:

#+BEGIN_SRC
{
"teaList": [
  "Black",
  "Green",
  "Oolong",
  "Sencha",
  "Herbal"
]
}
#+END_SRC

result:

#+BEGIN_SRC
 * Black
 * Green
 * Oolong
 * Sencha
 * Herbal
#+END_SRC

The following example builds an html select list of tea companies
with the Twinings company selected and it shows how to access
values from dictionaries.

template:

#+BEGIN_SRC
<h3>Tea Companies</h3>
<select>
<!--$ block t.repeat=len(s.companyList) -->
<!--$ : d = get(s.companyList, t.row) -->
<!--$ : selected = get(d, "selected", 0) -->
<!--$ : current = if1(selected, " selected=\"selected\"", "") -->
  <option{current}>{d.company}</option>
$$ endblock
</select>
#+END_SRC

server json:

#+BEGIN_SRC
{
"companyList": [
  {"company": "Lipton"},
  {"company": "Tetley"},
  {"company": "Twinings", "selected": 1},
  {"company": "American Tea Room"},
  {"company": "Argo Tea"},
  {"company": "Bigelow Tea Company"}
]
}
#+END_SRC

result:

#+BEGIN_SRC
<h3>Tea Companies</h3>
<select>
  <option>Lipton</option>
  <option>Tetley</option>
  <option selected="selected">Twinings</option>
  <option>American Tea Room</option>
  <option>Argo Tea</option>
  <option>Bigelow Tea Company</option>
</select>
#+END_SRC

Setting t.repeat to 0 is good for building test lists.

When you view the following template fragment in a browser it
shows one item in the list.

template:

#+BEGIN_SRC
<h3>Tea</h3>
<ul>
<!--$ nextline t.repeat = len(s.teaList)-->
<!--$ : tea = get(s.teaList, t.row) -->
  <li>{tea}</li>
</ul>
#+END_SRC

server json:

#+BEGIN_SRC
{
"teaList": [
  "Black",
  "Green",
  "Oolong",
  "Sencha",
  "Herbal"
]
}
#+END_SRC

To create a static page that has more products for better testing
you could create a test list of teas using t.repeat of 0. It will
appear when testing but not when generating the final result. In
the following example the test list will show: {tea}, Chamomile,
Chrysanthemum, White, and Puer.

template:

#+BEGIN_SRC
<h3>Tea</h3>
<ul>
<!--$ nextline t.repeat = len(s.teaList) -->
<!--$ : tea = get(s.teaList, t.row) -->
  <li>{tea}</li>
<!--$ block t.repeat = 0 -->
  <li>Chamomile</li>
  <li>Chrysanthemum</li>
  <li>White</li>
  <li>Puer</li>
<!--$ endblock -->
</ul>
#+END_SRC

result:

#+BEGIN_SRC
<h3>Tea</h3>
<ul>
  <li>Black</li>
  <li>Green</li>
  <li>Oolong</li>
  <li>Sencha</li>
  <li>Herbal</li>
</ul>
#+END_SRC

[[#contents][èŒ¶]]

*** t.row
:PROPERTIES:
    :CUSTOM_ID: trow
    :END:

The t.row read only variable counts the number of times the
replacement block repeats.

You use it to format lists and other repeating content in the
template.

Here is an example using the row variable.  In the example, row
is used in three places.

template:

#+BEGIN_SRC
<ul>
<!--$ nextline t.repeat=len(s.companies)-->
<!--$ : company = get(s.companies, t.row) -->
<!--$ : num = add(t.row, 1) -->
  <li id="r{t.row}">{num}. {company}</li>
</ul>
#+END_SRC

server json:

#+BEGIN_SRC
{
  "companies": [
    "Mighty Leaf Tea",
    "Numi Organic Tea",
    "Peet's Coffee & Tea",
    "Red Diamond"
  ]
}
#+END_SRC

result:

#+BEGIN_SRC
<ul>
  <li id="r0">1. Mighty Leaf Tea</li>
  <li id="r1">2. Numi Organic Tea</li>
  <li id="r2">3. Peet's Coffee & Tea</li>
  <li id="r3">4. Red Diamond</li>
</ul>
#+END_SRC

[[#contents][èŒ¶]]

*** t.version
:PROPERTIES:
:CUSTOM_ID: tversion
:END:

The read only t.version variable contains the current version
number of StaticTea. See the [[#cmpversion][cmpVersion]] function for more
information.

[[#contents][èŒ¶]]

* Types
:PROPERTIES:
:CUSTOM_ID: types
:END:

StaticTea variable types:

# Note: these links don't work in emacs but they work in Github.
- [[#string][string]]
- [[#int][int]]
- [[#float][float]]
- [[#dict][dict]]
- [[#list][list]]

[[#contents][èŒ¶]]

** String
:PROPERTIES:
:CUSTOM_ID: string
:END:

A string is an immutable sequence of unicode characters. You
define a literal string with double quotes.

The example below defines a literal string and assigns it to the
variable str:

#+BEGIN_SRC
str = "You can store black teas longer than green teas."
#+END_SRC

Strings are encoded as UTF-8 and invalid byte sequences generate
a warning.

Strings follow the same escaping rules as json strings.  You can
escape 8 special control characters using a slash followed by a
letter. Special escape letters:

- " -- quotation mark (U+0022)
- \ -- reverse solidus (U+005C)
- / -- solidus (U+002F)
- b -- backspace (U+0008)
- f -- form feed (U+000C)
- n -- line feed (U+000A)
- r -- carriage return (U+000D)
- t -- tab (U+0009)

Examples with escaping:

- "ending newline\n"
- "tab \t in the middle"
- "Mad Hatter: \\\"... you must have a cup of tea!\\\" - 'Alice In Wonderland'."
- "Unicode tea character 'èŒ¶' is '\u8336'"
- "smiley face ðŸ˜€ by escaping: \uD83D\uDE00."

You can enter any unicode value with \u and four hex digits or, for
values greater the U-FFFF, two pairs.  The two pairs are
called surrogate pairs.

#+BEGIN_SRC
The unicode code point U-8336 is èŒ¶ and escaped is \u8336.
The unicode code point U-1F600 is ðŸ˜€ and escaped is \uD83D\uDE00.
#+END_SRC

You can generate the surrogate pair for a unicode code point
using Russell Cottrell's surrogate pair calculator:
[[http://russellcottrell.com/greek/utilities/SurrogatePairCalculator.htm][
Surrogate Pair Calculator]].

[[#contents][èŒ¶]]

** Int
:PROPERTIES:
:CUSTOM_ID: int-type
:END:

An int is a 64 bit signed integer.  Plus signs are not used
with numbers. You can use underscores in long number literals to
make them more readable.

Example numbers:

#+BEGIN_SRC
12345
0
-8823
42
1_234_567
#+END_SRC

[[#contents][èŒ¶]]

** Float
:PROPERTIES:
:CUSTOM_ID: float-type
:END:

A float is a 64 bit real number, it has a decimal point and
starts with a digit or minus sign. You can use underscores in
long number literals to make them more readable.

Example floats:

#+BEGIN_SRC
3.14159
24.95
0.123
-34.0
1_234.56
#+END_SRC

[[#contents][èŒ¶]]

** Dict
:PROPERTIES:
:CUSTOM_ID: dict-type
:END:

The dict type is an ordered key value store with fast lookup. It
maps a string key to a value which can be any type. The dict is
ordered by insertion order.

- You create a dict in a json file or with the dict function.
- You append to a dict when you create new variables with a statement.
- You access dict items with dot names or with the get
  function.

In the following json data, the container element is a dictionary and
the d element is a dictionary.  The d dictionary has two key/value
pairs, ("x", 100) and ("y", 200).

server json:

#+BEGIN_SRC
{
  "a": 1,
  "b": 2,
  "d": {
    "x": 100,
    "y": 200
  }
}
#+END_SRC

If the key is a valid variable name, you can access it using dot
notation. For the json example above, you can access the data as:

#+BEGIN_SRC
s.a => 1
s.b => 2
s.d.x => 100
s.d.y => 200
#+END_SRC

Or you access the elements with the get function. The get
function has an optional default parameter and it works with keys
that don't look like variables.  Examples:

#+BEGIN_SRC
get(s, "a") => 1
get(s, "b") => 2
get(s, "d") => dict("x", 100, "y", 200)

d = get(s, "d")

get(d, "x") => 100
get(d, "y") => 200
get(d, "missing", 99) => 99
#+END_SRC

You append to a dictionary when you create a new variable. In the
following example the "a" and "str" elements are appended to the
d dictionary.

#+BEGIN_SRC
d = dict()
d.a = 5
d.str = "black"

d => {
  "a": 5,
  "str": "black"
}
#+END_SRC

[[#contents][èŒ¶]]

** List
:PROPERTIES:
:CUSTOM_ID: list-type
:END:

A list contains a sequence of values of any type.

You can create a list with the list function or with brackets:

#+BEGIN_SRC
a = list()
a = list(1)
a = list(1, 2, 3)
a = list("a", 5, "b")

a = []
a = [1]
a = [1, 2, 3]
a = ["a", 5, "b"]
#+END_SRC

You can append to a list by assigning a value to a variable with
the &= operator.  It will create the list if it doesn't exist. In
the example below, the first line creates the list variable then
assign "black" to it.  The second line appends "green":

#+BEGIN_SRC
teas &= "black"
teas &= "green"
teas => ["black", "green"]
#+END_SRC

The next example creates a g.names list from names contained in a
list of dictionaries:

#+BEGIN_SRC
$$ block
$$ : t.repeat = len(s.entries)
$$ : entry = get(s.entries, t.row)
$$ : g.names &= entry.name
$$ endblock
#+END_SRC

You can access list elements with the get function:

#+BEGIN_SRC
list = list(1, 3.3, "a")
get(list, 0) => 1
get(list, 1) => 3.3
get(list, 2) => "a"
get(list, 3, 99) => 99
#+END_SRC

[[#contents][èŒ¶]]

* Run StaticTea
:PROPERTIES:
:CUSTOM_ID: run-statictea
:END:

You run StaticTea from the command line. You specify the template
file to process along with the json data files and a result file
is generated.

- Warning messages go to standard error.
- If you don't specify the result file, the result goes to standard out.
- If you specify "stdin" for the template, the template comes
  from stdin.
- StaticTea returns success, return code 0, when there are no
  warning messages, else it returns 1.

The example below shows a typical invocation which specifies four
file arguments, the server json, the shared json, the template
and the result.

#+BEGIN_SRC
statictea \
  --server server.json \
  --shared shared.json \
  --template template.html \
  --result result.html
#+END_SRC

The StaticTea command line options:

- help -- show options and usage then quit.
- version -- outputs the version number.
- server -- a server json file. You can specify multiple server
  options.
- shared -- a shared json file. You can specify multiple shared
  options.
- template -- the template file, or "stdin" for input from
  standard input.
- result -- the result file. When not specified, standard out is
  used.
- update -- update the template replace blocks. See the
  [[#replace-command][Replace Command]].
- prepost -- a command prefix and postfix. You can specify
  multiple prepost options. When you specify a value, the
  defaults are no longer used. See the [[#prefix-postfix][Prefix
  Postfix]] section.
- log - log to a file, see [[#logging][Logging]] section.

[[#contents][èŒ¶]]

* Miscellaneous
:PROPERTIES:
:CUSTOM_ID: miscellaneous
:END:

Miscellaneous topics:

- [[#warning-messages][Warning Messages]]
- [[#if-functions][If Functions]]
- [[#prefix-postfix][Prefix Postfix]]
- [[#encoding-and-line-endings][Encoding and Line Endings]]
- [[#update-option][Update Option]]
- [[#logging][Logging]]
- [[#module-docs][Module Docs]]
- [[#html-formatted-json][HTML Formatted Json]]
- [[#nimble-tasks][Nimble Tasks]]
- [[#stf-runner][Stf Runner]]
- [[#example-templates][Example Templates]]

** Warning Messages
:PROPERTIES:
   :CUSTOM_ID: warning-messages
   :END:

When StaticTea detects a problem, a warning message is written to
standard error, the problem is skipped, and processing
continues.

For example, if a variable in a replacement block is used but it
doesn't exist, the bracketed variable remains as is in the
result, and a message is output to standard error. There are many
other potential warnings.

Itâ€™s good style to change your template to be free of messages.

Each warning message shows the file and line number where the
problem happened.

example messages:

- tea.html(0): w15: "Unable to parse the json file. Skipping file: test.json.
- tea.html(45): w61: No space after the command.

Statement errors generate multi-line messages showing the
statement and problem location, for example:

#+BEGIN_SRC
template.html(16): w33: Expected a string, number, variable, list or function.
statement: tea = len("abc",)
                           ^
#+END_SRC

Warnings are suppressed after the first 32. When you reach the
limit you will see the message:

#+BEGIN_SRC
You reached the maximum number of warnings, suppressing the rest.
#+END_SRC

Statictea returns success, return code 0, when there are no
warning messages, else it returns 1. If you want to treat
warnings as errors, check for the 1 return code.

Example of running statictea when a variable is missing:

template:

#+BEGIN_SRC
<!--$ block -->
You're a {s.webmaster},
I'm a {s.teaMaster}!
<!--$ endblock -->
#+END_SRC

server json:

#+BEGIN_SRC
{
 "webmaster": "html wizard"
}
#+END_SRC

stderr:

#+BEGIN_SRC
template.html(3): w58: The replacement variable doesn't exist: s.teaMaster.
#+END_SRC

result:

#+BEGIN_SRC
You're a html wizard,
I'm a {s.teaMaster}!
#+END_SRC

You can generate your own warnings messsage using the warn
function. Like the system warning messages it skips the current
statement, increments the warning count and produces a non-zero
return code.

For example if the server item list should contain one or more
items, you could output a warning when it's zero:

#+BEGIN_SRC
if0(len(s.items), warn("no items"))
#+END_SRC

[[#contents][èŒ¶]]

** If Functions
:PROPERTIES:
   :CUSTOM_ID: if-functions
   :END:

The if0 and if1 functions are special in a couple of ways. They
conditionally evaluate their arguments and they can be used in a
statement bare without an assignment.

You use the bare form with the warn and return functions for
their side effects.

The if functions evaluate the condition parameter first to
determine which parameter to evaluate next and the non-matching
parameter is skipped.  This is important when you use the warn or
return functions to control the statement flow.  The other
functions evaluate all their arguments before passing them to the
function.

In the following example do1 is executed and doOther is skipped.

#+BEGIN_SRC
a = if1(1, do1(), doOther())
#+END_SRC

The next example has a warn call in it.  If all the arguments
were evaluated, the warn would run everytime.

#+BEGIN_SRC
a = if1(1, do1(), warn("not one"))
#+END_SRC

The warn and return functions modify the statement flow.  The
warn function skips the current statement and the return function
ends the current block.

The next example is a bare if.  It generates a warning when cond
is 1.

#+BEGIN_SRC
if1(s.cond, warn("s.cond is 1"))
#+END_SRC

[[#contents][èŒ¶]]

** Prefix Postfix
:PROPERTIES:
   :CUSTOM_ID: prefix-postfix
   :END:

You make the template commands look like comments tailored for
your template file type. This allows you to edit the template
using its native editors and run other native tools.  For example,
you can edit a StaticTea html template with an html editor and
validate it online with w3.org's validator.

Comment syntax varies depending on the type of template file and
sometimes depending on the location within the file. StaticTea
supports several varieties and you can specify others.

You want to distinguish StaticTea commands from normal comments
when you create your own. The convention is to add a $ as the
last character of the prefix and only use $ with StaticTea
commands and space for normal comments.

Some file types, like markdown, don't support comments, for
them use $$.

Built in Prefixes:

- markdown: $$
- html: <!--$ and -->
- html inside a textarea: &lt;!--$ and --&gt;
- bash: #$
- config files: ;$
- C++: //$
- org mode: # $
- C language: â€‹/\star$ and \starâ€‹/

You can define other comment types on the command line using the
prepost option one or more times. When you specify your own
prepost values, the defaults no longer exist so you have control
of which prefixes get used.

You specify the prepost option with the prefix separated from the
postfix with a comma and the postfix is optional,
'prefix[,postfix]'. A prefix and postfix contain 1 to 20 ASCII
characters including spaces but without control characters or
commas.

Note: It's recommended that you use single quotes so the command
line doesn't interpret $ as an environment variable.

examples:

#+BEGIN_SRC
--prepost 'pre$,post'
--prepost 'a$,b'
--prepost '@$,|'
--prepost '#[$,]#'
--prepost '# $'
#+END_SRC

[[#contents][èŒ¶]]

** Encoding and Line Endings
:PROPERTIES:
:CUSTOM_ID: encoding-and-line-endings
:END:

Templates are treated as a stream of bytes. The embedded
statictea commands only use ASCII except for quoted strings which
are UTF-8 encoded.

Two line endings are supported on all platforms: LF, and CR/LF
and they are preserved.

The maximum command line length is 1024 bytes. There is
no limit on non-command lines.

Since line endings are preserved and there are no encoding or
line length restrictions on non-command lines, you can make
templates out of binary or mixed binary and text files like EPS
or PDF files.

[[#contents][èŒ¶]]

** Update Option
:PROPERTIES:
:CUSTOM_ID: update-option
:END:

The update option updates the template's replace blocks to
match their t.content text.  The text normally comes from the
shared template files but it doesn't have to.

You use this to keep the template blocks in sync with the shared
content so you can work with them as static pages.

If the t.content does not end with a newline, one is added so the
endcommand starts on a new line.

The following example shows a typical invocation:

#+BEGIN_SRC
statictea \
  --server server.json \
  --shared shared.json \
  --template template.html \
  --update
#+END_SRC

If the template content comes from the standard input stream the
result goes to the standard output stream.

See the [[#replace-command][replace command]] for update examples.

[[#contents][èŒ¶]]

** Logging
:PROPERTIES:
   :CUSTOM_ID: logging
   :END:

Statictea writes statistics to the log file.  Template commands
can also write to the log file.

Log information is appended to the file.  When the file size
exceeds 1 GB, a warning message is generated each time a template
is processed.

Logging is off by default. You turn it on with the log option.
If you don't specify a filename, the log lines are written to the
platform default location:

- Mac: ~/Library/Logs/statictea.log
- Other: ~/statictea.log

You can specify a full path. If you don't include path
information, the log is written to the current directory.

#+BEGIN_SRC
statictea --log mylog.txt
#+END_SRC

When you write a replacement block to the log file, the template
file and line number of the replacement block appear there.

#+BEGIN_SRC
2021-12-07 22:03:59.908; statictea.nim(42); Starting: argv: @["-l log.txt", "-t tmpl.txt", "-r result.txt"]
2021-12-07 22:03:59.908; statictea.nim(43); Version: 0.1.0
2021-12-07 22:03:59.909; tmpl.txt(2); â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
2021-12-07 22:03:59.909; tmpl.txt(3); â”‚log blockâ”‚
2021-12-07 22:03:59.909; tmpl.txt(4); â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
2021-12-07 22:03:59.910; statictea.nim(66); Warnings: 0
2021-12-07 22:03:59.910; statictea.nim(69); Return code: 0
2021-12-07 22:03:59.910; statictea.nim(70); Done
#+END_SRC

[[#contents][èŒ¶]]

** Module Docs
:PROPERTIES:
   :CUSTOM_ID: module-docs
   :END:

You can read the StaticTea source code documentation in Github
because it is formatted as github markdown. Statictea created the
markdown files from the source code's embedded doc comments.

- [[docs/index.md][StaticTea Source Docs]] --- Index to the
  source code documents.

The nimble *docsix* task builds the module index by running the
following process:

1. create a json file from the doc comments at the top of all the source files
2. format the json as markdown using the
   [[templates/nimModuleIndex.md][nimModuleIndex.md]] statictea
   template. Click the link then "View Raw".

The nimble *docs* task builds the module markdown files by running
the following process for each module:

1. create a json file of a module's docs using nim's jsondoc command
2. format the json as markdown using the [[templates/nimModule.md][nimModule.md]] statictea template

[[#contents][èŒ¶]]

** HTML Formatted Json
:PROPERTIES:
   :CUSTOM_ID: html-formatted-json
   :END:

The nim jsondoc command produces html formatted json data.  Our
desired final format is Github markdown so having html
presentation data in the json is a problem.

It was discovered that single paragraph comments are mostly
unformatted.  This is the basis for a workaround. You avoid the
formatting by making all the documentation look like one
paragraph by inserting some symbols in strategic places.

Workaround Rules:

- use @: at the beginning of lines, except the first line.
- use ~~~ to begin a code block
- use ~~~~ to end a code block
- use @{ for [ in an http link
- use }@ for ] in an http link
- use @@: for a : in an http link
- use @. for *
- use @! for |

Change:

#+BEGIN_SRC
[Semantic Versioning](https://semver.org/)
#+END_SRC
to:

#+BEGIN_SRC
@{Semantic Versioning}@(https@@://semver.org/)
#+END_SRC

See the [[src/runFunction.nim][runFunction.nim]] file for other examples.

[[#contents][èŒ¶]]

** Nimble Tasks
:PROPERTIES:
   :CUSTOM_ID: nimble-tasks
   :END:

You can run commands to build, test, make docs etc. using nimble
task commands. Run them from the statictea root folder. The n
task lists the available tasks.

#+BEGIN_SRC
cd ~/code/statictea
nimble n
#+END_SRC

Nimble Tasks:

#+BEGIN_SRC
n          Show available tasks.
test       Run one or more tests; specify part of test filename.
other      Run other tests and build tests.
b          Build the statictea exe.
docsall    Create all the docs, docsix, docs, readmefun, dot.
docs       Create one or more markdown docs; specify part of source filename.
docsix     Create markdown docs index.
json       Display one or more source file's json doc comments; specify part of name.
jsonix     Display markdown docs index json.
stfix      Display markdown testfiles index json.
readmefun  Create the readme function section.
dot        Create a dependency graph of the StaticTea source.
dot2       Create a dependency graph of the system modules used by StaticTea.
tt         Compile and run t.nim.
tree       Show the project directory tree.
args       Show command line arguments.
br         Build the stf test runner.
rt         Run one or more stf tests in testfiles; specify part of the name.
stfrm      Create testfiles readme.md.
newstf     Create new stf as a starting point for a new test.
runhelp    Show the runner help text with glow.
helpme     Show the statictea help text.
remote     Check whether the remote code needs updating.
cmdline    Build cmdline.
#+END_SRC

[[#contents][èŒ¶]]

** Stf Runner
:PROPERTIES:
   :CUSTOM_ID: stf-runner
   :END:

The Single Test File (stf) runner is a standalone program used
for testing command line applications. A stf file contains the
test which the runner executes to determine whether the test
passed. The stf files are designed to look good in markdown
readers.

The stf file contains instructions for creating files, running
files and comparing files. See the runner help message for more
information about stf files.

The testfiles folder contains statictea stf files.

- [[testfiles/readme.md][StaticTea Stf Files]] --- Index to the
  stf files.

[[#contents][èŒ¶]]

** Example Templates
:PROPERTIES:
   :CUSTOM_ID: example-templates
   :END:

You can examine simple self contained statictea templates
in the testfiles folder.

The [[#module-docs][Module Docs]] section has more complex examples.

[[#contents][èŒ¶]]

* Functions
:PROPERTIES:
:CUSTOM_ID: functions
:ORDERED:  t
:END:

Functions allow you to format variables for presentation.  They
return a value that you assign to a variable or pass to another
function.

This section was created from the nim source code by running the
readmefun nimble task which uses the StaticTea template
[[templates/readmeFuncSection.org][readmeFuncSection.org]].

List of functions:

# Dynamic Content Begins
- [[#add][add]] -- Add two floats.
- [[#add][add]] -- Add two integers.
- [[#case][case]] -- Compare integer cases and return the matching value.
- [[#case][case]] -- Compare string cases and return the matching value.
- [[#cmpVersion][cmpVersion]] -- Compare two StaticTea version numbers.
- [[#cmp][cmp]] -- Compare two floats.
- [[#cmp][cmp]] -- Compare two ints.
- [[#cmp][cmp]] -- Compare two strings.
- [[#concat][concat]] -- Concatentate two strings.
- [[#dict][dict]] -- Create a dictionary from a list of key, value pairs.
- [[#dup][dup]] -- Duplicate a string x times.
- [[#exists][exists]] -- Determine whether a key exists in a dictionary.
- [[#find][find]] -- Find the position of a substring in a string.
- [[#float][float]] -- Create a float from an int.
- [[#float][float]] -- Create a float from a number string.
- [[#get][get]] -- Get a dictionary value by its key.
- [[#get][get]] -- Get a list value by its index.
- [[#githubAnchor][githubAnchor]] -- Create Github anchor names from heading names.
- [[#githubAnchor][githubAnchor]] -- Create a Github anchor name from a heading name.
- [[#if0][if0]] -- If the condition is 0, return the second parameter, else return the third parameter.
- [[#if1][if1]] -- If the condition is 1, return the second parameter, else return the third parameter.
- [[#int][int]] -- Create an int from a float.
- [[#int][int]] -- Create an int from a number string.
- [[#joinPath][joinPath]] -- Join the path components with a path separator.
- [[#join][join]] -- Join a list of strings with a separator.
- [[#keys][keys]] -- Create a list from the keys in a dictionary.
- [[#len][len]] -- Number of elements in a dictionary.
- [[#len][len]] -- Number of elements in a list.
- [[#len][len]] -- Number of unicode characters in a string.
- [[#list][list]] -- Create a list of values.
- [[#lower][lower]] -- Lowercase a string.
- [[#path][path]] -- Split a file path into its component pieces.
- [[#replace][replace]] -- Replace a substring specified by its position and length with another string.
- [[#replaceRe][replaceRe]] -- Replace multiple parts of a string using regular expressions.
- [[#return][return]] -- Return the given value and control command looping.
- [[#slice][slice]] -- Extract a substring from a string by its position and length.
- [[#sort][sort]] -- Sort a list of values of the same type.
- [[#sort][sort]] -- Sort a list of lists.
- [[#sort][sort]] -- Sort a list of dictionaries.
- [[#type][type]] -- Return the parameter type, one of: int, float, string, list, dict.
- [[#values][values]] -- Create a list out of the values in the specified dictionary.
- [[#warn][warn]] -- Return a warning message and skip the current statement.

[[#contents][èŒ¶]]

** add
:PROPERTIES:
:CUSTOM_ID: add
:END:

Add two floats. A warning is generated on overflow.

#+BEGIN_SRC
add(a: float, b: float) float
#+END_SRC

Examples:

#+BEGIN_SRC
add(1.5, 2.3) => 3.8
add(3.2, -2.2) => 1.0
#+END_SRC

[[#contents][èŒ¶]]

** add
:PROPERTIES:
:CUSTOM_ID: add
:END:

Add two integers. A warning is generated on overflow.

#+BEGIN_SRC
add(a: int, b: int)) int
#+END_SRC

Examples:

#+BEGIN_SRC
add(1, 2) => 3
add(3, -2) => 1
add(-2, -5) => -7
#+END_SRC

[[#contents][èŒ¶]]

** case
:PROPERTIES:
:CUSTOM_ID: case
:END:

Compare integer cases and return the matching value.  It takes a
main integer condition, a list of case pairs and an optional
value when none of the cases match.

The first element of a case pair is the condition and the
second is the return value when that condition matches the main
condition. The function compares the conditions left to right and
returns the first match.

When none of the cases match the main condition, the default
value is returned if it is specified, otherwise a warning is
generated.  The conditions must be integers. The return values
can be any type.

#+BEGIN_SRC
case(condition: int, pairs: list, optional default: any) any
#+END_SRC

Examples:

#+BEGIN_SRC
cases = list(0, "tea", 1, "water", 2, "beer")
case(0, cases) => "tea"
case(1, cases) => "water"
case(2, cases) => "beer"
case(2, cases, "wine") => "beer"
case(3, cases, "wine") => "wine"
#+END_SRC

[[#contents][èŒ¶]]

** case
:PROPERTIES:
:CUSTOM_ID: case
:END:

Compare string cases and return the matching value.  It takes a
main string condition, a list of case pairs and an optional
value when none of the cases match.

The first element of a case pair is the condition and the
second is the return value when that condition matches the main
condition. The function compares the conditions left to right and
returns the first match.

When none of the cases match the main condition, the default
value is returned if it is specified, otherwise a warning is
generated.  The conditions must be strings. The return values
can be any type.

#+BEGIN_SRC
case(condition: string, pairs: list, optional default: any) any
#+END_SRC

Examples:

#+BEGIN_SRC
cases = list("tea", 15, "water", 2.3, "beer", "cold")
case("tea", cases) => 15
case("water", cases) => 2.3
case("beer", cases) => "cold"
case("bunch", cases, "other") => "other"
#+END_SRC

[[#contents][èŒ¶]]

** cmpVersion
:PROPERTIES:
:CUSTOM_ID: cmpVersion
:END:

Compare two StaticTea version numbers. Returns -1 for less, 0 for
equal and 1 for greater than.

#+BEGIN_SRC
cmpVersion(versionA: string, versionB: string) int
#+END_SRC

StaticTea uses [[https://semver.org/][Semantic Versioning]]
with the added restriction that each version component has one
to three digits (no letters).

Examples:

#+BEGIN_SRC
cmpVersion("1.2.5", "1.1.8") => 1
cmpVersion("1.2.5", "1.3.0") => -1
cmpVersion("1.2.5", "1.2.5") => 0
#+END_SRC

[[#contents][èŒ¶]]

** cmp
:PROPERTIES:
:CUSTOM_ID: cmp
:END:

Compare two floats. Returns -1 for less, 0 for
equal and 1 for greater than.

#+BEGIN_SRC
cmp(a: float, b: float) int
#+END_SRC

Examples:

#+BEGIN_SRC
cmp(7.8, 9.1) => -1
cmp(8.4, 8.4) => 0
cmp(9.3, 2.2) => 1
#+END_SRC

[[#contents][èŒ¶]]

** cmp
:PROPERTIES:
:CUSTOM_ID: cmp
:END:

Compare two ints. Returns -1 for less, 0 for equal and 1 for
 greater than.

#+BEGIN_SRC
cmp(a: int, b: int) int
#+END_SRC

Examples:

#+BEGIN_SRC
cmp(7, 9) => -1
cmp(8, 8) => 0
cmp(9, 2) => 1
#+END_SRC

[[#contents][èŒ¶]]

** cmp
:PROPERTIES:
:CUSTOM_ID: cmp
:END:

Compare two strings. Returns -1 for less, 0 for equal and 1 for
greater than.

You have the option to compare case insensitive. Case sensitive
is the default.

#+BEGIN_SRC
cmp(a: string, b: string, optional insensitive: int) int
#+END_SRC

Examples:

#+BEGIN_SRC
cmp("coffee", "tea") => -1
cmp("tea", "tea") => 0
cmp("Tea", "tea") => 1
cmp("Tea", "tea", 0) => 1
cmp("Tea", "tea", 1) => 0
#+END_SRC

[[#contents][èŒ¶]]

** concat
:PROPERTIES:
:CUSTOM_ID: concat
:END:

Concatentate two strings.

#+BEGIN_SRC
concat(a: string, b: string) string
#+END_SRC

Examples:

#+BEGIN_SRC
concat("tea", " time") => "tea time"
concat("a", "b") => "ab"
#+END_SRC

[[#contents][èŒ¶]]

** dict
:PROPERTIES:
:CUSTOM_ID: dict
:END:

Create a dictionary from a list of key, value pairs.  The keys
must be strings and the values can be any type.

#+BEGIN_SRC
dict(pairs: optional list) dict
#+END_SRC

Examples:

#+BEGIN_SRC
dict() => {}
dict(list("a", 5)) => {"a": 5}
dict(list("a", 5, "b", 33, "c", 0)) =>
  {"a": 5, "b": 33, "c": 0}
#+END_SRC

[[#contents][èŒ¶]]

** dup
:PROPERTIES:
:CUSTOM_ID: dup
:END:

Duplicate a string x times.  The result is a new string built by
concatenating the string to itself the specified number of times.

#+BEGIN_SRC
dup(pattern: string, count: int) string
#+END_SRC

Examples:

#+BEGIN_SRC
dup("=", 3) => "==="
dup("abc", 0) => ""
dup("abc", 1) => "abc"
dup("abc", 2) => "abcabc"
dup("", 3) => ""
#+END_SRC

[[#contents][èŒ¶]]

** exists
:PROPERTIES:
:CUSTOM_ID: exists
:END:

Determine whether a key exists in a dictionary. Return 1 when it exists, else 0.

#+BEGIN_SRC
exists(dictionary: dict, key: string) int
#+END_SRC

Examples:

#+BEGIN_SRC
d = dict("tea", "Earl")
exists(d, "tea") => 1
exists(d, "coffee") => 0
#+END_SRC

[[#contents][èŒ¶]]

** find
:PROPERTIES:
:CUSTOM_ID: find
:END:

Find the position of a substring in a string.  When the substring
is not found, return an optional default value.  A warning is
generated when the substring is missing and you don't specify a
default value.

#+BEGIN_SRC
find(str: string, substring: string, optional default: any) any
#+END_SRC

Examples:

#+BEGIN_SRC
       0123456789 1234567
msg = "Tea time at 3:30."
find(msg, "Tea") = 0
find(msg, "time") = 4
find(msg, "me") = 6
find(msg, "party", -1) = -1
find(msg, "party", len(msg)) = 17
find(msg, "party", 0) = 0
#+END_SRC

[[#contents][èŒ¶]]

** float
:PROPERTIES:
:CUSTOM_ID: float
:END:

Create a float from an int.

#+BEGIN_SRC
float(num: int) float
#+END_SRC

Examples:

#+BEGIN_SRC
float(2) => 2.0
float(-33) => -33.0
#+END_SRC

[[#contents][èŒ¶]]

** float
:PROPERTIES:
:CUSTOM_ID: float
:END:

Create a float from a number string.

#+BEGIN_SRC
float(numString: string) float
#+END_SRC

Examples:

#+BEGIN_SRC
float("2") => 2.0
float("2.4") => 2.4
float("33") => 33.0
#+END_SRC

[[#contents][èŒ¶]]

** get
:PROPERTIES:
:CUSTOM_ID: get
:END:

Get a dictionary value by its key.  If the key doesn't exist, the
default value is returned if specified, else a warning is
generated.

#+BEGIN_SRC
get(dictionary: dict, key: string, optional default: any) any
#+END_SRC

Note: For dictionary lookup you can use dot notation. It's the
same as get without the default.

Examples:

#+BEGIN_SRC
d = dict("tea", "Earl Grey")
get(d, "tea") => "Earl Grey"
get(d, "coffee", "Tea") => "Tea"
#+END_SRC

Using dot notation:
#+BEGIN_SRC
d = dict("tea", "Earl Grey")
d.tea => "Earl Grey"
#+END_SRC

[[#contents][èŒ¶]]

** get
:PROPERTIES:
:CUSTOM_ID: get
:END:

Get a list value by its index.  If the index is invalid, the
default value is returned when specified, else a warning is
generated.

#+BEGIN_SRC
get(list: list, index: int, optional default: any) any
#+END_SRC

Examples:

#+BEGIN_SRC
list = list(4, "a", 10)
get(list, 2) => 10
get(list, 3, 99) => 99
#+END_SRC

[[#contents][èŒ¶]]

** githubAnchor
:PROPERTIES:
:CUSTOM_ID: githubAnchor
:END:

Create Github anchor names from heading names. Use it for Github
markdown internal links. It handles duplicate heading names.

#+BEGIN_SRC
githubAnchor(names: list) list
#+END_SRC

Examples:

#+BEGIN_SRC
list = list("Tea", "Water", "Tea")
githubAnchor(list) =>
  ["tea", "water", "tea-1"]
#+END_SRC

[[#contents][èŒ¶]]

** githubAnchor
:PROPERTIES:
:CUSTOM_ID: githubAnchor
:END:

Create a Github anchor name from a heading name. Use it for
Github markdown internal links. If you have duplicate heading
names, the anchor name returned only works for the
first. Punctuation characters are removed so you can get
duplicates in some cases.

#+BEGIN_SRC
githubAnchor(name: string) string
#+END_SRC

Examples:

#+BEGIN_SRC
githubAnchor("MyHeading") => "myheading"
githubAnchor("Eary Gray") => "eary-gray"
githubAnchor("$Eary-Gray#") => "eary-gray"
#+END_SRC

Example in a markdown template:

#+BEGIN_SRC
$$ : anchor = githubAnchor(entry.name)
- {type]{{entry.name}](#{anchor}) &mdash; {short}
...
# {entry.name}
#+END_SRC

[[#contents][èŒ¶]]

** if0
:PROPERTIES:
:CUSTOM_ID: if0
:END:

If the condition is 0, return the second parameter, else return the third parameter. Return 0 for the else case when there is no third parameter.

The if functions, if0 and if1 are special in a couple of ways, see
[[#if-functions][If Functions]]

#+BEGIN_SRC
if0(condition: int, then: any, optional else: any) any
#+END_SRC

Examples:

#+BEGIN_SRC
drink0 = if0(0, "tea", "beer")
drink1 = if0(1, "tea", "beer")
drink4 = if0(4, "tea", "beer")
drink5 = if0(0, "tea")
drink6 = if0(8, "tea")
if0(c, return("skip"))
if0(c, warn("c is 0"))
#+END_SRC

result:

#+BEGIN_SRC
drink0 => tea
drink1 => beer
drink4 => beer
drink5 => tea
drink6 => 0
#+END_SRC

[[#contents][èŒ¶]]

** if1
:PROPERTIES:
:CUSTOM_ID: if1
:END:

If the condition is 1, return the second parameter, else return the third parameter. Return 0 for the else case when there is no third parameter.

The if functions, if0 and if1 are special in a couple of ways, see
[[#if-functions][If Functions]]

#+BEGIN_SRC
if1(condition: int, then: any, optional else: any) any
#+END_SRC

Examples:

#+BEGIN_SRC
drink0 = if1(0, "tea", "beer")
drink1 = if1(1, "tea", "beer")
drink4 = if1(4, "tea", "beer")
drink5 = if1(1, "tea")
drink6 = if1(8, "tea")
if1(c, return("skip"))
if1(c, warn("c is 1"))
#+END_SRC

result:

#+BEGIN_SRC
drink0 => beer
drink1 => tea
drink4 => beer
drink5 => tea
drink6 => 0
#+END_SRC

[[#contents][èŒ¶]]

** int
:PROPERTIES:
:CUSTOM_ID: int
:END:

Create an int from a float.

#+BEGIN_SRC
int(num: float, optional roundOption: string) int
#+END_SRC

Round options:

- "round" - nearest integer, the default.
- "floor" - integer below (to the left on number line)
- "ceiling" - integer above (to the right on number line)
- "truncate" - remove decimals

Examples:

#+BEGIN_SRC
int(2.34) => 2
int(2.34, "round") => 2
int(-2.34, "round") => -2
int(6.5, "round") => 7
int(-6.5, "round") => -7
int(4.57, "floor") => 4
int(-4.57, "floor") => -5
int(6.3, "ceiling") => 7
int(-6.3, "ceiling") => -6
int(6.3456, "truncate") => 6
int(-6.3456, "truncate") => -6
#+END_SRC

[[#contents][èŒ¶]]

** int
:PROPERTIES:
:CUSTOM_ID: int
:END:

Create an int from a number string.

#+BEGIN_SRC
int(numString: string, optional roundOption: string) int
#+END_SRC

Round options:

- "round" - nearest integer, the default
- "floor" - integer below (to the left on number line)
- "ceiling" - integer above (to the right on number line)
- "truncate" - remove decimals

Examples:

#+BEGIN_SRC
int("2") => 2
int("2.34") => 2
int("-2.34", "round") => -2
int("6.5", "round") => 7
int("-6.5", "round") => -7
int("4.57", "floor") => 4
int("-4.57", "floor") => -5
int("6.3", "ceiling") => 7
int("-6.3", "ceiling") => -6
int("6.3456", "truncate") => 6
int("-6.3456", "truncate") => -6
#+END_SRC

[[#contents][èŒ¶]]

** joinPath
:PROPERTIES:
:CUSTOM_ID: joinPath
:END:

Join the path components with a path separator.

You pass a list of components to join. For the second optional
parameter you specify the separator to use, either "/", "" or
"". If you specify "" or leave off the parameter, the current
platform separator is used.

If the separator already exists between components, a new one
is not added. If a component is "", the platform separator is
used for it.

#+BEGIN_SRC
joinPath(components: list, optional separator: string) string
#+END_SRC

Examples:

#+BEGIN_SRC
joinPath(list("images", "tea")) =>
  "images/tea"

joinPath(list("images", "tea"), "/") =>
  "images/tea"

joinPath(list("images", "tea"), "\") =>
  "images\tea"

joinPath(list("images/", "tea") =>
  "images/tea"

joinPath(list("", "tea")) =>
  "/tea"

joinPath(list("/", "tea")) =>
  "/tea"
#+END_SRC

[[#contents][èŒ¶]]

** join
:PROPERTIES:
:CUSTOM_ID: join
:END:

Join a list of strings with a separator.
An optional parameter determines whether you skip empty
strings or not.

#+BEGIN_SRC
join(strs: list, sep: string, optional skipEmpty: int) string
#+END_SRC

Examples:

#+BEGIN_SRC
join(list("a", "b"), ", ") => "a, b"
join(list("a"), ", ") => "a"
join(list(""), ", ") => ""
join(list("a", "b"), "") => "ab"
join(list("a", "", "c"), "|") => "a||c"
join(list("a", "", "c"), "|", 1) => "a|c"
#+END_SRC

[[#contents][èŒ¶]]

** keys
:PROPERTIES:
:CUSTOM_ID: keys
:END:

Create a list from the keys in a dictionary.

#+BEGIN_SRC
keys(dictionary: dict) list
#+END_SRC

Examples:

#+BEGIN_SRC
d = dict("a", 1, "b", 2, "c", 3)
keys(d) => ["a", "b", "c"]
values(d) => ["apple", 2, 3]
#+END_SRC

[[#contents][èŒ¶]]

** len
:PROPERTIES:
:CUSTOM_ID: len
:END:

Number of elements in a dictionary.

#+BEGIN_SRC
len(dictionary: dict) int
#+END_SRC

Examples:

#+BEGIN_SRC
len(dict()) => 0
len(dict("a", 4)) => 1
len(dict("a", 4, "b", 3)) => 2
#+END_SRC

[[#contents][èŒ¶]]

** len
:PROPERTIES:
:CUSTOM_ID: len
:END:

Number of elements in a list.

#+BEGIN_SRC
len(list: list) int
#+END_SRC

Examples:

#+BEGIN_SRC
len(list()) => 0
len(list(1)) => 1
len(list(4, 5)) => 2
#+END_SRC

[[#contents][èŒ¶]]

** len
:PROPERTIES:
:CUSTOM_ID: len
:END:

Number of unicode characters in a string.

#+BEGIN_SRC
len(str: string) int
#+END_SRC

Examples:

#+BEGIN_SRC
len("tea") => 3
len("aÃ±yÃ³ng") => 6
#+END_SRC

[[#contents][èŒ¶]]

** list
:PROPERTIES:
:CUSTOM_ID: list
:END:

Create a list of values. You can also use [ ... ] to create a
list.

#+BEGIN_SRC
list(...) list
#+END_SRC

Examples:

#+BEGIN_SRC
list() => []
list(1) => [1]
list(1, 2, 3) => [1, 2, 3]
list("a", 5, "b") => ["a", 5, "b"]
#+END_SRC

[[#contents][èŒ¶]]

** lower
:PROPERTIES:
:CUSTOM_ID: lower
:END:

Lowercase a string.

#+BEGIN_SRC
lower(str: string) string
#+END_SRC

Examples:

#+BEGIN_SRC
lower("Tea") => "tea"
lower("TEA") => "tea"
lower("TEÄ€") => "teÄ"
#+END_SRC

[[#contents][èŒ¶]]

** path
:PROPERTIES:
:CUSTOM_ID: path
:END:

Split a file path into its component pieces. Return a dictionary
with the filename, basename, extension and directory.

You pass a path string and the optional path separator, forward
slash or or backwards slash. When no separator, the current
system separator is used.

#+BEGIN_SRC
path(filename: string, optional separator: string) dict
#+END_SRC

Examples:

#+BEGIN_SRC
path("src/runFunction.nim") => {
  "filename": "runFunction.nim",
  "basename": "runFunction",
  "ext": ".nim",
  "dir": "src/",
}

path("src\runFunction.nim", "\") => {
  "filename": "runFunction.nim",
  "basename": "runFunction",
  "ext": ".nim",
  "dir": "src\",
}
#+END_SRC

[[#contents][èŒ¶]]

** replace
:PROPERTIES:
:CUSTOM_ID: replace
:END:

Replace a substring specified by its position and length with another string.  You can use the function to insert and append to
a string as well.

#+BEGIN_SRC
replace(str: string, start: int, length: int, replacement: string) string
#+END_SRC

- str: string
- start: substring start index
- length: substring length
- replacement: substring replacement

Examples:

Replace:
#+BEGIN_SRC
replace("Earl Grey", 5, 4, "of Sandwich")
  => "Earl of Sandwich"
replace("123", 0, 1, "abcd") => abcd23
replace("123", 0, 2, "abcd") => abcd3

replace("123", 1, 1, "abcd") => 1abcd3
replace("123", 1, 2, "abcd") => 1abcd

replace("123", 2, 1, "abcd") => 12abcd
#+END_SRC
Insert:
#+BEGIN_SRC
replace("123", 0, 0, "abcd") => abcd123
replace("123", 1, 0, "abcd") => 1abcd23
replace("123", 2, 0, "abcd") => 12abcd3
replace("123", 3, 0, "abcd") => 123abcd
#+END_SRC
Append:
#+BEGIN_SRC
replace("123", 3, 0, "abcd") => 123abcd
#+END_SRC
Delete:
#+BEGIN_SRC
replace("123", 0, 1, "") => 23
replace("123", 0, 2, "") => 3
replace("123", 0, 3, "") => ""

replace("123", 1, 1, "") => 13
replace("123", 1, 2, "") => 1

replace("123", 2, 1, "") => 12
#+END_SRC
Edge Cases:
#+BEGIN_SRC
replace("", 0, 0, "") =>
replace("", 0, 0, "a") => a
replace("", 0, 0, "ab") => ab
replace("", 0, 0, "abc") => abc
replace("", 0, 0, "abcd") => abcd
#+END_SRC

[[#contents][èŒ¶]]

** replaceRe
:PROPERTIES:
:CUSTOM_ID: replaceRe
:END:

Replace multiple parts of a string using regular expressions.

You specify one or more pairs of regex patterns and their string
replacements.

#+BEGIN_SRC
replaceRe(str: string, pairs: list) string
#+END_SRC

Examples:

#+BEGIN_SRC
list = list("abc", "456", "def", "")
replaceRe("abcdefabc", list))
  => "456456"
#+END_SRC

For developing and debugging regular expressions see the
website: https://regex101.com/

[[#contents][èŒ¶]]

** return
:PROPERTIES:
:CUSTOM_ID: return
:END:

Return the given value and control command looping. A return in a
statement causes the command to stop processing the current
statement and following statements in the command. You can
control whether the replacement block is output or not.

- "stop" -- stop processing the command
- "skip" -- skip this replacement block and continue with the next
- "" -- output the replacement block and continue

#+BEGIN_SRC
return(value: string) string
#+END_SRC

Examples:

#+BEGIN_SRC
if1(c, return("stop"))
if1(c, return("skip"))
if1(c, return(""))
#+END_SRC

[[#contents][èŒ¶]]

** slice
:PROPERTIES:
:CUSTOM_ID: slice
:END:

Extract a substring from a string by its position and length. You
pass the string, the substring's start index and its length.  The
length is optional. When not specified, the slice returns the
characters from the start to the end of the string.

The start index is by unicode characters not bytes.

#+BEGIN_SRC
slice(str: string, start: int, optional length: int) string
#+END_SRC

Examples:

#+BEGIN_SRC
slice("Earl Grey", 1, 3) => "arl"
slice("Earl Grey", 6) => "rey"
slice("aÃ±yÃ³ng", 0, 3) => "aÃ±y"
#+END_SRC

[[#contents][èŒ¶]]

** sort
:PROPERTIES:
:CUSTOM_ID: sort
:END:

Sort a list of values of the same type.  The values are ints,
floats or strings.

You specify the sort order, "ascending" or "descending".

You have the option of sorting strings case "insensitive". Case
"sensitive" is the default.

#+BEGIN_SRC
sort(values: list, order: string, optional insensitive: string) list
#+END_SRC

Examples:

#+BEGIN_SRC
ints = list(4, 3, 5, 5, 2, 4)
sort(list, "ascending") => [2, 3, 4, 4, 5, 5]
sort(list, "descending") => [5, 5, 4, 4, 3, 2]

floats = list(4.4, 3.1, 5.9)
sort(floats, "ascending") => [3.1, 4.4, 5.9]
sort(floats, "descending") => [5.9, 4.4, 3.1]

strs = list("T", "e", "a")
sort(strs, "ascending") => ["T", "a", "e"]
sort(strs, "ascending", "sensitive") => ["T", "a", "e"]
sort(strs, "ascending", "insensitive") => ["a", "e", "T"]
#+END_SRC

[[#contents][èŒ¶]]

** sort
:PROPERTIES:
:CUSTOM_ID: sort
:END:

Sort a list of lists.

You specify the sort order, "ascending" or "descending".

You specify how to sort strings either case "sensitive" or
"insensitive".

You specify which index to compare by.  The compare index value
must exist in each list, be the same type and be an int, float or
string.

#+BEGIN_SRC
sort(lists: list, order: string, case: string, index: int) list
#+END_SRC

Examples:

#+BEGIN_SRC
l1 = list(4, 3, 1)
l2 = list(2, 3, 4)
listOfLists = list(l1, l2)
sort(listOfLists, "ascending", "sensitive", 0) => [l2, l1]
sort(listOfLists, "ascending", "sensitive", 2) => [l1, l2]
#+END_SRC

[[#contents][èŒ¶]]

** sort
:PROPERTIES:
:CUSTOM_ID: sort
:END:

Sort a list of dictionaries.

You specify the sort order, "ascending" or "descending".

You specify how to sort strings either case "sensitive" or
"insensitive".

You specify the compare key.  The key value must exist
in each dictionary, be the same type and be an int, float or
string.

#+BEGIN_SRC
sort(dicts: list, order: string, case: string, key: string) list
#+END_SRC

Examples:

#+BEGIN_SRC
d1 = dict("name", "Earl Gray", "weight", 1.2)
d2 = dict("name", "Tea Pot", "weight", 3.5)
dicts = list(d1, d2)
sort(dicts, "ascending", "sensitive", "weight") => [d1, d2]
sort(dicts, "descending", "sensitive", "name") => [d2, d1]
#+END_SRC

[[#contents][èŒ¶]]

** type
:PROPERTIES:
:CUSTOM_ID: type
:END:

Return the parameter type, one of: int, float, string, list, dict.

#+BEGIN_SRC
type(variable: any) string
#+END_SRC

Examples:

#+BEGIN_SRC
type(2) => "int"
type(3.14159) => "float"
type("Tea") => "string"
type(list(1,2)) => "list"
type(dict("a", 1)) => "dict"
#+END_SRC

[[#contents][èŒ¶]]

** values
:PROPERTIES:
:CUSTOM_ID: values
:END:

Create a list out of the values in the specified dictionary.

#+BEGIN_SRC
values(dictionary: dict) list
#+END_SRC

Examples:

#+BEGIN_SRC
d = dict("a", "apple", "b", 2, "c", 3)
keys(d) => ["a", "b", "c"]
values(d) => ["apple", 2, 3]
#+END_SRC

[[#contents][èŒ¶]]

** warn
:PROPERTIES:
:CUSTOM_ID: warn
:END:

Return a warning message and skip the current statement.

#+BEGIN_SRC
warn(message: string) string
#+END_SRC

Examples:

#+BEGIN_SRC
b = warn("message")
b = if1(a, warn("a is one"), "")
#+END_SRC


# Dynamic Content Ends
* Contents :notoc:
:PROPERTIES:
:CUSTOM_ID: contents
:END:

# You run the command below to make the table of contents. Copy
# to scratch to remove the leading pound signs.
# grep '^\* ' readme.org | grep -v ":notoc" | cut -c 3- | \
# awk '{a = $0; gsub(" ", "-", a); printf "- [[#%s][%s]]\n", tolower(a), $0 }'

- [[#advantages][Advantages]]
- [[#how-it-works][How it Works]]
- [[#commands][Commands]]
- [[#replacement-block][Replacement Block]]
- [[#statements][Statements]]
- [[#syntax][Syntax]]
- [[#variables][Variables]]
- [[#dot-names][Dot Names]]
- [[#types][Types]]
- [[#run-statictea][Run StaticTea]]
- [[#miscellaneous][Miscellaneous]]
- [[#functions][Functions]]

* Tea Info                                                            :notoc:

Tea plant: Camellia sinensis

Tea is the most popular manufactured drink consumed in the world,
equaling all others â€“ including coffee, soft drinks, and alcohol
â€“ combined. -- Wikipedia -- Macfarlane, Alan; Macfarlane, Iris
(2004). The Empire of Tea. The Overlook Press. p. 32. ISBN
978-1-58567-493-0.
* templates/readmeFuncSection.org
