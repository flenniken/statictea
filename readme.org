#+TITLE: StaticTea
A template processor and language.

StaticTea combines a template with json data to produce a result.

Example hello world template:

#+BEGIN_SRC
<!--$ nextline -->
hello {s.name}
#+END_SRC

The associated json data:

#+BEGIN_SRC
{"name": "world"}
#+END_SRC

The result:

#+BEGIN_SRC
hello world
#+END_SRC

[[#contents][茶]] (contents at the bottom)

* Advantages
:PROPERTIES:
:CUSTOM_ID: advantages
:END:

You can view, edit and validate your templates with its normal
tools.  You develop templates as if they were static pages.

The template designer has full control over the presentation.
You can change the look without changing the server.

You can share common template fragments between templates.

In a general sense StaticTea is a program and language for
formatting json.

[[#contents][茶]]

* How it Works
  :PROPERTIES:
:CUSTOM_ID: how-it-works
:END:

You pass unformatted variable content from the server as json.
You format the content with template commands to create new
variables that substitute text in the template.

You define replacement blocks by surrounding them with commands
and you target replacement variables inside the block by wrapping
them with brackets.

You encode the commands as comments to match the particular
template type.

[[#contents][茶]]

* Commands
:PROPERTIES:
:CUSTOM_ID: commands
:END:

StaticTea commands:

- [[#nextline-command][nextline]] -- make substitutions in the next line
- [[#block-command][block]] —- make substitutions in the next block of lines
- [[#replace-command][replace]] -— replace the block with a variable
- [[#endblock-command][endblock]] -- end the replacement block for block and replace
  commands.
- # —- [[#comment-command][comment command]]
- : -- [[#continue-command][continue command]], used to continue a command line

[[#contents][茶]]

** Nextline Command
:PROPERTIES:
:CUSTOM_ID: nextline-command
:END:

The nextline command targets the line following it for
replacement. The targeted line is called the replacement block.

The following example's replacement block contains two variables,
drink and drinkType.

template:

#+BEGIN_SRC
<!--$ nextline -->
Drink {s.drink} -- {s.drinkType} is my favorite.
#+END_SRC

server json:

#+BEGIN_SRC
{
  "drink": "tea",
  "drinkType": "Earl Grey"
}
#+END_SRC

result:

#+BEGIN_SRC
Drink tea -- Earl Grey is my favorite.
#+END_SRC

[[#contents][茶]]

** Block Command
:PROPERTIES:
:CUSTOM_ID: block-command
:END:

The block command targets multiple lines for replacement. The
replacement block starts after the command and continues until
the endblock line is found. It behaves like the nextline command
except with multiple lines.

In the following example the block has three lines. The block
contains three replacement variables, weekday, name and time.

template:

#+BEGIN_SRC
<!--$ block -->
Join our tea party on
{s.weekday} at {s.name}'s
house at {s.time}.
<!--$ endblock -->
#+END_SRC

server json:

#+BEGIN_SRC
{
  "weekday": "Friday",
  "name": "John",
  "time": "5:00 pm"
}
#+END_SRC

result:

#+BEGIN_SRC
Join our tea party on
Friday at John's
house at 5:00 pm.
#+END_SRC

[[#contents][茶]]

** Replace Command
:PROPERTIES:
:CUSTOM_ID: replace-command
:END:

The replace command's replacement block gets replaced with the
t.content variable.

The lines in the block mirror the variable so you can
test the template as if it was a static file.

The command is useful for sharing common template lines between
templates and it has the special property that you can keep the
replacement block in sync with the variable, see [[#update-option][Update Option]]
for more information.

If you don't assign the t.content variable, a warning is
generated, and the command behaves like a block command.  This is
good for testing changes you want to make to the shared value.

The following example uses a common header from the shared json.

template:

#+BEGIN_SRC
<!--$ replace t.content=h.header -->
<!--$ endblock -->
#+END_SRC

shared json:

#+BEGIN_SRC
{
  "header": "<!doctype html>\n<html lang=\"en\">\n"
}
#+END_SRC

result:

#+BEGIN_SRC
<!doctype html>
<html lang="en">
#+END_SRC

The above example generates the correct result but it doesn’t
work as a static template because the template is missing the
header lines.

You can fix this by adding the header lines inside the replace
command's replacement block. The lines do not appear in the
result, just the data from the json header variable.

template:

#+BEGIN_SRC
<!--$ replace t.content=h.header -->
<!doctype html>
<html lang="en">
<!--$ endblock -—>
#+END_SRC

The shared variable may contain replacement content too.  Here is
an example of that:

template:

#+BEGIN_SRC
<!--$ replace t.content=h.header -->
<!DOCTYPE html>
<html lang="{s.languageCode}" dir="{s.languageDirection}">
<head>
<meta charset="UTF-8"/>
<title>{s.title}</title>
<--$ endblock -->
#+END_SRC

server json:

#+BEGIN_SRC
{
"languageCode": "en",
"languageDirection": "ltr",
"title": "Teas in England"
}
#+END_SRC

shared json:

#+BEGIN_SRC
{
  "header": "<!DOCTYPE html>
<html lang=\"{s.languageCode}\" dir=\"{s.languageDirection}\">
<head>
<meta charset=\"UTF-8\"/>
<title>{s.title}</title>\n"
}
#+END_SRC

result:

#+BEGIN_SRC
<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8"/>
<title>Teas in England</title>
#+END_SRC

[[#contents][茶]]

** Comment Command
:PROPERTIES:
:CUSTOM_ID: comment-command
:END:

You can comment templates with the comment command.  Comments
are line based and use the # character. They do not appear in the
result.

template:

#+BEGIN_SRC
<!--$ # The main tea groups. -->
There are five main groups of teas:
white, green, oolong, black, and pu'erh.
You make Oolong Tea in five time
intensive steps.
#+END_SRC

result:

#+BEGIN_SRC
There are five main groups of teas:
white, green, oolong, black, and pu'erh.
You make Oolong Tea in five time
intensive steps.
#+END_SRC

[[#contents][茶]]

** Continue Command
:PROPERTIES:
:CUSTOM_ID: continue-command
:END:

The continue command allows you to continue adding statements to
a nextline, block and replace command.

In the following example the nextline command continues on a
second line and third line.

template:

#+BEGIN_SRC
$$ nextline
$$ : tea = 'Earl Grey'
$$ : tea2 = 'Masala chai'
{tea}, {tea2}
#+END_SRC

result:

#+BEGIN_SRC
Earl Grey, Masala chai
#+END_SRC

[[#contents][茶]]

** Endblock Command
:PROPERTIES:
:CUSTOM_ID: endblock-command
:END:

The endblock command ends the replacement block for the block and
replace commands. Only the endblock command ends them. All text
until the endblock is part of the replacement block. This
includes lines that look like commands. For example:

template:

#+BEGIN_SRC
<!--$ block -->
<!--$ # this is not a comment, just text -->
fake nextline
<!--$ nextline -->
<!--$ endblock -->
#+END_SRC

result:

#+BEGIN_SRC
<!--$ # this is not a comment, just text -->
fake nextline
<!--$ nextline -->
#+END_SRC

[[#contents][茶]]

* Replacement Block
:PROPERTIES:
:CUSTOM_ID: replacement-block
:END:

A replacement block is a group of contiguous lines in a template
between a command and its endblock or in the nextline case the
block is one line.

The block contains the any number of bracketed variables for
substitution.

You can repeat the block to make lists and other repeating
content. You control how many times the block repeats with the
t.repeat variable.  The t.row counts the number of times the
block has repeated and you use its value to customize each
repeated block.

[[#contents][茶]]

* Statements
:PROPERTIES:
:CUSTOM_ID: statements
:END:

You format server content in variables you create in statements.

A statement is an expression consisting of a variable, an equal
sign, and a right hand side. The right hand side is either
another variable, a string, a number or a function.

All operations are done with functions except the equal
operator. Looping is done at the replacement block level with
t.repeat and t.row. Output control is done with t.output.

Statements are allowed on the nextline, block and replace
commands. You can use multiple statements on the same line
separated with semicolons. If you need more space for a
statement, you can continue the line with the "+" character at
the end. Statements are executed from left to right, top to
bottom.

Here are some simple statements:

#+BEGIN_SRC
tea = "Earl Grey"
num = 5
t.repeat = 8
nameLen = len(s.name)
name = concat(substr(s.name, 0, 7), "...")
#+END_SRC

[[#contents][茶]]

* Syntax
:PROPERTIES:
:CUSTOM_ID: syntax
:END:

A template consists of command lines and non-command lines.  The
command lines are line oriented and they have the same form and
they are limited to 1024 bytes. There are no restrictions on the
non-command lines in a template.

Each command line is a comment to match the template type. The
beginning comment characters are called the prefix and the
optional ending comment characters are called the postfix. For
example, in an html template the prefix is "<!--$" and the
postfix is "-->". See [[#prefix-postfix][Prefix Postfix]] for more information.

The prefix starts at column 1. Next comes the command
name. Statements follow the command name, they are separated by
semicolons or newlines and they may flow through the following
lines. At the end of the line is an optional plus continuation
character then the optional postfix then the end of line, either
\r\n or \n.

The following chart shows a nextline command made up of two
lines. It has three statements: a=5, b="banana" and c=5.

#+BEGIN_SRC
prefix
|     command
|     |        statements
|     |        |         continuation
|     |        |         |
|     |        |         |postfix
|     |        |         ||  newline
|     |        |         ||  |
<!--$ nextline a=5;  b="b+-->
<!--$ : anana"; c=5       -->
#+END_SRC

A space or tab is required between a command and a statement,
otherwise you can use zero or more tabs and spaces where they are
allowed. Space isn't allowed before the prefix, after the
continuation or after the postfix or between the function name
and its opening parentheses. Here are a few single line examples:

#+BEGIN_SRC
$$nextline
$$ nextline
$$ nextline a=5
$$ nextline a = 5
$$ nextline num = len(tea_list); b=3
$$ nextline num = len( tea_list ) ;b=3
#+END_SRC

The statements may flow between lines by using the continuation
plus character. The following two nextline commands are
equivalent:

#+BEGIN_SRC
<!--$ nextline com = "Bigelow Tea Company" -->

<!--$ nextline com = "Big+-->
<!--$ : elow Tea Company" -->
#+END_SRC

You separate statements with semicolons or newlines. You can have
blank statements that do nothing. Both commands below have three
statements: a = 1, b = 2 and c = 3.

#+BEGIN_SRC
<!--$ nextline a=1; b=2; c=3 -->

$$ nextline a = 1
$$ : b = 2
$$ : c = 3
#+END_SRC

[[#contents][茶]]

* Variables
:PROPERTIES:
:CUSTOM_ID: variables
:END:

You use variables to create formatted content for a block and to
control how a command works. You create them in json files or in
template statements.

All variables are immutable.  You can assign a new value to a
dictionary but you cannot change an existing value. If you try to
change a variable, a warning is generated and the statement is
skipped.

Local variables and tea variables (except row) are cleared after
processing each replacement block.

One dictionary exists for each of the five types of
variables. You access them with different prefixes.

- s -- [[#json-variables][Server Json Variables]]
- h -- [[#json-variables][Shared Json Variables]]
- l -- [[#local-variables][Local Variables]]
- g -- [[#global-variables][Global Variables]]
- t -- [[#tea-variables][Tea Variables]]

[[#contents][茶]]

** Json Variables
:PROPERTIES:
:CUSTOM_ID: json-variables
:END:

You pass variables to the template in json files.

The variables are defined by the top level dictionary items. Each
item's key is the name of a variable and the item's value is
the variables' value.

There are two types of json files, the server json and the shared
json. The server file populates the s dictionary and the
shared file populates the h dictionary.

You can use multiple server and shared json files by specifying
multiple files on the command line. The files are processed
left to right which is important when there are duplicate
variables since the last one processed overwrites the previous
one.

The json null values get converted to the 0. Json True and False
get converted to 1 and 0.

To give full control of the presentation to the template
designers, the server json shouldn't contain any presentation
data.

The shared json is created and maintained by the template
designer for sharing common template fragments and other
presentation needs.

[[#contents][茶]]

** Local Variables
   :PROPERTIES:
   :CUSTOM_ID: local-variables
   :END:

You create local variables with template statements.  They are
local to the command where they are defined. You do not have to
specify a prefix for local variables but you can use l. They are
stored in the l dictionary. The local variables are cleared and
recalculated for each repeated block.

[[#contents][茶]]

** Global Variables
    :PROPERTIES:
    :CUSTOM_ID: global-variables
    :END:

Like local variables, you create global variables with template
statements.  All commands have access to them and they are stored
in the g dictionary.

[[#contents][茶]]

** Tea Variables
:PROPERTIES:
    :CUSTOM_ID: tea-variables
    :END:

The tea variables control how the replacement block works.
They are are stored in the t dictionary.

Tea variables:

- [[#tcontent][t.content]] -- content of the replace block
- [[#tmaxrepeat][t.maxRepeat]] -- maximum number of times to repeat the block
- [[#tmaxlines][t.maxLines]] -- maximum number of replacement block lines (lines before endblock)
- [[#toutput][t.output]] -- where the block output goes
- [[#trepeat][t.repeat]] -- controls how many times the block repeats
- [[#trow][t.row]] -- the current index number of a repeating block
- [[#tversion][t.version]] -- the StaticTea version number

[[#contents][茶]]

*** t.content
    :PROPERTIES:
    :CUSTOM_ID: tcontent
    :END:

The t.content variable determines the content used for the
whole replace block.

#+BEGIN_SRC
t.content = h.header
#+END_SRC

You use [[#update-option][Update Option]] to keep the template's blocks in sync with
their variables.

When t.content is not set, the command behaves like a block
command except a warning message is output. This is good for
testing changes you want to make to the shared value and the
warning reminds you to set the variable when you're done testing.

The variable only applies to the replace command. See the
[[#replace-command][replace command]] section for an example.

[[#contents][茶]]

*** t.maxRepeat
  :PROPERTIES:
  :CUSTOM_ID: tmaxrepeat
  :END:

The t.maxRepeat variable determines the maximum times a block can
repeat.  The default is 100. You can increase it to repeat more
times. You cannot assign a number to t.repeat bigger than
maxRepeat.

It prevents the case where you mistakenly assign a giant number,
and it allows you to design your template to work well for the
expected range of blocks.

[[#contents][茶]]

*** t.maxLines
    :PROPERTIES:
    :CUSTOM_ID: tmaxlines
    :END:

The t.maxLines variable determines the maximum lines in a
replacement block.

StaticTea reads lines looking for the endblock.  By default, if
it is not found in 50 lines, the 50 lines are used for the block
and a warning is output. This catches the case where you forget
the endblock command. You can increase or decrease the value.

#+BEGIN_SRC
<!--$ block t.maxLines=200 -->
#+END_SRC

[[#contents][茶]]

*** t.output
:PROPERTIES:
    :CUSTOM_ID: toutput
    :END:

The t.output variable determines where the block output goes.  By
default it goes to the result file.

- "result" -- the block output goes to the result file (default)
- "stderr" -- the block output goes to standard error
- "log" -- the block output goes to the log file
- "skip" -- the block is skipped

You can use the stderr option to write your own warning messages.

template:

#+BEGIN_SRC
$$ nextline
$$ : t.output = if( +
$$ :   exists("s.admin"), "skip",
$$ :   "stderr")
$$ : msg = concat( +
$$ :   template(), "(", +
$$ :   getLineNumber(), ")", +
$$ :   "missing admin var")
{msg}
#+END_SRC

result:

#+BEGIN_SRC
template.html(45): missing admin var
#+END_SRC

[[#contents][茶]]

*** t.repeat
    :PROPERTIES:
    :CUSTOM_ID: trepeat
    :END:

The t.repeat variable is a number that tells how many times to
repeat the block. A value of zero means don't show the block at
all. The t.repeat variable defaults to 1 so by default the block
is output once.

Each time the block repeats the local variables get cleared then
recalculated.

The t.row variable counts the number of times the block repeats
and is used with t.repeat to customize each block.

You cannot assign a number bigger than t.maxRepeat to
t.repeat. You can set t.maxRepeat to anything you want, the
default is 100.

For the following example, the number of items in tea_list is
assigned to the t.repeat variable which outputs the block five
times.

template:

#+BEGIN_SRC
<!--$ nextline t.repeat = len(s.tea_list) -->
<!--$ : tea = get(s.tea_list, t.row) -->
 * {tea}
#+END_SRC

server json:

#+BEGIN_SRC
{
"tea_list": [
  "Black",
  "Green",
  "Oolong",
  "Sencha",
  "Herbal"
]
}
#+END_SRC

result:

#+BEGIN_SRC
 * Black
 * Green
 * Oolong
 * Sencha
 * Herbal
#+END_SRC

The following example builds an html select list of tea companies
with the Twinings company selected and it shows how to access
values from dictionaries.

template:

#+BEGIN_SRC
<h3>Tea Companies</h3>
<select>
<!--$ nextline t.repeat=len(s.companyList) -->
<!--$ : d = get(s.companyList, t.row) -->
<!--$ : selected = get(d.company, "selected", 0) -->
<!--$ : current=if(selected, ' selected="selected"', "") -->
<option{current}>{d.company}</option>
</select>
#+END_SRC

server json:

#+BEGIN_SRC
{
"companyList": [
  {"company": "Lipton"},
  {"company": "Tetley"},
  {"company": "Twinings", "selected": 1},
  {"company": "American Tea Room"},
  {"company": "Argo Tea"},
  {"company": "Bigelow Tea Company"}
]
}
#+END_SRC

result:

#+BEGIN_SRC
<h3>Tea Companies</h3>
<select>
<option>Lipton</option>
<option>Tetley</option>
<option>selected="selected">Twinings</option>
<option>Argo Tea</option>
<option>American Tea Room</option>
<option>Bigelow Tea Company</option>
</select>
#+END_SRC

Setting t.repeat to 0 is good for building test lists.

When you view the following template fragment in a browser it
shows one item in the list.

template:

#+BEGIN_SRC
<h3>Tea</h3>
<ul>
<!--$ nextline t.repeat = len(s.teaList)-->
<!--$ : tea = get(s.teaList, t.row) -->
<li>{tea}</li>
</ul>
#+END_SRC

To create a static page that has more products for better testing
you could use the repeat variable like this:

template:

#+BEGIN_SRC
<h3>Tea</h3>
<ul>
<!--$ nextline t.repeat = len(s.teaList) -->
<!--$ : tea = get(s.teaList, t.row) -->
<li>{tea}</li>
<!--$ block t.repeat = 0 -->
<li>Black</li>
<li>Green</li>
<li>Oolong</li>
<li>Sencha</li>
<li>Herbal</li>
<!--$ endblock -->
</ul>
#+END_SRC

server json:

#+BEGIN_SRC
{
"teaList": [
  "Chamomile",
  "Chrysanthemum",
  "White",
  "Puer"
]
}
#+END_SRC

result:

#+BEGIN_SRC
<h3>Tea</h3>
<ul>
<li>Chamomile</li>
<li>Chrysanthemum</li>
<li>White</li>
<li>Puer</li>
</ul>
#+END_SRC

[[#contents][茶]]

*** t.row
    :PROPERTIES:
    :CUSTOM_ID: trow
    :END:

The t.row variable contains the current row number for blocks
that repeat. The row numbers start at 0 and increase.  You use it
to format lists and other repeating content in the template.

Here is an example using the row variable.  In the example the
row number is used in three places.

template:

#+BEGIN_SRC
<!--$ nextline t.repeat=len(s.companies)-->
<!--$ : company = get(s.companies, t.row) -->
<!--$ : num = add(t.row, 1) -->
<li id="r{t.row}>{num}. {company}</li>
#+END_SRC

server json:

#+BEGIN_SRC
{
  "companies": [
    "Mighty Leaf Tea",
    "Numi Organic Tea",
    "Peet's Coffee & Tea",
    "Red Diamond"
  ]
}
#+END_SRC

result:

#+BEGIN_SRC
  <li id="r0">1. Mighty Leaf Tea</li>
  <li id="r1">2. Numi Organic Tea</li>
  <li id="r2">3. Peet's Coffee & Tea</li>
  <li id="r3">4. Red Diamond</li>
#+END_SRC

[[#contents][茶]]

*** t.version
:PROPERTIES:
:CUSTOM_ID: tversion
:END:

The t.version variable contains the current version number of
StaticTea. See the [[#cmpversion][cmpVersion]] function for more information.

[[#contents][茶]]

* Types
:PROPERTIES:
:CUSTOM_ID: types
:END:

StaticTea variable types:

- [[#string][string]]
- [[#integer][int]]
- [[#float][float]]
- [[#dict][dict]]
- [[#list][list]]

[[#contents][茶]]

** String
:PROPERTIES:
:CUSTOM_ID: string
:END:

A string is an immutable sequence of characters. You define a
string with single or double quotes and use them in
statements. You encode strings as unicode utf-8.  Invalid utf-8
sequences generate a warning and the statement is skipped.

example strings:

- "this is a string"
- 'using single quotes'
- "You can store black teas longer than green teas."
- "100"

example usage:

#+BEGIN_SRC
<!--$ nextline tea = "Earl Grey" -->
<h2>{tea}</h2>
#+END_SRC

result:

#+BEGIN_SRC
<h2>Earl Grey</h2>
#+END_SRC

[[#contents][茶]]

** Int
:PROPERTIES:
:CUSTOM_ID: integer
:END:

An int is a 64 bit signed integer.  Plus signs are not used
with numbers.

Example numbers:

#+BEGIN_SRC
12345
0
-8823
42
#+END_SRC

[[#contents][茶]]

** Float
:PROPERTIES:
:CUSTOM_ID: float
:END:

A float is a 64 bit real number, it has a decimal point and
starts with a digit or minus sign.

Example floats:

#+BEGIN_SRC
3.14159
24.95
0.123
-34.0
#+END_SRC

[[#contents][茶]]

** Dict
:PROPERTIES:
:CUSTOM_ID: dict-type
:END:

The dict type, short for dictionary, is a key value store with
fast lookup. It maps a string key to a value which can be any
type.

You access dictionary items with variable names or with the get
function.  You create them in the json files or with the dict
function.

In Json files dictionaries are known as json objects. Json calls
the object items name/value pairs and we call them key/value
pairs. StaticTea preserves the order of the elements and the last
duplicate wins.

In the following json data, the overall data is a dictionary and
the d element is a dictionary.  The d dictionary has two key/value
pairs, ("x", 100) and ("y", 200).

server json:

#+BEGIN_SRC
{
  "a": 1,
  "b": 2,
  "d": {
    "x": 100,
    "y": 200
  }
}
#+END_SRC

If a key has valid variable syntax, you can access it as a
variable using dot notation. For the json example above, you can
access the data as:

#+BEGIN_SRC
s.a => 1
s.b => 2
s.d => dict("x", 100, "y", 200)
s.d.x => 100
s.d.y => 200
#+END_SRC

Or you access the elements with the get function. The get
function has an optional default parameter and it works with keys
that don't look like variables.  Examples:

#+BEGIN_SRC
get(s, "a") => 1
get(s, "b") => 2
get(s, "d") => dict("x", 100, "y", 200)

d = get(s, "d")
get(d, "x") => 100
get(d, "y") => 200

get(s, "c", 3) => 3
#+END_SRC

[[#contents][茶]]

** List
:PROPERTIES:
:CUSTOM_ID: list
:END:

A list contains a sequence of values of any type.  You create
lists in json files or in templates with the list function. You
lookup list elements by their index using the get function.

#+BEGIN_SRC
list() => []
list(1) => [1]
list(1, 2, 3) => [1, 2, 3]
list("a", 5, "b") => ["a", 5, "b"]

list = list(1, 3.3, "a")
get(list, 0) => 1
get(list, 1) => 3.3
git(list, 2) => "a"
git(list, 3, 99) => 99
#+END_SRC

[[#contents][茶]]

* Run StaticTea
:PROPERTIES:
:CUSTOM_ID: run-statictea
:END:

You run StaticTea from the command line. You specify the template
file to process along with the json data files and a result file
is generated.

- Warning messages go to standard error.
- If you don't specify the result file, the result goes to standard out.
- If you specify "stdin" for the template, the template comes
  from stdin.
- StaticTea returns success, return code 0, when there are no
  warning messages, else it returns 1.

The example below shows a typical invocation which specifies four
file arguments, the server json, the shared json, the template
and the result.

#+BEGIN_SRC
statictea \
  --server server.json \
  --shared shared.json \
  --template template.html \
  --result result.html
#+END_SRC

The StaticTea command line options:

- help -- show options and usage documentation.
- version -- outputs the version number.
- server -- the server json file(s), you can specify multiple.
- shared -- the shared json file(s), you can specify multiple.
- template -- the template file, or "stdin" for input from
  standard input.
- result -- the result file, or standard out when not specified.
- update -- update the template replace blocks. See the
  [[#replace-command][Replace Command]].
- prepost -- add a command prefix and postfix, you can specify
  multiple. When you specify values, the defaults are no longer
  used. See the [[#prefix-postfix][Prefix Postfix]] section.
- log - log to a file, see [[#log-file][Log File]] section.

[[#contents][茶]]

* Miscellaneous
:PROPERTIES:
:CUSTOM_ID: miscellaneous
:END:

Miscellaneous topics:

- [[#warning-messages][Warning Messages]]
- [[#prefix-postfix][Prefix Postfix]]
- [[#encoding-and-line-endings][Encoding and Line Endings]]
- [[#update-option][Update Option]]
- [[#log-file][Log File]]
- [[#module-docs][Module Docs]]
- [[#html-formatted-json][HTML Formatted Json]]
- [[#nimble-tasks][Nimble Tasks]]

** Warning Messages
:PROPERTIES:
   :CUSTOM_ID: warning-messages
   :END:

When StaticTea detects a problem, a warning message is written to
standard error, the problem is skipped, and processing
continues.

For example, if a variable in a replacement block is used but it
doesn't exist, the bracketed variable remains as is in the
result, and a message is output to standard error. There are many
other potential warnings.

It’s good style to change your template or json to be free of
messages.

Each warning message shows the file and line number where the
problem happened.

example messages:

- tea.html(0): w15: "Unable to parse the json file. Skipping file: test.json.
- tea.html(45): w61: No space after the command.
- tea.html(121): w52: The get function takes 2 or 3 parameters.
- tea.html(243): w36: The variable 'teaMaster' does not exist.
- tea.html(3044): w47: Concat parameter 45 is not a string."

Statement errors generate multi-line messages, for example:

#+BEGIN_SRC
template.html(16): w33: Expected a string, number, variable or function.
statement: tea = len("abc",)
                           ^
#+END_SRC

Statictea returns success, return code 0, when there are no
warning messages, else it returns 1.

Example of running statictea when a variable is missing:

template:

#+BEGIN_SRC
<!--$ block -->
You're a {s.webmaster},
I'm a {s.teaMaster}!
<!--$ endblock -->
#+END_SRC

server json:

#+BEGIN_SRC
{
 "webmaster": "html wizard"
}
#+END_SRC

stderr:

#+BEGIN_SRC
template.html(3): w58: The replacement variable doesn't exist: s.teaMaster.
#+END_SRC

result:

#+BEGIN_SRC
You're a html wizard,
I'm a {s.teaMaster}!
#+END_SRC

You can write your own warning messages using the system t.output
set to stderr. In the following example a warning message is
written to standard error when the server admin variable is
missing. When it is not missing nothing gets output.

template:

#+BEGIN_SRC
<--$ nextline t.output = if( +-->
<--$ : exists("admin"), "skip", "stderr") -->
warning: the admin variable is missing
#+END_SRC

[[#contents][茶]]

** Prefix Postfix
:PROPERTIES:
   :CUSTOM_ID: prefix-postfix
   :END:

You make the template commands look like comments tailored for
your template file type. This allows you to edit the template
using its native editor and run other native tools.  For example,
you can edit a StaticTea html template with an html editor and
validate it online with w3.org's validator.

Comment syntax varies depending on the type of template file and
sometimes depending on the location within the file. StaticTea
supports several varieties and you can specify others.

You want to distinguish StaticTea commands from normal comments
when you create your own. The convention is to add a $ as the
last character of the prefix and only use $ with StaticTea
commands and space for normal comments.

Some file types, like markdown, don't support comments, for
them use $$.

Built in Prefixes:

- html: <!--$ and -->
- html: &lt;!--$ and --&gt; for textarea elements
- bash: #$
- org mode: # $
- config files: ;$
- C++: //$
- C language: ​/\star$ and \star​/
- markdown: $$

You can define other comment types on the command line using the
prepost option one or more times. When you specify your own
prepost values, the defaults no longer exist so you have control
of which prefixes get used.

You specify the prepost option with the prefix separated from the
postfix with a comma and the postfix is optional,
"prefix[,postfix]". A prefix and postfix contain 1 to 20 ascii
characters including spaces but without control characters or
commas.

examples:

#+BEGIN_SRC
--prepost="pre$,post"
--prepost="a$,b"
--prepost="@$,|"
--prepost="#[$,]#"
--prepost="# $"
#+END_SRC

[[#contents][茶]]

** Encoding and Line Endings
:PROPERTIES:
:CUSTOM_ID: encoding-and-line-endings
:END:

Templates are utf-8 encoded.  Two line endings are supported on
all platforms: LF, and CR/LF.  Line endings are preserved.  The
template syntax only uses ascii except unicode characters are
allowed in quoted strings. The maximum command line length is
1024 bytes, there is no limit on non-command lines.

Since line endings are preserved and there are no encoding or
line length restrictions on non-command lines, you can make
templates out of binary or mixed binary and text files like EPS
or PDF files.

[[#contents][茶]]

** Update Option
:PROPERTIES:
:CUSTOM_ID: update-option
:END:

The --update option updates the template's replace blocks to
match their t.content text.  The text normally comes from the
shared template files but it doesn't have to.

You use this to keep the template blocks in sync with the shared
content so you can work with them as static pages.

#+BEGIN_SRC
statictea \
  --server server.json \
  --shared shared.json \
  --template template.html \
  --update
#+END_SRC

[[#contents][茶]]

** Log File
:PROPERTIES:
   :CUSTOM_ID: log-file
   :END:

The log file contains information about processing your
template. Template commands can also write to the log file.

Log information is appended to the file.  When the file size
exceeds 1 GB, a warning message is generated each time a template
is processed.

Logging is off by default. You turn it on with the --log option.
You can specify the log file full path.  If you don't specify a
filename, "statictea.log" is used. The log location depends on
the platform:

- Mac: ~/Library/lib/statictea.log
- Other: ~/statictea.log

[[#contents][茶]]

** Module Docs
:PROPERTIES:
   :CUSTOM_ID: module-docs
   :END:

You can read the StaticTea source code documentation in Gitlab
because it is formatted as gitlab markdown. Statictea
created the markdown files from the embedded doc comments.

- [[docs/index.md][Module Index]] --- Index to the nim module documents.

Build Module Index:

The nimble *docsix* task builds the module index markdown file by running
the following process:

1. create a json file from the doc comments at the top of all the source files
2. format the json as markdown using the [[templates/nimModuleIndex.md][nimModuleIndex.md]] statictea template

Build Module Docs:

The nimble *docs* task builds the modules markdown files by running
the following process for each module:

1. create a json file of a module docs using nim's jsondoc command
2. format the json as markdown using the [[templates/nimModule.md][nimModule.md]] statictea template

[[#contents][茶]]

** HTML Formatted Json
:PROPERTIES:
   :CUSTOM_ID: html-formatted-json
   :END:

The nim jsondoc command produces html formatted json data.  Our
desired final format is Gitlab markdown so having html
presentation data in the json is a problem.

It was discovered that single paragraph comments are left
unformatted.  This is the basis for a workaround. You make all
the documentation look like one paragraph by inserting some
symbols in strategic places, then the json data does not contain
html formatting.

Workaround Rules:

- use @: at the beginning of lines, except the first line.
- use ~~~ to begin a code block
- use ~~~~ to end a code block
- use @|, |@ and @@ to disguise a link, see example:

#+BEGIN_SRC
[Semantic Versioning](https://semver.org/)
@|Semantic Versioning|@(https@@://semver.org/)
#+END_SRC

[[#contents][茶]]

** Nimble Tasks
:PROPERTIES:
   :CUSTOM_ID: nimble-tasks
   :END:

You can run commands to build, test, make docs etc. using nimble
task commands. From the statictea folder run the n task to see
the available tasks.

#+BEGIN_SRC
cd ~/code/statictea
alias n='nimble --silent'
n n
#+END_SRC

Here is the output:

#+BEGIN_SRC
n           Show available tasks.
t           Run all tests at once.
test        Run tests; specify part of test filename.
b           Build the statictea exe.
docs        Create markdown docs; specify part of source filename.
docsix      Create markdown docs index.
json        Display markdown docs json; specify part of name.
jsonix      Display markdown docs index json.
readmefun   Create readme function section.
dot         Create a dependency graph of the StaticTea source.
dot2        Create a dependency graph system modules used by StaticTea.
tt          Compile and run t.nim.
tree        Show the project directory tree.
args        Show command line arguments.
#+END_SRC

[[#contents][茶]]

* Functions
:PROPERTIES:
:CUSTOM_ID: functions
:ORDERED:  t
:END:

Functions allow you to format variables for presentation.  They
return a value that you assign to a variable or pass to another
function.

This section was created from the nim source code by running the
readmefun nimble task which uses the StaticTea template
[[templates/readmeFuncSection.org][readmeFuncSection.org]].

List of functions:

# Dynamic Content Begins
- [[#add][add()]] -- Add two or more numbers.
- [[#case][case()]] -- Return a value from multiple choices.
- [[#cmp][cmp()]] -- Compare two values.
- [[#cmpVersion][cmpVersion()]] -- Compare two StaticTea version numbers.
- [[#concat][concat()]] -- Concatentate two or more strings.
- [[#dict][dict()]] -- Create a dictionary from a list of key, value pairs.
- [[#dup][dup()]] -- Duplicate a string.
- [[#exists][exists()]] -- Determine whether a key exists in a dictionary.
- [[#find][find()]] -- Find the position of a substring in a string.
- [[#float][float()]] -- Create a float from an int or an int number string.
- [[#get][get()]] -- Get a value from a list or dictionary.
- [[#githubAnchor][githubAnchor()]] -- Create a Github markdown anchor name given a heading name.
- [[#if][if()]] -- Return a value based on a condition.
- [[#int][int()]] -- Create an int from a float or a float number string.
- [[#keys][keys()]] -- Create a list from the keys in a dictionary.
- [[#len][len()]] -- Length of a string, list or dictionary.
- [[#list][list()]] -- Create a list of values.
- [[#lower][lower()]] -- Lowercase a string.
- [[#path][path()]] -- Split a file path into pieces.
- [[#replace][replace()]] -- Replace a substring by its position.
- [[#replaceRe][replaceRe()]] -- Replace multiple parts of a string using regular expressions.
- [[#sort][sort()]] -- Sort a list of values of the same type.
- [[#substr][substr()]] -- Extract a substring from a string by its position.
- [[#values][values()]] -- Create a list of the values in the specified dictionary.

[[#contents][茶]]

** add()
:PROPERTIES:
:CUSTOM_ID: add
:END:

Add two or more numbers.  The parameters must be all integers or
all floats.  A warning is generated on overflow.

Integer case:

- p1: int
- p2: int
- ...
- pn: int
- return: int

Float case:

- p1: float
- p2: float
- ...
- pn: float
- return: float

Examples:

#+BEGIN_SRC
add(1, 2) => 3
add(1, 2, 3) => 6

add(1.5, 2.3) => 3.8
add(1.1, 2.2, 3.3) => 6.6
#+END_SRC

[[#contents][茶]]

** case()
:PROPERTIES:
:CUSTOM_ID: case
:END:

Return a value from multiple choices. It takes a main condition,
any number of case pairs then an optional else value.

The first parameter of a case pair is the condition and the
second is the return value when that condition matches the main
condition. The function compares the conditions left to right and
returns the first match.

When none of the cases match the main condition, the "else"
value is returned. If none match and the else is missing, a
warning is generated and the statement is skipped. The conditions
must be integers or strings. The return values can be any type.

- p1: the main condition value
- p2: the first case condition
- p3: the first case value
- ...
- pn-2: the last case condition
- pn-1: the last case value
- pn: the optional "else" value returned when nothing matches
- return: any value

Examples:

#+BEGIN_SRC
case(8, 8, "tea", "water") => "tea"
case(8, 3, "tea", "water") => "water"
case(8,
  1, "tea", +
  2, "water", +
  3, "wine", +
  "beer") => "beer"
#+END_SRC

[[#contents][茶]]

** cmp()
:PROPERTIES:
:CUSTOM_ID: cmp
:END:

Compare two values. Returns -1 for less, 0 for equal and 1 for
greater than.  The values are either int, float or string (both the
same type) The default compares strings case sensitive.

Compare numbers:

- p1: number
- p2: number
- return: -1, 0, 1

Compare strings:

- p1: string
- p2: string
- p3: optional: 1 for case insensitive
- return: -1, 0, 1

Examples:

#+BEGIN_SRC
cmp(7, 9) => -1
cmp(8, 8) => 0
cmp(9, 2) => 1

cmp("coffee", "tea") => -1
cmp("tea", "tea") => 0
cmp("Tea", "tea") => 1
cmp("Tea", "tea", 1) => 0
#+END_SRC

[[#contents][茶]]

** cmpVersion()
:PROPERTIES:
:CUSTOM_ID: cmpVersion
:END:

Compare two StaticTea version numbers. Returns -1 for less, 0 for
equal and 1 for greater than.

StaticTea uses [[https://semver.org/][Semantic Versioning]]
with the added restriction that each version component has one
to three digits (no letters).

- p1: version number string
- p2: version number string
- return: -1, 0, 1

Examples:

#+BEGIN_SRC
cmpVersion("1.2.5", "1.1.8") => -1
cmpVersion("1.2.5", "1.3.0") => 1
cmpVersion("1.2.5", "1.2.5") => 0
#+END_SRC

[[#contents][茶]]

** concat()
:PROPERTIES:
:CUSTOM_ID: concat
:END:

Concatentate two or more strings.

- p1: string
- p2: string
- ...
- pn: string
- return: string

Examples:

#+BEGIN_SRC
concat("tea", " time") => "tea time"
concat("a", "b", "c", "d") => "abcd"
#+END_SRC

[[#contents][茶]]

** dict()
:PROPERTIES:
:CUSTOM_ID: dict
:END:

Create a dictionary from a list of key, value pairs.  The keys
must be strings and the values can be any type.

#+BEGIN_SRC
dict(pairs: optional varargs(string, any)) dict
#+END_SRC

Examples:

#+BEGIN_SRC
dict() => {}
dict("a", 5) => {"a": 5}
dict("a", 5, "b", 33, "c", 0) =>
  {"a": 5, "b": 33, "c": 0}
#+END_SRC

[[#contents][茶]]

** dup()
:PROPERTIES:
:CUSTOM_ID: dup
:END:

Duplicate a string. The first parameter is the string to dup and
the second parameter is the number of times to duplicate it.

#+BEGIN_SRC
dup(pattern: string, count: int) string
#+END_SRC

Examples:

#+BEGIN_SRC
dup("=", 3) => "==="
dup("abc", 2) => "abcabc"
#+END_SRC

[[#contents][茶]]

** exists()
:PROPERTIES:
:CUSTOM_ID: exists
:END:

Determine whether a key exists in a dictionary.

- p1: dictionary
- p2: key string
- return: 0 or 1

Examples:

#+BEGIN_SRC
d = dict("tea", "Earl")
exists(d, "tea") => 1
exists(d, "coffee") => 0
#+END_SRC

[[#contents][茶]]

** find()
:PROPERTIES:
:CUSTOM_ID: find
:END:

Find the position of a substring in a string.  When the substring
is not found you can return a default value.  A warning is
generated when the substring is missing and you don't specify a
default value.


- p1: string
- p2: substring
- p3: optional default value
- return: the index of substring or p3

#+BEGIN_SRC
       0123456789 1234567
msg = "Tea time at 3:30."
find(msg, "Tea") = 0
find(msg, "time") = 4
find(msg, "me") = 6
find(msg, "party", -1) = -1
find(msg, "party", len(msg)) = 17
find(msg, "party", 0) = 0
#+END_SRC

[[#contents][茶]]

** float()
:PROPERTIES:
:CUSTOM_ID: float
:END:

Create a float from an int or an int number string.

- p1: int or int string
- return: float

Examples:

#+BEGIN_SRC
float(2) => 2.0
float("33") => 33.0
#+END_SRC

[[#contents][茶]]

** get()
:PROPERTIES:
:CUSTOM_ID: get
:END:

Get a value from a list or dictionary.  You can specify a default
value to return when the value doesn't exist, if you don't, a
warning is generated when the element doesn't exist.

Note: for dictionary lookup you can use dot notation for many
cases.

Dictionary case:

- p1: dictionary
- p2: key string
- p3: optional default value returned when key is missing
- return: value

List case:

- p1: list
- p2: index of item
- p3: optional default value returned when index is too big
- return: value

Examples:

#+BEGIN_SRC
d = dict("tea", "Earl Grey")
get(d, 'tea') => "Earl Grey"
get(d, 'coffee', 'Tea') => "Tea"

list = list(4, 'a', 10)
get(list, 2) => 10
get(list, 3, 99) => 99

d = dict("tea", "Earl Grey")
d.tea => "Earl Grey"
#+END_SRC

[[#contents][茶]]

** githubAnchor()
:PROPERTIES:
:CUSTOM_ID: githubAnchor
:END:

Create a Github markdown anchor name given a heading name.  If
you have duplicate heading names, the anchor name returned only
works for the first. Use it for Github markdown internal links.

#+BEGIN_SRC
githubAnchor(name: string) string
#+END_SRC

Examples:

#+BEGIN_SRC
githubAnchor("MyHeading") => "myheading"
githubAnchor("Eary Gray") => "eary-gray"
githubAnchor("$Eary-Gray#") => "eary-gray"
#+END_SRC

Example in a markdown template:

#+BEGIN_SRC
$$ : anchor = githubAnchor(entry.name)
- {type}[{entry.name}](#{anchor}) &mdash; {short}
...
# {entry.name}
#+END_SRC

[[#contents][茶]]

** if()
:PROPERTIES:
:CUSTOM_ID: if
:END:

Return a value based on a condition.

- p1: int condition
- p2: true case: the value returned when condition is 1
- p3: else case: the value returned when condition is not 1.
- return: p2 or p3

Examples:

#+BEGIN_SRC
if(1, 'tea', 'beer') => "tea"
if(0, 'tea', 'beer') => "beer"
if(4, 'tea', 'beer') => "beer"
#+END_SRC

[[#contents][茶]]

** int()
:PROPERTIES:
:CUSTOM_ID: int
:END:

Create an int from a float or a float number string.

- p1: float or float number string
- p2: optional round option. "round" is the default.
- return: int

Round options:

- "round" - nearest integer
- "floor" - integer below (to the left on number line)
- "ceiling" - integer above (to the right on number line)
- "truncate" - remove decimals

Examples:

#+BEGIN_SRC
int("2") => 2
int("2.34") => 2
int(2.34, "round") => 2
int(-2.34, "round") => -2
int(6.5, "round") => 7
int(-6.5, "round") => -7
int(4.57, "floor") => 4
int(-4.57, "floor") => -5
int(6.3, "ceiling") => 7
int(-6.3, "ceiling") => -6
int(6.3456, "truncate") => 6
int(-6.3456, "truncate") => -6
#+END_SRC

[[#contents][茶]]

** keys()
:PROPERTIES:
:CUSTOM_ID: keys
:END:

Create a list from the keys in a dictionary.

#+BEGIN_SRC
keys(dictionary: dict) list
#+END_SRC

Examples:

#+BEGIN_SRC
d = dict("a", 1, "b", 2, "c", 3)
keys(d) => ["a", "b", "c"]
values(d) => ["apple", 2, 3]
#+END_SRC

[[#contents][茶]]

** len()
:PROPERTIES:
:CUSTOM_ID: len
:END:

Length of a string, list or dictionary. For strings it returns
the number of characters, not bytes. For lists and dictionaries
it return the number of elements.

- p1: string, list or dict
- return: int

Examples:

#+BEGIN_SRC
len("tea") => 3
len(list(4, 1)) => 2
len(dict('a', 4)) => 1
#+END_SRC

[[#contents][茶]]

** list()
:PROPERTIES:
:CUSTOM_ID: list
:END:

Create a list of values.

#+BEGIN_SRC
list(items: optional varargs(any)) list
#+END_SRC

Examples:

#+BEGIN_SRC
list() => []
list(1) => [1]
list(1, 2, 3) => [1, 2, 3]
list("a", 5, "b") => ["a", 5, "b"]
#+END_SRC

[[#contents][茶]]

** lower()
:PROPERTIES:
:CUSTOM_ID: lower
:END:

Lowercase a string.

#+BEGIN_SRC
lower(str: string) string
#+END_SRC

Examples:

#+BEGIN_SRC
lower("Tea") => "tea"
lower("TEA") => "tea"
#+END_SRC

[[#contents][茶]]

** path()
:PROPERTIES:
:CUSTOM_ID: path
:END:

Split a file path into pieces. Return a dictionary with the
filename, basename, extension and directory.

You pass a path string and the optional path separator, "/" or
"\". When no separator, the current system separator is used.

#+BEGIN_SRC
path(filename: string, optional separator: string) dict
#+END_SRC

Examples:

#+BEGIN_SRC
path("src/runFunction.nim") => {
  "filename": "runFunction.nim",
  "basename": "runFunction",
  "ext": ".nim",
  "dir": "src/",
}

path("src\runFunction.nim", "\") => {
  "filename": "runFunction.nim",
  "basename": "runFunction",
  "ext": ".nim",
  "dir": "src\",
}
#+END_SRC

[[#contents][茶]]

** replace()
:PROPERTIES:
:CUSTOM_ID: replace
:END:

Replace a substring by its position.  You specify the substring
position and the string to take its place.  You can use it to
insert and append to a string as well.

#+BEGIN_SRC
replace(str: string, start: int, length: int, replacement: string) string
#+END_SRC

- str: string
- start: substring start index
- length: substring length
- replacement: substring replacement

Examples:

#+BEGIN_SRC
replace("Earl Grey", 5, 4, "of Sandwich")
  => "Earl of Sandwich"
replace("123", 0, 0, "abcd") => abcd123
replace("123", 0, 1, "abcd") => abcd23
replace("123", 0, 2, "abcd") => abcd3
replace("123", 0, 3, "abcd") => abcd
replace("123", 3, 0, "abcd") => 123abcd
replace("123", 2, 1, "abcd") => 12abcd
replace("123", 1, 2, "abcd") => 1abcd
replace("123", 0, 3, "abcd") => abcd
replace("123", 1, 0, "abcd") => 1abcd23
replace("123", 1, 1, "abcd") => 1abcd3
replace("123", 1, 2, "abcd") => 1abcd
replace("", 0, 0, "abcd") => abcd
replace("", 0, 0, "abc") => abc
replace("", 0, 0, "ab") => ab
replace("", 0, 0, "a") => a
replace("", 0, 0, "") =>
replace("123", 0, 0, "") => 123
replace("123", 0, 1, "") => 23
replace("123", 0, 2, "") => 3
replace("123", 0, 3, "") =>
#+END_SRC

[[#contents][茶]]

** replaceRe()
:PROPERTIES:
:CUSTOM_ID: replaceRe
:END:

Replace multiple parts of a string using regular expressions.

You specify one or more pairs of a regex patterns and its string
replacement. The pairs can be specified as parameters to the
function or they can be part of a list.

Muliple parameters case:

- p1: string to replace
- p2: pattern 1
- p3: replacement string 1
- p4: optional: pattern 2
- p5: optional: replacement string 2
- ...
- pn-1: optional: pattern n
- pn: optional: replacement string n
- return: string

List case:

- p1: string to replace
- p2: list of pattern and replacement pairs
- return: string

Examples:

#+BEGIN_SRC
replaceRe("abcdefabc", "abc", "456")
  => "456def456"
replaceRe("abcdefabc", "abc", "456", "def", "")
  => "456456"
list = list("abc", "456", "def", "")
replaceRe("abcdefabc", list))
  => "456456"
#+END_SRC

For developing and debugging regular expressions see the
website: https://regex101.com/

[[#contents][茶]]

** sort()
:PROPERTIES:
:CUSTOM_ID: sort
:END:

Sort a list of values of the same type.

When sorting strings you have the option to compare case
sensitive or insensitive.

When sorting lists the lists are compared by their first
element. The first elements must exist, be the same type and be
an int, float or string. You have the option of comparing strings
case insensitive.

Dictionaries are compared by the value of one of their keys.  The
key values must exist, be the same type and be an int, float or
string. You have the option of comparing strings case
insensitive.

int, float case:

- p1: list of ints or list of floats
- p2: optional: "ascending", "descending"
- return: sorted list

string or list case:

- p1: list of strings or list of lists
- p2: optional: "ascending", "descending"
- p3: optional: default "sensitive", "insensitive"
- return: sorted list

dictionary case:

- p1: list of dictionaries
- p2: "ascending", "descending"
- p3: "sensitive", "insensitive"
- p4: key string
- return: sorted list

Examples:

#+BEGIN_SRC
list = list(4, 3, 5, 5, 2, 4)
sort(list) => [2, 3, 4, 4, 5, 5]
sort(list, "descending") => [5, 5, 4, 4, 3, 2]

strs = list('T', 'e', 'a')
sort(strs) => ['T', 'a', 'e']
sort(strs, "ascending", "sensitive") => ['T', 'a', 'e']
sort(strs, "ascending", "insensitive") => ['a', 'e', 'T']

l1 = list(4, 3, 1)
l2 = list(2, 3, 0)
listOfList = list(l1, l2)
sort(listOfList) => [l2, l1]

d1 = dict('name', 'Earl Gray', 'weight', 1.2)
d2 = dict('name', 'Tea Pot', 'weight', 3.5)
dicts = list(d1, d2)
sort(dicts, "ascending", "sensitive", 'weight') => [d1, d2]
sort(dicts, "descending", "sensitive", 'name') => [d2, d1]
#+END_SRC

[[#contents][茶]]

** substr()
:PROPERTIES:
:CUSTOM_ID: substr
:END:

Extract a substring from a string by its position. You pass the
string, the substring's start index then its end index+1.
The end index is optional and defaults to the end of the
string.

The range is half-open which includes the start position but not
the end position. For example, [3, 7) includes 3, 4, 5, 6. The
end minus the start is equal to the length of the substring.

#+BEGIN_SRC
substr(str: string, start: int, optional end: int) string
#+END_SRC

Examples:

#+BEGIN_SRC
substr("Earl Grey", 0, 4) => "Earl"
substr("Earl Grey", 5) => "Grey"
#+END_SRC

[[#contents][茶]]

** values()
:PROPERTIES:
:CUSTOM_ID: values
:END:

Create a list of the values in the specified dictionary.

#+BEGIN_SRC
values(dictionary: dict) list
#+END_SRC

Examples:

#+BEGIN_SRC
d = dict("a", "apple", "b", 2, "c", 3)
keys(d) => ["a", "b", "c"]
values(d) => ["apple", 2, 3]
#+END_SRC

# Dynamic Content Ends
* Contents :notoc:
:PROPERTIES:
:CUSTOM_ID: contents
:END:

# You run the command below to make the table of contents. Copy
# to scratch to remove the leading pound signs.
# grep '^\* ' readme.org | grep -v ":notoc" | cut -c 3- | \
# awk '{a = $0; gsub(" ", "-", a); printf "- [[#%s][%s]]\n", tolower(a), $0 }'

- [[#advantages][Advantages]]
- [[#how-it-works][How it Works]]
- [[#commands][Commands]]
- [[#replacement-block][Replacement Block]]
- [[#statements][Statements]]
- [[#syntax][Syntax]]
- [[#variables][Variables]]
- [[#types][Types]]
- [[#run-statictea][Run StaticTea]]
- [[#miscellaneous][Miscellaneous]]
- [[#functions][Functions]]

* Tea Info                                                            :notoc:

Tea is the most popular manufactured drink consumed in the world,
equaling all others – including coffee, soft drinks, and alcohol
– combined. -- Wikipedia -- Macfarlane, Alan; Macfarlane, Iris
(2004). The Empire of Tea. The Overlook Press. p. 32. ISBN
978-1-58567-493-0.
