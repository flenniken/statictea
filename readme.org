#+TITLE: StaticTea

[[docs/teapotlogo.svg]]

A template processor and language.

StaticTea produces a file from a template and optional json and
code files.

Example hello world html template:

#+BEGIN_SRC
<!--$ nextline -->
hello {s.name}
#+END_SRC

The associated json data:

#+BEGIN_SRC
{"name": "world"}
#+END_SRC

The result:

#+BEGIN_SRC
hello world
#+END_SRC

[[#contents][茶]] (table of contents at the bottom)

* Advantages
:PROPERTIES:
:CUSTOM_ID: advantages
:END:

You can view, edit and validate your templates with its normal
tools as if they were static pages and at the same time share
common template fragments between templates.

The template designer has full control over the presentation
providing a clear separation of concerns. They can change the
look without changing the server.

[[#contents][茶]]

* How it Works
:PROPERTIES:
:CUSTOM_ID: how-it-works
:END:

You create a template and add command lines around your variable
content. This defines the replacement blocks.

In the replacement blocks you add variables in brackets for
substitutions.

In the commands you format the variables for the replacement
blocks.

You specify the commands so they look like comments for your
template type.

[[#contents][茶]]

* Commands
:PROPERTIES:
:CUSTOM_ID: commands
:END:

A StaticTea command marks a replacement block in the template and
it provides a place for your code statements.

- [[#nextline-command][nextline]] -- make substitutions in the next line
- [[#block-command][block]] —- make substitutions in the next block of lines
- [[#replace-command][replace]] -— replace the block with a variable
- [[#endblock-command][endblock]] -- end the block and replace commands
- : ([[#continue-command][continue]]) -- continue a command
- # ([[#comment-command][comment]]) -- code comment

[[#contents][茶]]

** Nextline Command
:PROPERTIES:
:CUSTOM_ID: nextline-command
:END:

The nextline command targets the line following it for
replacement. The targeted line is called the replacement block.

The following example's replacement block contains two variables,
drink and drinkType.

template:

#+BEGIN_SRC
<!--$ nextline -->
Drink {s.drink} -- {s.drinkType} is my favorite.
#+END_SRC

server json:

#+BEGIN_SRC
{
  "drink": "tea",
  "drinkType": "Earl Grey"
}
#+END_SRC

result:

#+BEGIN_SRC
Drink tea -- Earl Grey is my favorite.
#+END_SRC

[[#contents][茶]]

** Block Command
:PROPERTIES:
:CUSTOM_ID: block-command
:END:

The block command targets multiple lines for replacement. The
replacement block starts after the command and continues until
the endblock line is found. It behaves like the nextline command
except with multiple lines.

In the following example the block has three lines. The block
contains three replacement variables, weekday, name and time.

template:

#+BEGIN_SRC
<!--$ block -->
Join our tea party on
{s.weekday} at {s.name}'s
house at {s.time}.
<!--$ endblock -->
#+END_SRC

server json:

#+BEGIN_SRC
{
  "weekday": "Friday",
  "name": "John",
  "time": "5:00 pm"
}
#+END_SRC

result:

#+BEGIN_SRC
Join our tea party on
Friday at John's
house at 5:00 pm.
#+END_SRC

[[#contents][茶]]

** Replace Command
:PROPERTIES:
:CUSTOM_ID: replace-command
:END:

The replace command's replacement block gets replaced with the
t.content variable. Here is a simple example:

template:

#+BEGIN_SRC
<!--$ replace t.content = o.header -->
<!--$ endblock -->
#+END_SRC

shared code file:

#+BEGIN_SRC nim
o.header = """
<!doctype html>
<html lang="en">
"""
#+END_SRC

result:

#+BEGIN_SRC
<!doctype html>
<html lang="en">
#+END_SRC

The above example generates the correct result but it doesn’t
work as a static template because the template is missing the
header lines.

You can add lines to the replace command's replacement block to
mirror the t.content variable so you can develop and test the
template as if it was a static file.

The replace command allows you to share common template lines between
templates and at the same time work with them as static pages.

Since you are duplicating content in the replacement block, when
you want to edit the shared text it will get out of sync. You can
update your templates using the [[#update-option][Update Option]].

If you don't assign the t.content variable, a warning is
generated, and the command behaves like a block command.  This is
good for testing changes you want to make to the shared value.

The following example uses a common header from the shared code
file and it mirrors it in the replacement block.

template:

#+BEGIN_SRC
<!--$ replace t.content = o.header -->
<!doctype html>
<html lang="en">
<!--$ endblock -—>
#+END_SRC

The shared variable may contain replacement content too.  Here is
an example of that:

template:

#+BEGIN_SRC
<!--$ replace t.content = o.header -->
<!DOCTYPE html>
<html lang="{s.languageCode}" dir="{s.languageDirection}">
<head>
<meta charset="UTF-8"/>
<title>{s.title}</title>
<--$ endblock -->
#+END_SRC

server json:

#+BEGIN_SRC
{
"languageCode": "en",
"languageDirection": "ltr",
"title": "Teas in England"
}
#+END_SRC

shared code file:

#+BEGIN_SRC nim
o.header = """
<!DOCTYPE html>
<html lang="{s.languageCode}" dir="{s.languageDirection}">
<head>
<meta charset="UTF-8"/>
<title>{s.title}</title>
"""
#+END_SRC

result:

#+BEGIN_SRC
<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8"/>
<title>Teas in England</title>
#+END_SRC

[[#contents][茶]]

** Endblock Command
:PROPERTIES:
:CUSTOM_ID: endblock-command
:END:

The endblock command ends the replacement block for the block and
replace commands. For example:

#+BEGIN_SRC
$$ block
replacement block text
replacement block text
$$ endblock

$$ replace
replacement block text
replacement block text
$$ endblock
#+END_SRC

Only the endblock command ends them. All text until the endblock
is part of the replacement block. This includes lines that look
like commands. For example:

template:

#+BEGIN_SRC
<!--$ block -->
<!--$ # this is not a comment, just text -->
fake nextline
<!--$ nextline -->
<!--$ endblock -->
#+END_SRC

result:

#+BEGIN_SRC
<!--$ # this is not a comment, just text -->
fake nextline
<!--$ nextline -->
#+END_SRC

[[#contents][茶]]

** Continue Command
:PROPERTIES:
:CUSTOM_ID: continue-command
:END:

The continue command (a colon) allows you to continue adding
statements to the nextline, block and replace commands.

We often refer to the command and its continue commands as the
command (one logical unit).

In the following example the nextline command continues on a
second line and third line because of the two continue commands.

template:

#+BEGIN_SRC
$$ nextline
$$ : tea = "Earl Grey"
$$ : tea2 = "Masala chai"
{tea}, {tea2}
#+END_SRC

result:

#+BEGIN_SRC
Earl Grey, Masala chai
#+END_SRC

[[#contents][茶]]

** Comment Command
:PROPERTIES:
:CUSTOM_ID: comment-command
:END:

You can comment templates with the comment command.  Comments
are line based and use the # character. They do not appear in the
result.

template:

#+BEGIN_SRC
<!--$ # The main tea groups. -->
There are five main groups of teas:
white, green, oolong, black, and pu'erh.
You make Oolong Tea in five time
intensive steps.
#+END_SRC

result:

#+BEGIN_SRC
There are five main groups of teas:
white, green, oolong, black, and pu'erh.
You make Oolong Tea in five time
intensive steps.
#+END_SRC

You can also comment in statements with # to the end of the line,
see the [[#syntax][Syntax]] section.

[[#contents][茶]]

* Replacement Block
:PROPERTIES:
:CUSTOM_ID: replacement-block
:END:

A replacement block is a group of contiguous lines in a template
between a command and its endblock or for the nextline command,
the one line after it.

The block contains any number of bracketed variables for
substitution. Each variable gets replaced with its value.

You have control over where the replacement block goes, either
the result file, standard out, standard error, or the log file
using the t.output variable.

You can repeat the block to make lists and other repeating
content. You control how many times the block repeats with the
t.repeat variable.  You can skip and stop early with the return
function. The t.row counts the number of times the block has
repeated and you use its value to customize each repeated block.

Below is an example that repeats the block three times and
outputs 0, 1, 2:

template:

#+BEGIN_SRC
$$ nextline t.repeat = 3
{t.row}
#+END_SRC

result:

#+BEGIN_SRC
0
1
2
#+END_SRC

If a replacement block variable doesn't exist, the bracketed
variable remains as is in the result, and a message is output to
standard error. For example:

template:

#+BEGIN_SRC
<!--$ block -->
You're a {s.webmaster},
I'm a {s.teaMaster}!
<!--$ endblock -->
#+END_SRC

server json:

#+BEGIN_SRC
{
 "webmaster": "html wizard"
}
#+END_SRC

stderr:

#+BEGIN_SRC
template.html(3): w58: The replacement variable doesn't exist: s.teaMaster.
#+END_SRC

result:

#+BEGIN_SRC
You're a html wizard,
I'm a {s.teaMaster}!
#+END_SRC

[[#contents][茶]]

* Statements
:PROPERTIES:
:CUSTOM_ID: statements
:END:

You create a new variable with a statement. A statement is an
expression consisting of a variable name, an operator and a right
hand side.

For the example below, tea is the variable name, = is the
operator and "Earl Grey" is the right hand side:

#+BEGIN_SRC
tea = "Earl Grey"
#+END_SRC

The operator is either an equal sign or an "&=". The equal sign
appends to a dictionary and the &= appends to a list.

The right hand side is either a variable, string, number, list,
boolean expression or a function.

Here are a few example statements:

#+BEGIN_SRC nim
tea = "Earl Grey"
num = 5
t.repeat = len(tealist)
numList = [1, 2, 3]
flag = (s.name > 20)
name = s.firstName
b &= 3
#+END_SRC

Statements are allowed on the nextline, block, continue and
replace commands.

In the next example, the block command and the continue command
contain a statement.

#+BEGIN_SRC
$$ block tea = "Earl Grey"
$$ : a = 5
$$ endblock
#+END_SRC


Most operations are done with functions. For example, to add 1 to
t.row you use the add function.

#+BEGIN_SRC nim
num = add(t.row, 1)
#+END_SRC

Statements are executed from top to bottom. You can use the warn
function to exit a statement early and use the return function to
exit a command early.

If there is a syntax error or a function generates a warning, the
statement is skipped.

You can continue a long statement on the next line by using a "+"
character at the end.

You can have a bare IF function on a statement and a few other
exceptions, see special forms [[#special-forms][Special Forms]].

[[#contents][茶]]

* Syntax
:PROPERTIES:
:CUSTOM_ID: syntax
:END:

A template consists of command lines and non-command lines.  The
command lines are line oriented and they have the same form and
they are limited to 1024 bytes. There are no restrictions on the
non-command lines in a template.

Each command line is a comment to match the template type. The
beginning comment characters are called the prefix and the
optional ending comment characters are called the postfix. For
example, in an html template the prefix is "<!--$" and the
postfix is "-->". See [[#prefix-postfix][Prefix Postfix]] for more information.

From left to right a command line consists of:

- a prefix at column 1.
- a command name
- an optional statement
- an optional comment
- an optional plus continuation character
- an optional postfix
- the end of line, either \r\n or \n.

Here is a chart showing line components and where spaces
are allowed:

#+BEGIN_SRC
prefix
|     command  [statement]
|     |        |   [comment]
|     |        |   |       [continuation]
|     |        |   |       |[postfix]
|     |        |   |       ||  [newline]
|     |        |   |       ||  |
<!--$ nextline a=5 # set a +-->
     |        |            |
     |        |      no spaces at the end
     |        one required space
     optional spaces
#+END_SRC

The chart below shows a nextline command with three continuation
commands and three statements: a = 5, b = "tea" and c = "The Earl
of Grey".

#+BEGIN_SRC
prefix
|     command  statement
|     |        |         continuation
|     |        |         |
|     |        |         |postfix
|     | +------+         ||  newline
|     | |      |         ||  |
<!--$ nextline a = 5      -->
<!--$ : b = "tea"         -->
<!--$ : c = "The Earl of +-->
<!--$ : Grey"             -->
#+END_SRC

A statement starts one space after the command. You can use more
spaces but they are part of the statement. This is important when
you wrap quoted strings with a continuation.

Space isn't allowed before the prefix, after the continuation or
after the postfix or between the function name and its opening
parentheses. Here are a few single line examples:

#+BEGIN_SRC
$$ nextline
$$ nextline a=5
$$ nextline a = 5
$$ nextline num = len(s.tea_list)
$$ nextline  num = len( s.tea_list )
$$nextline
$$   nextline
#+END_SRC

The statements may flow between lines by using the continuation
plus character. The following two nextline commands are
equivalent:

#+BEGIN_SRC
<!--$ nextline com = "Bigelow Tea Company" -->

<!--$ nextline com = "Big+-->
<!--$ : elow Tea Company" -->
#+END_SRC

You can have blank statements that do nothing.

#+BEGIN_SRC
$$ nextline
$$ :
$$ : # comment
#+END_SRC

[[#contents][茶]]

* Variables
:PROPERTIES:
:CUSTOM_ID: variables
:END:

You use variables to add variable content to replacement blocks.

A string variable gets replaced with its value, a function
variable with its name, and the other variable types get replaced
with their json equivalent.

In the example below, "name" and "teas" are variables that are
defined in the command. Both variables are used in the
replacement block.

Template:

#+BEGIN_SRC
$$ block
$$ : name = "Eary Grey"
$$ : teas = list("Black", "Green", "Oolong")
Popular tea: {name}
Available kinds: {teas}
$$ endblock
#+END_SRC

Result:

#+BEGIN_SRC
Popular tea: Earl Grey
Available kinds: ["Black","Green","Oolong"]
#+END_SRC

You use variables in the t dictionary (tea variables), to
control where the output goes, how many times it repeats and
other aspects controlling a command.

A variable name starts with a letter followed by letters, digits,
hyphens and underscores and ends with a letter or a digit. It is
limited to a total of 64 ASCII characters.

Some single letters are reserved for important dictionaries,
[[#single-letter-dictionaries][Single Letter Dictionaries]].

Example variable names:

#+BEGIN_SRC
a
tea-type
first_name
nameLen
b5
#+END_SRC

Each iteration of a replacement block starts fresh.  Local
variables and some tea variables are undefined before processing
the next replacement block. The t.repeat and t.row variables are
exceptions since they control the loop.

In the next example the name variable gets defined differently
for each iteration based on t.row.

#+BEGIN_SRC
$$ nextline
$$ : t.repeat = 3
$$ : name = format("a{t.row}")
{name}
#+END_SRC

Output:

#+BEGIN_SRC
a0
a1
a2
#+END_SRC

You can append a new variable to a list or dictionary but you
cannot change an existing variable.

A dot name is a fully qualified variable name where variables are
connected with dots. It is limited to 64 characters.

Example dot names:

#+BEGIN_SRC
t.repeat
s.name
d.path.filename
f.cmp
entry.name
#+END_SRC

You can leave off the "l" prefix from your non-function local
variables, they are assumed to be in the local dictionary.

Equivalent statements:

#+BEGIN_SRC
a = 5
l.a = 5
#+END_SRC

You can leave off the "f" prefix from built-in functions you
call, they are assumed to be in the function dictionary.  A
function call is a variable followed by a left parentheses.

Equivalent statements:

#+BEGIN_SRC nim
rt = cmp(a, b)
rt = f.cmp(a, b)
#+END_SRC

[[#contents][茶]]

* Single Letter Dictionaries
:PROPERTIES:
:CUSTOM_ID: single-letter-dictionaries
:END:

All variables are stored in one of the reserved one letter top
level dictionaries f - u. Seven are currently used: f, g, l, o,
s, t, u.

The server json variables are stored in the s dictionary. You
reference them with "s.", for example:

#+BEGIN_SRC
s.name
s.address
#+END_SRC

A local variable is stored in the l (local) dictionary. L is
implied for an unqualified non-function name.

You can use the unreserved beginning and ending letters of the
alphabet, a, b, c, d, e and v, w, x, y, z for your variable
names.

Reserved single letter variables:

- f -- [[#function-variables][Function Variables]]
- g -- [[#global-variables][Global Variables]]
- h, i, j, k -- Reserved
- l -- [[#local-variables][Local Variables]]
- m, n -- Reserved
- o -- [[#code-variables][Shared Code Variables]]
- p, q, r -- Reserved
- s -- [[#server-json-variables][Server Json Variables]]
- t -- [[#tea-variables][Tea Variables]]
- u -- [[#user-function-vars][User Function Vars]]

[[#contents][茶]]

** Function Variables
:PROPERTIES:
:CUSTOM_ID: function-variables
:END:

All the built-in functions exist in the f dictionary. F is
implied for an unqualified function name you call.  See [[#func-type][Func Type]]
for more information.

[[#contents][茶]]

** Global Variables
:PROPERTIES:
:CUSTOM_ID: global-variables
:END:

Variables you add to the g dictionary are global to the template
file. They’re visible to all commands in the template and they
are not reset like local variables.

Shared code cannot see or set g variables.

#+BEGIN_SRC nim
g.title = "Teas of the World"
g.names &= entry.name
#+END_SRC

[[#contents][茶]]

** Local Variables
:PROPERTIES:
:CUSTOM_ID: local-variables
:END:

Variables you create without a prefix go in the local (l)
dictionary.

The local variables are cleared and recalculated for each
iteration of a repeated block.

Inside a user defined function there is another local (l)
dictionary used for its local variables and parameters.

Examples:

#+BEGIN_SRC nim
a = 5
pot = "black"
l.tea = "earl grey"
#+END_SRC

[[#contents][茶]]

** Code Variables
:PROPERTIES:
:CUSTOM_ID: code-variables
:END:

You create code variables with statements in code files.  Code
variables are good for sharing between templates.

The variables go in the o dictionary, see [[#code-files][Code Files]].

[[#contents][茶]]

** Server Json Variables
:PROPERTIES:
:CUSTOM_ID: server-json-variables
:END:

You pass variables from the server to the template in json files.

The variables are defined by the top level JSON dictionary
items. Each item's key is the name of a variable and the item's
value is the variable's value.

You can use multiple server json files by specifying multiple
files on the command line. The files are processed left to right.

The server json files populate the s dictionary.

The json null values get converted to the 0.

To give full control of the presentation to the template
designers, the server json shouldn't contain any presentation
data.

[[#contents][茶]]

** User Function Vars
:PROPERTIES:
:CUSTOM_ID: user-function-vars
:END:

You use the u dictionary to store your function variables for
easy access inside other functions.

Similar to the f dictionary the u dictionary variables are
visible inside user defined functions so you don’t need to pass
them in.  You specify the u prefix when defining and calling the
function.

Only user function variables are allowed in the u
dictionary. Below is an example of defining u.myCmp and calling
it:

#+BEGIN_SRC nim
u.myCmp = func(…) int
…
a = u.myCmp("3", "4")
#+END_SRC

[[#contents][茶]]

** Tea Variables
:PROPERTIES:
    :CUSTOM_ID: tea-variables
    :END:

The tea variables control how the replacement block works and
they provide information about the system.  They are stored in
the t dictionary.

Tea variables:

- [[#targs][t.args]] -- arguments passed on the command line
- [[#tcontent][t.content]] -- content of the replace block
- [[#tmaxrepeat][t.maxRepeat]] -- maximum number of times to repeat the block
- [[#tmaxlines][t.maxLines]] -- maximum number of replacement block lines allowed
  before the endblock
- [[#toutput][t.output]] -- where the block output goes
- [[#trepeat][t.repeat]] -- how many times the block repeats
- [[#trow][t.row]] -- the current index number of a repeating block
- [[#tversion][t.version]] -- the StaticTea version number

[[#contents][茶]]

*** t.args
:PROPERTIES:
:CUSTOM_ID: targs
:END:

The read-only t.args variable contains the arguments passed to
statictea on the command line.

For example using the command line below results in a t.args
value shown:

#+BEGIN_SRC
statictea -l -s server.json -o codefile.tea \
  -s server2.json -o codefile2.tea \
  -p 'abc$,def' -p '$$' \
  -t template.html -r result.html

t.args => {
  "help":0,
  "version":0,
  "update":0,
  "log":1,
  "serverList":["server.json","server2.json"],
  "codeList":["codefile.tea","codefile2.tea"],
  "resultFilename":"result.html",
  "templateFilename":"template.html",
  "logFilename":"",
  "prepostList":[["abc$","def"],["$$",""]]
}
#+END_SRC

[[#contents][茶]]

*** t.content
:PROPERTIES:
:CUSTOM_ID: tcontent
:END:

The t.content variable determines the content used for the
replace command's whole replacement block.

#+BEGIN_SRC
t.content = h.header
#+END_SRC

You use [[#update-option][Update Option]] to keep the template's blocks in sync with
their variables.

When t.content is not set, the command behaves like a block
command except a warning message is output. This is good for
testing changes you want to make to the shared value and the
warning reminds you to set the variable when you're done testing.

The variable only applies to the replace command. See the
[[#replace-command][replace command]] section for an example.

[[#contents][茶]]

*** t.maxRepeat
:PROPERTIES:
:CUSTOM_ID: tmaxrepeat
:END:

The t.maxRepeat variable determines the maximum times a block can
repeat.  The default is 100. You can increase it to repeat more
times. You cannot assign a number to t.repeat bigger than
maxRepeat.

It prevents the case where you mistakenly assign a giant number,
and it allows you to design your template to work well for the
expected range of blocks.

[[#contents][茶]]

*** t.maxLines
:PROPERTIES:
:CUSTOM_ID: tmaxlines
:END:

The t.maxLines variable determines the maximum lines in a
replacement block.

StaticTea reads lines looking for the endblock.  By default, if
it is not found in 50 lines, the 50 lines are used for the block
and a warning is output. This catches the case where you forget
the endblock command. You can increase or decrease the value.

#+BEGIN_SRC
<!--$ block t.maxLines = 200 -->
#+END_SRC

[[#contents][茶]]

*** t.output
:PROPERTIES:
    :CUSTOM_ID: toutput
    :END:

The t.output variable determines where the block output goes.  By
default it goes to the result file.

- "result" -- to the result file (default)
- "stdout" -- to standard out
- "stderr" -- to standard error
- "log" -- to the log file
- "skip" -- to the bit bucket

[[#contents][茶]]

*** t.repeat
    :PROPERTIES:
    :CUSTOM_ID: trepeat
    :END:

The t.repeat variable is an integer that tells how many times to
show the command’s replacement block.  A value of 0 means don't
show the block at all. If you don't set it, the block repeats one
time.

Each time the block repeats the local variables get cleared then
recalculated.

The t.row variable counts the number of times the block repeats
and is used to customize each block iteration.

The t.maxRepeat variable limits how many times the block can repeat.
You cannot assign a number bigger than t.maxRepeat to
t.repeat. You can set t.maxRepeat to anything you want, the
default is 100.

When you set t.repeat to 0, the command exits.  The commands'
statements following are not run. This makes a difference when
the command has side effects, like setting global variables. You
can move the "t.repeat = 0" line around to compensate.

For the following example, the number of items in teaList is
assigned to the t.repeat variable which outputs the block five
times.

template:

#+BEGIN_SRC
<!--$ nextline t.repeat = len(s.teaList) -->
<!--$ : tea = get(s.teaList, t.row) -->
 * {tea}
#+END_SRC

server json:

#+BEGIN_SRC
{
"teaList": [
  "Black",
  "Green",
  "Oolong",
  "Sencha",
  "Herbal"
]
}
#+END_SRC

result:

#+BEGIN_SRC
 * Black
 * Green
 * Oolong
 * Sencha
 * Herbal
#+END_SRC

The following example builds an html select list of tea companies
with the Twinings company selected and it shows how to access
values from dictionaries.

template:

#+BEGIN_SRC
<h3>Tea Companies</h3>
<select>
<!--$ block t.repeat=len(s.companyList) -->
<!--$ : d = s.companyList[t.row] -->
<!--$ : selected = get(d, "selected", false) -->
<!--$ : current = if(selected, " selected=\"selected\"", "") -->
  <option{current}>{d.company}</option>
<!--$ endblock -->
</select>
#+END_SRC

server json:

#+BEGIN_SRC
{
"companyList": [
  {"company": "Lipton"},
  {"company": "Tetley"},
  {"company": "Twinings", "selected": true},
  {"company": "American Tea Room"},
  {"company": "Argo Tea"},
  {"company": "Bigelow Tea Company"}
]
}
#+END_SRC

result:

#+BEGIN_SRC
<h3>Tea Companies</h3>
<select>
  <option>Lipton</option>
  <option>Tetley</option>
  <option selected="selected">Twinings</option>
  <option>American Tea Room</option>
  <option>Argo Tea</option>
  <option>Bigelow Tea Company</option>
</select>
#+END_SRC

Setting t.repeat to 0 is good for building test lists.

When you view the following template fragment in a browser it
shows one item in the list, "{tea}".

template:

#+BEGIN_SRC
<h3>Tea</h3>
<ul>
<!--$ nextline t.repeat = len(s.teaList)-->
<!--$ : tea = get(s.teaList, t.row) -->
  <li>{tea}</li>
</ul>
#+END_SRC

server json:

#+BEGIN_SRC
{
"teaList": [
  "Black",
  "Green",
  "Oolong",
  "Sencha",
  "Herbal"
]
}
#+END_SRC

To create a static page that has more products for better testing
you could create a test list of teas using t.repeat of 0. It will
appear when testing but not when generating the final result. In
the following example the test list will show: {tea}, Chamomile,
Chrysanthemum, White, and Puer.

template:

#+BEGIN_SRC
<h3>Tea</h3>
<ul>
<!--$ nextline t.repeat = len(s.teaList) -->
<!--$ : tea = get(s.teaList, t.row) -->
  <li>{tea}</li>
<!--$ block t.repeat = 0 -->
  <li>Chamomile</li>
  <li>Chrysanthemum</li>
  <li>White</li>
  <li>Puer</li>
<!--$ endblock -->
</ul>
#+END_SRC

result:

#+BEGIN_SRC
<h3>Tea</h3>
<ul>
  <li>Black</li>
  <li>Green</li>
  <li>Oolong</li>
  <li>Sencha</li>
  <li>Herbal</li>
</ul>
#+END_SRC

[[#contents][茶]]

*** t.row
:PROPERTIES:
    :CUSTOM_ID: trow
    :END:

The t.row read-only variable counts the number of times the
replacement block repeats.

You use it to format lists and other repeating content in the
template.

Here is an example using the row variable.  In the example, row
is used in three places.

template:

#+BEGIN_SRC
<ul>
<!--$ nextline t.repeat=len(s.companies)-->
<!--$ : company = s.companies[t.row] -->
<!--$ : num = add(t.row, 1) -->
  <li id="r{t.row}">{num}. {company}</li>
</ul>
#+END_SRC

server json:

#+BEGIN_SRC
{
  "companies": [
    "Mighty Leaf Tea",
    "Numi Organic Tea",
    "Peet's Coffee & Tea",
    "Red Diamond"
  ]
}
#+END_SRC

result:

#+BEGIN_SRC
<ul>
  <li id="r0">1. Mighty Leaf Tea</li>
  <li id="r1">2. Numi Organic Tea</li>
  <li id="r2">3. Peet's Coffee & Tea</li>
  <li id="r3">4. Red Diamond</li>
</ul>
#+END_SRC

[[#contents][茶]]

*** t.version
:PROPERTIES:
:CUSTOM_ID: tversion
:END:

The read-only t.version variable contains the current version
number of StaticTea. See the [[#cmpversion][cmpVersion]] function for more
information.

[[#contents][茶]]

* Types
:PROPERTIES:
:CUSTOM_ID: types
:END:

StaticTea variable types:

- [[#string-type][String]]
- [[#int-type][Int]]
- [[#float-type][Float]]
- [[#dict-type][Dict]]
- [[#list-type][List]]
- [[#bool-type][Bool]]
- [[#func-type][Func]]

[[#contents][茶]]

** String Type
:PROPERTIES:
:CUSTOM_ID: string-type
:END:

A string is an immutable sequence of unicode characters.

You define a single line literal string with double quotes and a
[[#multiline-strings][multiline string]] in code files with triple quotes.

The example below defines a literal string and assigns it to the
variable str:

#+BEGIN_SRC
str = "black teas vs. green teas"
#+END_SRC

Strings are encoded as UTF-8 and invalid byte sequences generate
a warning.

Strings follow the same escaping rules as json strings.  You can
escape eight special control characters using a slash followed by
a letter, otherwise slash is a normal character. Special escape
letters:

- " -- quotation mark (U+0022)
- \ -- reverse solidus (U+005C)
- / -- solidus (U+002F)
- b -- backspace (U+0008)
- f -- form feed (U+000C)
- n -- line feed (U+000A)
- r -- carriage return (U+000D)
- t -- tab (U+0009)

Examples with escaping:

- "ending newline\n"
- "tab \t in the middle"
- "Mad Hatter: \\\"... you must have a cup of tea!\\\" - 'Alice In Wonderland'."
- "Unicode tea character '茶' is '\u8336'"
- "smiley face 😀 by escaping: \uD83D\uDE00."

You can enter any unicode value with \u and four hex digits or, for
values greater the U-FFFF, two pairs.  The two pairs are
called surrogate pairs.

#+BEGIN_SRC
Unicode code point U-8336
is 茶, escaped: \u8336.

Unicode code point U-1F600
is 😀, escaped: \uD83D\uDE00.
#+END_SRC

You can generate the surrogate pair for a unicode code point
using Russell Cottrell's surrogate pair calculator:
[[http://russellcottrell.com/greek/utilities/SurrogatePairCalculator.htm][
Surrogate Pair Calculator]].

[[#contents][茶]]

** Int Type
:PROPERTIES:
:CUSTOM_ID: int-type
:END:

An int is a 64 bit signed integer.  Plus signs are not used
with numbers. You can use underscores in long number literals to
make them more readable.

Example numbers:

#+BEGIN_SRC
12345
0
-8823
42
1_234_567
#+END_SRC

[[#contents][茶]]

** Float Type
:PROPERTIES:
:CUSTOM_ID: float-type
:END:

A float is a 64 bit real number, it has a decimal point and
starts with a digit or minus sign. You can use underscores in
long number literals to make them more readable.

Example floats:

#+BEGIN_SRC
3.14159
24.95
0.123
-34.0
1_234.56
#+END_SRC

[[#contents][茶]]

** Dict Type
:PROPERTIES:
:CUSTOM_ID: dict-type
:END:

The dict type is an ordered key value store with fast lookup. It
maps a string key to a value which can be any type. The dict is
ordered by insertion order.

You create a dict using the dict function. The example below
creates an empty dict d and a dict d2 with 2 elements.

#+BEGIN_SRC
d = dict()
d2 = dict(["one", 1, "two", 2])
#+END_SRC

You can append to a dict using dot name notation:

#+BEGIN_SRC nim
d = dict()
d.a = 5
d.tea = "Eary Grey"
#+END_SRC

You can append to a dict using bracket notation on the left hand
side of the equal sign and this way allows you to use a variable
for the key:

#+BEGIN_SRC nim
d = dict()
d["a"] = 5
var = "tea"
d[var] = "Eary Grey"
#+END_SRC

You append to the l dict when you create a new variable without a
prefix.

#+BEGIN_SRC nim
a = 5
tea = "Eary Grey"
#+END_SRC

You access a dict element with a dot name, bracket notation or
with the get function. If the key is an invalid variable name,
you cannot access it using dot notation.

The get function has an optional default parameter that's used
when the key doesn't exist (the z case below).

#+BEGIN_SRC nim
d = dict(["x", 100, "y", 200])
x = get(d, "x") # 100
y = get(d, "y") # 200
z = get(d, "z", 300) # 300
#+END_SRC

The server json data becomes the s dictionary. For the example
below s contains three top level elements, a, b and d. A and b
are integers and d is a dictionary with elements x and y.

server json:

#+BEGIN_SRC
{
  "a": 1,
  "b": 2,
  "d": {
    "x": 100,
    "y": 200
  }
}
#+END_SRC

[[#contents][茶]]

** List Type
:PROPERTIES:
:CUSTOM_ID: list-type
:END:

A list contains a sequence of values of any type.

You can create a list with the list function or with brackets:

#+BEGIN_SRC nim
a = list()
a = list(1)
a = list(1, 2, 3)
a = list("a", 5, "b")

a = []
a = [1]
a = [1, 2, 3]
a = ["a", 5, "b"]
#+END_SRC

You can append to a list by assigning a value to a variable with
the &= operator.  It will create the list if it doesn't exist. In
the example below, the first line creates the list variable then
assign "black" to it.  The second line appends "green":

#+BEGIN_SRC
teas &= "black"
teas &= "green"
teas => ["black", "green"]
#+END_SRC

The next example creates a g.names list from names contained in a
list of dictionaries:

#+BEGIN_SRC
$$ block
$$ : t.repeat = len(s.entries)
$$ : entry = s.entries[t.row]
$$ : g.names &= entry.name
$$ endblock
#+END_SRC

You can access list elements with the get function or bracket notation:

#+BEGIN_SRC nim
list = list(1, 3.3, "a")
get(list, 0) # 1
get(list, 1) # 3.3
get(list, 2) # "a"
get(list, 3, 99) # 99
get(list, -1) # "a"
get(list, -2) # 3.3
get(list, -3) # 1
get(list, -4, 99) # 99

list[0] # 1
list[1] # 3.3
list[2] # "a"
list[-1] # "a"
list[-2] # 3.3
list[-3] # 1
#+END_SRC

[[#contents][茶]]

** Bool Type
:PROPERTIES:
:CUSTOM_ID: bool-type
:END:

A bool is a true or false value. You typically use the boolean
type with IF statements and [[#boolean-expression][Boolean Expression]]s.

You can create a bool value using true or false or with the bool
function.

#+BEGIN_SRC nim
a = true
b = false
c = bool(0) # false
d = bool(1) # true (not 0)
#+END_SRC

[[#contents][茶]]

** Func Type
:PROPERTIES:
:CUSTOM_ID: func-type
:END:

A func variable refers to a function. You use it to call the
function, to get information about it, and to pass it around.

You create a func variable from an existing func variable or by
defining a new function with the special "func" function, see
[[#user-functions][User Functions]].

All the built-in functions exist in the f dictionary by
name. Each dictionary value is a list of func values with the
same name. There are three cmp functions so the f dictionary
value for it is a list of three function variables:

#+BEGIN_SRC nim
f.cmp => ["cmp","cmp","cmp"]
#+END_SRC

You can call a list of func variables. The function called is
determined by the parameters passed, the one with the matching
signature is called. All the built-in functions are lists
containing one or more items. Below is an example calling a
function given a list:

#+BEGIN_SRC nim
value = f.cmp(1,2)
#+END_SRC

You can call a func variable directly. In the following example
the "a" func variable is defined to be equal to the second
built-in cmp function.

#+BEGIN_SRC nim
l.a = f.cmp[1]
#+END_SRC

You call it with parentheses:

#+BEGIN_SRC nim
b = l.a(4, 7) #-1
#+END_SRC

You can have multiple functions with the same name as long as
their signatures differ.

When you call a function variable without a prefix, statictea
looks for it in the function dictionary.

When none of the signatures match the first argument, you see a
message about that, for example:

#+BEGIN_SRC
shared.tea(1): w207: None of the 3 functions matched the first argument.
statement: o.a = cmp(l, f)
                     ^
#+END_SRC

When the first argument matches one of the signatures, that
signature determines the message you see when one of the other
arguments do not match. For example:

#+BEGIN_SRC
o.b = cmp(1, 4.5)
shared.tea(2): w120: Wrong argument type, expected int.
statement: o.b = cmp(1, 4.5)
                        ^
o.c = cmp(1.9, 5)
shared.tea(2): w120: Wrong argument type, expected float.
statement: o.b = cmp(1.9, 5)
                          ^
#+END_SRC

You can call functionDetails to get the signature, doc comment,
statements etc. of a user or built-in function.

[[#contents][茶]]

* Boolean Expression
:PROPERTIES:
:CUSTOM_ID: boolean-expression
:END:

You use a boolean expression with an IF statement to make a
decision that controls code flow.

A boolean expression is an infix expression wrapped with
parentheses containing logical and compare operators that returns
a true or false value.

In the following example the (3 == 4) is an expression and the e
variable is assigned false because 3 does not equal 4.

#+BEGIN_SRC nim
e = (3 == 4) # false
#+END_SRC

You can write boolean expressions with the following operators:

- and
- or
- ==
- !=
- <
- >
- <=
- >=

You typically use a boolean expression with an IF statement. In
the next example v is set to "s" because 3 is less than 5.

#+BEGIN_SRC nim
v = if((3 < 5), "s", "l") # "s"
#+END_SRC

Note: a conditional is wrapped in parentheses and there is no
name on the left, so the following statement is invalid:

#+BEGIN_SRC
v = if(3 < 5, "s", "l")
       ^ invalid syntax
#+END_SRC

The comparisons have the highest precedence, then the logical
"and" and "or".  Highest precedence to lowest:

- <, >, ==, !=, <=, >=
- and, or

You can control precedence with parentheses. The following two
expressions are equivalent:

#+BEGIN_SRC
(a < b and c > d) =>
( (a < b) and ( c > d) )
#+END_SRC

You can use multiple and’s or or’s in an expression.  For example:

#+BEGIN_SRC
(a < b and c > d and e == f)
(a < b or c > d or e == f)
#+END_SRC

If you mix ANDs and ORs, you need to specify the precedence
with parentheses. For example:

#+BEGIN_SRC
( (a < b or c > d) and e == f)
#+END_SRC

The arguments are processed left to right and it uses short
circuit evaluation. OR returns true on the first true argument
and AND returns false on the first false argument and the rest
are skipped.

AND and OR work with bool arguments. The comparisons work with
numbers and strings.

NOT is not a logical operator but it is a function.  You can
pass a logical expression to it to invert it.  Here are a couple
of examples:

#+BEGIN_SRC nim
x = not( (a < b and c > d) )
y = (a < b and not((c > d)))
#+END_SRC

Note: If you need case insensitive string compare, use the cmp
function.

[[#contents][茶]]

* Code Files
:PROPERTIES:
:CUSTOM_ID: code-files
:END:

A code file is a list of statements.  You use a code file for
defining variables for templates.

The template designer controls the code files.

Here is an example of a code file that defines two variables, pi
and footer.

#+BEGIN_SRC nim
o.pi = 3.14159
o.footer = "</html>"
#+END_SRC

There are no prefix, postfix and other line decorations that you
use in templates so the code is easier to read and write.  It is
suggested that you add most of your code in code files to
minimize the amount in the template.

Below is an example of defining a multiline string header in a
code file for sharing with templates. The code populates the o
dictionary that is available to the template commands.

#+BEGIN_SRC nim
o.header = """
<!doctype html>
<html lang="en">
"""
#+END_SRC

You use the header in a template’s replace command

#+BEGIN_SRC
$$ replace t.content = o.header
#+END_SRC

See the [[#multiline-strings][Multiline Strings]], [[#replace-command][Replace Command]] and [[#user-functions][User Functions]]
sections for more information.

You import a code file from the command line with the -o or –code
option. You can use multiple -o files and they run in the order
specified.

The code files run after importing the JSON files so they have
access to the server variables.

You can use the local variables for intermediate values but they
disappear when the code file finishes running.  For example the
"a" variable is local:

#+BEGIN_SRC nim
a = 5
o.x = a + 6
#+END_SRC

You can use the listLoop function to loop over a list and build lists
and dictionaries. It’s the looping method you use in code files.

Processing continues after a warning except for a problem reading
a multi-line string or a problem with line continuation which
stops processing the code file.

Like template commands, the maximum line length is 1024 bytes and
an ending plus sign continues a long statement on the next line.

[[#contents][茶]]

* Multiline Strings
:PROPERTIES:
:CUSTOM_ID: multiline-strings
:END:

Code files support multiline strings which are triple quoted
UTF-8 encode strings.

They are useful for sharing template fragments without escaping
characters. In the following example the header variable is
assigned a two line string containing quotes and newlines.

#+BEGIN_SRC nim
o.header = """
<!doctype html>
<html lang="en">
"""
#+END_SRC

Both the leading and ending triple quotes end the line. Nothing
follows the quotes except the lf or crlf. The following example
is invalid because the leading triple quote does not end the
line:

#+BEGIN_SRC
msg = """not valid"""
         ^ syntax error
#+END_SRC

The next couple of examples compare multiline strings with normal
strings.

#+BEGIN_SRC nim
str = """
All the tea in China.
"""
#+END_SRC

is equivalent to:

#+BEGIN_SRC nim
str = "All the tea in China.\n"
#+END_SRC

The multiline string:

#+BEGIN_SRC nim
str = """
All the tea in China."""
#+END_SRC

is equivalent to:

#+BEGIN_SRC nim
str = "All the tea in China."
#+END_SRC

The advantage of a multiline string over a regular string is no
quoting of the newline and other special characters.  For example
you can copy and paste HTML directly into the code file then mark
variables in it:

#+BEGIN_SRC nim
o.header = """
<!DOCTYPE html>
<html lang="{s.languageCode}"
dir="{s.languageDirection}">
<head>
<meta charset="UTF-8"/>
<title>{s.title}</title>
"""
#+END_SRC

A multiline string can contain triple quotes as long as they
don't end the line.

#+BEGIN_SRC
str = """
This is a """triple quoted""" string.
"""
#+END_SRC

A multiline string literal cannot be an argument to a
function. The workaround is to assign it to a local variable and
pass that to the function.

#+BEGIN_SRC nim
str = """
Teas of China
"""
count = len(str)
#+END_SRC

[[#contents][茶]]

* User Functions
:PROPERTIES:
:CUSTOM_ID: user-functions
:END:

You can define your own functions in code files.

User defined functions are important for sharing common code, as
conditional code blocks, looping (listLoop) and as callbacks for
building lists and dictionaries.

In the following example we define a function called u.mycmp and
assign the result to the u.mycmp function variable. The function
takes two string parameters called numStr1 and numStr2 and it
returns an integer.

#+BEGIN_SRC nim
u.mycmp = func(numStr1: string, numStr2: string) int
  ## Compare two number strings
  ## and return 1, 0, or -1.
  num1 = int(numStr1)
  num2 = int(numStr2)
  return(cmp(num1, num2))
#+END_SRC

The first line names the function and defines its signature and
assigns it to a variable. The function variable is stored in the
u dictionary so it is visible inside other functions.

#+BEGIN_SRC nim
u.mycmp = func(numStr1: string, numStr2: string) int
#+END_SRC

The doc comment comes next and tells what the function does:

#+BEGIN_SRC nim
  ## Compare two number strings
  ## and return 1, 0, or -1.
#+END_SRC

The last lines of the definition are the statement lines. A bare
return statement ends the function definition.

#+BEGIN_SRC nim
  num1 = int(numStr1)
  num2 = int(numStr2)
  return(cmp(num1, num2))
#+END_SRC

The code is line based so the indentation doesn’t matter, there
aren’t any brackets, and no line terminators.

Here is how you call the example function:

#+BEGIN_SRC nim
a = u.mycmp("1", "2")
#+END_SRC

*Function Signature:*

A function signature tells the function name, the parameter names
and types and the return type. For the example above the
signature string is:

#+BEGIN_SRC nim
u.mycmp = func(numStr1: string, numStr2: string) int
#+END_SRC

You can specify an optional last parameter and a parameter can
use "any" when it accepts any type. The built-in get function
is an example of optional and any.

#+BEGIN_SRC nim
get = func(dictionary: dict, key: string, default: optional any) any
#+END_SRC

*Return Statement:*

You use the return statement to return the function’s value and
to finish the definition of the function. A bare return ends the
function; you can use a return in a IF statement and they don’t end
the function.

*Function Local Variables:*

The function‘s local variables and its arguments are stored in
the function’s own l dictionary which exists while the function
runs and is separate from the tea code local variables.

It contains the parameters and their argument values and local
variables used in the function. The example below prints the l
dictionary

#+BEGIN_SRC
u.get6 = func(msg: string) int
  ## Return 6.
  a = 3
  echo(string(l, "dn", "l"))
  return(6)

# output:
l.msg = "hi"
l.a = 3
#+END_SRC

You have access to f and u dictionaries inside the function. To
access other external variables, you need to pass them in.

[[#contents][茶]]

* Run StaticTea
:PROPERTIES:
:CUSTOM_ID: run-statictea
:END:

You run StaticTea from the command line. You specify the template
file to process along with the json data files and code files and
a result file is generated.

- Warning messages go to standard error.
- If you don't specify the result file, the result goes to standard out.
- If you specify "stdin" for the template, the template comes
  from stdin.
- StaticTea returns success, return code 0, when there are no
  warning messages, else it returns 1.

The example below shows a typical invocation which specifies four
file arguments, the server json, the shared code file, the template
and the result.

#+BEGIN_SRC
statictea \
  --server server.json \
  --code shared.tea \
  --template template.html \
  --result result.html
#+END_SRC

The StaticTea command line options:

- help -- show options and usage help then quit
- version -- show the version number then quit
- server -- a server json file  You can specify multiple server
  files, see [[#server-json-variables][Server Json Variables]].
- code -- a shared code file. You can specify multiple shared
  options, see [[#code-files][Code Files]].
- template -- the template file, or "stdin" for input from
  standard input.
- result -- the result file. When not specified, standard out is
  used.
- update -- update the template replace blocks. See the
  [[#update-option][Update Option]].
- prepost -- a command prefix and postfix. You can specify
  multiple prepost options. When you specify a value, the
  defaults are no longer used. See the [[#prefix-postfix][Prefix
  Postfix]] section.
- log - log to a file, see [[#logging][Logging]] section


[[#contents][茶]]

* How To
:PROPERTIES:
:CUSTOM_ID: how-to
:END:

Follow these guidelines when creating a new template.  Open and
test the template after each step in the process. For example an
HTML file you would open it in a browser and validate it.

1. Create a sample result file. For HTML create an HTML
   file. This will become your template.

2. Identify the variable and repeating parts of the file. Put a
   command around each as a comment for your template type. This
   defines the replacement blocks.

3. Inside the replacement blocks replace the variables with
   variable names in brackets, e.g. {name}.

4. Create a test JSON file containing the variables defined in
   step 3. Create a list of dictionaries for repeating blocks.

5. For repeating replacement blocks set t.repeat to the repeat
   count (the length of its JSON list).

6. Run statictea combining the JSON file and the template to make
   a result file. Then edit the JSON or the template and repeat,
   perfecting the template.

In a project with many templates, you can share common template
fragments using the replace command.

If you don’t have control over the JSON, create a tea code file
and write code converting the JSON to variables you want in the
template.

[[#contents][茶]]

* Miscellaneous
:PROPERTIES:
:CUSTOM_ID: miscellaneous
:END:

- [[#warning-messages][Warning Messages]]
- [[#prefix-postfix][Prefix Postfix]]
- [[#encoding-and-line-endings][Encoding and Line Endings]]
- [[#update-option][Update Option]]
- [[#logging][Logging]]
- [[#special-forms][Special Forms]]
- [[#if-function][IF Function]]
- [[#docs-and-templates][Docs and Templates]]
- [[#html-formatted-json][HTML Formatted Json]]
- [[#nimble-tasks][Nimble Tasks]]
- [[#stf-runner][Stf Runner]]
- [[#repl-environment][REPL Environment]]
- [[#docker-development][Docker Development]]
- [[#mac-development][Mac Development]]

[[#contents][茶]]

** Warning Messages
:PROPERTIES:
   :CUSTOM_ID: warning-messages
   :END:

When StaticTea detects a problem, a warning message is written to
standard error, the problem statement is skipped, and processing
continues.

It’s good style to change your template to be free of messages.

Each warning message shows the file and line number where the
problem happened.

example messages:

- tea.html(0): w15: "Unable to parse the json file. Skipping file: test.json.
- tea.html(45): w61: No space after the command.

Statement errors generate multi-line messages showing the
statement and problem location, for example:

#+BEGIN_SRC
template.html(16): w33: Expected a string, number, variable, list or condition.
statement: tea = len("abc",)
                           ^
#+END_SRC

Warnings are suppressed after the first 32. When you reach the
limit you will see the message:

#+BEGIN_SRC
You reached the maximum number of warnings, suppressing the rest.
#+END_SRC

Statictea returns success, return code 0, when there are no
warning messages, else it returns 1. If you want to treat
warnings as errors, check for the 1 return code.


You can generate your own warnings messsage using the warn
function. Like the system warning messages it skips the current
statement, increments the warning count and produces a non-zero
return code.

For example if the server item list should contain one or more
items, you could output a warning when it's empty:

#+BEGIN_SRC nim
if((len(s.items) == 0), warn("no items"))
#+END_SRC

[[#contents][茶]]

** Prefix Postfix
:PROPERTIES:
   :CUSTOM_ID: prefix-postfix
   :END:

The prefix and postfix are the leading and ending comment
characters your template uses.  For html they are "<!–" and "–>".

You tell statictea what they are then you use them in the
template so all the statictea commands are comments.

This allows you to edit the template using its native editors and
run other native tools. For html, you can view it in a browser,
edit with an html editor and validate it online with w3.org’s
validator.

Comment syntax varies depending on the type of template file and
sometimes depending on the location within the file. StaticTea
supports several varieties and you can specify others.

You want to distinguish StaticTea commands from the file’s normal
comments so it is clear which comments are which. Normal comments
appear in the result and StaticTea comments don’t.  The
convention is to add a $ as the last character of the prefix.

#+BEGIN_SRC
<!- normal html comment ->
<!-$ # statictea comment ->
#+END_SRC

Some file types, like markdown, don't support comments, for
them use $$.

Built-in Prefixes:

- markdown: $$
- html: <!--$ and -->
- html inside a textarea: &lt;!--$ and --&gt;
- bash: #$
- config files: ;$
- C++: //$
- org mode: # $
- C language: ​/\star$ and \star​/

You can define other comment types on the command line using the
prepost option one or more times. When you specify your own
prepost values, the defaults no longer exist so you have control
of which prefixes get used.

You specify the prepost option with the prefix separated from the
postfix with a comma and the postfix is optional,
'prefix[,postfix]'. A prefix and postfix contain 1 to 20 ASCII
characters including spaces but without control characters or
commas.

Note: It's recommended that you use single quotes so the command
line doesn't interpret $ as an environment variable.

examples:

#+BEGIN_SRC
--prepost 'pre$,post'
--prepost 'a$,b'
--prepost '@$,|'
--prepost '#[$,]#'
--prepost '# $'
#+END_SRC

[[#contents][茶]]

** Encoding and Line Endings
:PROPERTIES:
:CUSTOM_ID: encoding-and-line-endings
:END:

Templates are treated as a stream of bytes. The embedded
statictea commands only use ASCII except for quoted strings which
are UTF-8 encoded.

Two line endings are supported on all platforms: LF, and CR/LF
and they are preserved.

The maximum command line length is 1024 bytes. There is
no limit on non-command lines.

Since line endings are preserved and there are no encoding or
line length restrictions on non-command lines, you can make
templates out of binary or mixed binary and text files like EPS
or PDF files.

[[#contents][茶]]

** Update Option
:PROPERTIES:
:CUSTOM_ID: update-option
:END:

The update option updates the template's replace blocks to
match their t.content text.  The text normally comes from the
shared code files but it doesn't have to.

You use this to keep the template blocks in sync with the shared
content so you can work with them as static pages.

If the t.content does not end with a newline, one is added so the
endcommand starts on a new line.

The following example shows a typical invocation:

#+BEGIN_SRC
statictea \
  --server server.json \
  --code shared.tea \
  --template template.html \
  --update
#+END_SRC

If the template content comes from the standard input stream the
result goes to the standard output stream.

See the [[#replace-command][replace command]] for update examples.

[[#contents][茶]]

** Logging
:PROPERTIES:
   :CUSTOM_ID: logging
   :END:

Statictea appends statistics to the log file.  Template commands
can also append to the log file.

Logging is off by default. You turn it on with the log option.
If you don't specify a filename, the log lines are written to the
platform default location:

- Mac: ~/Library/Logs/statictea.log
- Other: ~/statictea.log

You can specify a full path. If you don't include path
information, the log is written to the current directory.

#+BEGIN_SRC
statictea --log mylog.txt
#+END_SRC

The template file and line number appear in the log.  For
example:

#+BEGIN_SRC
2021-12-07 22:03:59.908; statictea.nim(42); Starting: argv: @["-l log.txt", "-t tmpl.txt", "-r result.txt"]
2021-12-07 22:03:59.908; statictea.nim(43); Version: 0.1.0
2021-12-07 22:03:59.909; tmpl.txt(2); ┌─────────┐
2021-12-07 22:03:59.909; tmpl.txt(3); │log block│
2021-12-07 22:03:59.909; tmpl.txt(4); └─────────┘
2021-12-07 22:03:59.910; statictea.nim(66); Warnings: 0
2021-12-07 22:03:59.910; statictea.nim(69); Return code: 0
2021-12-07 22:03:59.910; statictea.nim(70); Done
#+END_SRC

[[#contents][茶]]

** Special Forms
:PROPERTIES:
   :CUSTOM_ID: special-forms
   :END:

The normal way functions behave when you call them is known as
the normal form. A few functions deviate in one or more ways from
the normal form and these are known as special forms.

The normal form you call with parentheses and pass a fixed number
of arguments which get evaluated before hand. The function
returns a value and there are no side effects.

A normal statement has a left side, an operator, and a right hand
side, for example:

#+BEGIN_SRC nim
a = len("tea")
#+END_SRC

Below are the list of special functions and how they deviate from
the normal form:

- case — conditionally evaluates its arguments
- echo — writes a message to standard out and has a bare form
- func - defines a function, see [[#user-functions][User Functions]]
- if - conditionally evaluates its arguments and it has a bare form, see [[#if-function][IF Function]]
- list - takes any number of arguments
- listLoop — has a bare form
- log - writes a message to the log file and has a bare form
- return - exits the command block or function with a return
  value and has a bare form
- warn — exits the statement with a warning and has a bare form

If the form doesn't have an assignment it's called a bare
function. The echo, warn, return, if, listLoop and log have bare forms.

Special Form Examples:

#+BEGIN_SRC nim
v = list(1,2,3,4,5,6,7)
v = if(b, 5, 6)
if(c, warn("abc"))
if(c, return("abc"))
newList &= if( (x > 5), value)
warn("the tea is hot")
echo("the tea is delicious")
return(1)
log("log message")
a = case(22, [11, 1, 22, 2])
#+END_SRC

[[#contents][茶]]

** IF Function
:PROPERTIES:
   :CUSTOM_ID: if-function
   :END:

The IF function is special in a few ways. It conditionally
evaluates its arguments and it can be used in a statement
without an assignment.

There are three basic forms, a three parameter form, a two
parameter form and a bare two parameter form. Here are examples:

#+BEGIN_SRC nim
tea = if(cond, "black", "green")
newList &= if(cond, value)
if(cond, return("stop"))
#+END_SRC

*Three Parameter Form*

Normally functions evaluate all their arguments before passing
them to the function but the three parameter IF evaluates its
condition argument first to determine which argument to evaluate
next and the non-matching argument is skipped.

In the following example do-this is executed and do-other is
skipped.

#+BEGIN_SRC
a = if(true, do-this(), do-other())
#+END_SRC

*Two Parameter Form*

The two parameter form assigns the variable when the condition is
true but not when it’s false. You use it to conditionally append
to a list or dictionary. You cannot use this form as an argument
to another function.

#+BEGIN_SRC nim 
newList &= if(cond, value)
d.tea = if(cond, value)
#+END_SRC

*Bare Two Parameter Form*

The bare two parameter form doesn’t have an assignment. You use
it with the echo, warn and return functions for their side
effects.

#+BEGIN_SRC nim
if(c, return("stop"))
if(c, warn("buy more tea!"))
#+END_SRC

[[#contents][茶]]

** Docs and Templates
:PROPERTIES:
   :CUSTOM_ID: docs-and-templates
   :END:

All the documents for this project, except this readme, were
created with Statictea templates. The resulting documents are
useful as documentation as well as examples for building your own
templates. They also the serve as test cases.

Below we show the resulting documents and their associated
templates and we tell which nimble task builds it.

*Nim Source Docs*

Statictea is written in the Nim language.  The documentation for
the functions and types exists in the source code as nim doc
comments.  The nim compiler provides a command to export these
doc comments to a JSON file.  The template uses the JSON to
produce the resulting documentation in markdown format.

The markdown format was choosen so the source and documentation
can reside in the same github repository. Github renders markdown
(unlike HTML) without having to create a separate github.io repo.

The index was created with one template and the module docs with
another. The nimble *docmix* task builds the module index and the
*docm* task builds one or more modules docs. For more details see
the [[#html-formatted-json][HTML Formatted Json]] section.

For easier reading of the markdown templates, click the link then
switch to "View Raw".

- [[docs/md/index.md][Source Code]]
- [[templates/nimModuleIndex.md][nimModuleIndex.md]] (view raw)
- [[templates/nimModule.md][nimModule.md]] (view raw)
- [[templates/nimModule.tea][nimModule.tea]]

*HTML Docs*

A second set of nim source documents exist for HTML. They are
designed for viewing locally on your machine and for testing. The
HTML templates share the same tea code files with the markdown
templates. The nimble *dochix* task builds the module index and
the *doch* task builds one or more HTML modules docs.

- Open docs/html/index.html in your browser.
- [[templates/nimModuleIndex2.html][nimModuleIndex2.html]] HTML template
- [[templates/nimModule2.html][nimModule2.html]] HTML template
- [[templates/nimModule.tea][nimModule.tea]]

*Functions*

The Statictea language functions doc was created from
statictea's embedded docs by looping over the f dictionary and
fetching each function's docComment. The nimble *funcdocs* task
builds the template.

- [[docs/md/teaFunctions.md][Functions]]
- [[templates/teaFunctions.md][teaFunctions.md]] (view raw)
- [[templates/teaFunctions.tea][teaFunctions.tea]]

*Built-in Docs*

Statictea function documentation is built in to the program. The
documentation is extracted from the nim functions.nim module
which is the "source of truth".

The nimble *dyfuncs* task extracts the docs and creates the nim
source file dynamicFunctions.nim which gets complied into statictea.

Since the function documentation is built in you can display it using
the ph REPL command, see [[#repl-environment][REPL Environment]].

- [[src/dynamicFuncList.nim][src/dynamicFuncList.nim]]
- [[templates/dynamicFuncList.nim][dynamicFuncList.nim]]
- [[templates/dynamicFuncList.tea][dynamicFuncList.tea]]

*Stf Tests*

The stf files used to test statictea exist in the testfiles
folder. Each stf file is a test file that's also a markdown
file. The nimble *stfix* task extracts a sentence from the top of
each stf file and makes an index from that with a template.

- [[testfiles/stf-index.md][StaticTea Stf Files]]
- [[templates/stf-index.md][stf-index.md]] (view raw)

*Highlighted Tea Code*

You can view the tea code files found in the templates folder
syntax highlighted.  The nimble *tea2html* task runs a statictea
template that creates colorful HTML files. They are designed for
viewing locally on your machine and for testing the syntax
highlighter.

- [[templates/tea2html.html][tea2html.html]] -- HTML template
- [[templates/tea2html.tea][tea2html.tea]] -- tea code file for the template

*Dev Index*

The dev.html file in the root folder is a master index to the svg
files and to all the markdown and html documents. It’s handy for
developers with the source code for debugging the docs.

[[#contents][茶]]

** HTML Formatted Json
:PROPERTIES:
   :CUSTOM_ID: html-formatted-json
   :END:

The nim jsondoc command produces html formatted descriptions.
Our desired final format is Github markdown so having html
presentation data in the json is a problem.

The jsondocraw command produces a JSON file like jsondoc, except
the descriptions match the text in the source file. Jsondocraw
calls nim's jsondoc command then patches the descriptions.

The nimble *jsondoc* command creates the jsondocraw exe.

[[#contents][茶]]

** Nimble Tasks
:PROPERTIES:
   :CUSTOM_ID: nimble-tasks
   :END:

You can run commands to build, test, make docs etc. using nimble
task commands. Run them from the statictea root folder. The n
task lists the available tasks.

#+BEGIN_SRC
cd ~/code/statictea
nimble n
#+END_SRC

# Build the list below with these commands:
# n n | gsed 's/ [ \t]*/@/' | gawk -F@ '{printf "- *%s*:  %s\n", $1, $2}'

Nimble Tasks:

- *n*:  Show available tasks.
- *test*:  Run one or more tests; specify part of the name.
- *other*:  Run stf tests, build release exe and other tests.
- *docsall*:  Create all the docs.
- *release*:  Run tests and update docs; test, other, docsall.
- *b*:  Build the statictea release exe (bin/x/statictea).
- *docm*:  Create one or more markdown docs; specify part of the name.
- *doch*:  Create one or more html docs; specify part of the name.
- *docmix*:  Create markdown docs index (docs/md/index.md).
- *dochix*:  Create html docs index (docs/html/index.html).
- *jsonix*:  Display docs index json.
- *json*:  Display a source file's json doc comments; specify part of the name.
- *teafuncs*:  Create the function docs (docs/md/teaFunctions.md).
- *dyfuncs*:  Create the built-in function details (src/dynamicFuncList.nim) from (src/functions.nim).
- *dotsrc*:  Create source module dependency graph (docs/staticteadep.svg).
- *dotsys*:  Create system modules dependency graph (docs/staticteadep2.svg).
- *tt*:  Compile and run t.nim.
- *tree*:  Show the project directory tree.
- *args*:  Show command line arguments.
- *br*:  Build the stf test runner (bin/x/runner).
- *rt*:  Run one or more stf tests in testfiles; specify part of the name.
- *stfix*:  Create stf test files index (testfiles/stf-index.md).
- *stfjson*:  Display stf test files index JSON.
- *newstf*:  Create new stf test skeleton, specify a name no ext.
- *runhelp*:  Show the runner help text with glow.
- *helpme*:  Show the statictea help text.
- *cmdline*:  Build cmdline test app (bin/x/cmdline).
- *jsondoc*:  Build jsondocraw app (bin/x/jsondocraw).
- *drun*:  Run a statictea debian docker build environment
- *ddelete*:  Delete the statictea docker image and container.
- *dlist*:  List the docker image and container.
- *clean*:  Remove all the binaries so everything gets built next time.
- *replace*:  Show pattern for text search and replace in all the nim source files.
- *tea2html*:  Create one or more html docs from the templates
  dir; specify part of the name.

[[#contents][茶]]

** Stf Runner
:PROPERTIES:
   :CUSTOM_ID: stf-runner
   :END:

The Single Test File (stf) runner is a standalone program in this
project used for testing command line applications.

A stf file defines the test which the runner executes to
determine whether the test passed. The stf file contains
instructions for creating files, running files and comparing
files.

The stf files are designed to look good in markdown readers.  The
testfiles folder contains [[testfiles/stf-index.md][StaticTea Stf Files]].

See the runner help message for more information about stf
files. The nimble *runhelp* task shows the stf help with glow.

[[#contents][茶]]

** REPL Environment
:PROPERTIES:
   :CUSTOM_ID: repl-environment
   :END:

You can run statictea code interactively at a prompt. You run
statements at the prompt and print variables with commands.

The -x option starts the Read Eval Print Loop (REPL) and tea is
the prompt.

#+BEGIN_SRC
statictea -x
tea>
#+END_SRC

The prompt appears after processing code files and importing json
files, so you can inspect values they create.

#+BEGIN_SRC
statictea -x -o codefile.tea -s in.json
tea>
#+END_SRC

In the following example the statement "z = 5" is entered then
z is printed. P is short for print.

#+BEGIN_SRC
statictea -x
tea> z = 5
tea> p z
5
#+END_SRC

You can use several commands for printing out values. The help
command (h) shows them.

#+BEGIN_SRC
tea> h
Enter statements or commands at the prompt.

Available commands:

  * h — this help text
  * p — print a variable like in a replacement block
  * pd — print a dictionary as dot names
  * pf - print function names, signatures or docs, e.g. f, f.cmp, f.cmp[0]
  * plc - print a list in columns
  * plv - print a list vertical, one element per line
  * v — print the number of variables in the one letter dictionaries
  * q — quit (ctrl-d too)
tea>
#+END_SRC

You can explore the built-in functions with the REPL commands. We
show some examples using the v and pf commands below.

You can view the number of variables in the one letter
dictionaries with the v command. In the following example the f
dictionary has 52 variables.

#+BEGIN_SRC
tea> v
f={52} g={} l={} o={} s={} t={3} u={}
#+END_SRC

You can list all the built-in function names with the pf command
specifying f as shown below.

#+BEGIN_SRC
tea> pf f
add         find             join      parseCode      startsWith
anchors     float            joinPath  parseMarkdown  string
bool        format           keys      path           sub
case        func             len       readJson       type
cmp         functionDetails  list      replace        values
cmpVersion  get              listLoop  replaceRe      warn
dict        html             log       return
dup         if               lower     slice
exists      int              not       sort
#+END_SRC

Each element in the f dictionary is a list of the function
variables with the same name.  You can print a list to see each
signature. For example there are three cmp functions:

#+BEGIN_SRC
tea> pf f.cmp
0:  cmp = func(a: float, b: float) int
1:  cmp = func(a: int, b: int) int
2:  cmp = func(a: string, b: string, c: optional bool) int
#+END_SRC

You can print the documentation of a built-in function with the
pf command by specifying the function variable:

#+BEGIN_SRC
tea> pf f.cmp[0]
Compare two floats. Returns -1 for less, 0 for equal and 1 for
greater than.

cmp = func(a: float, b: float) int

Examples:

cmp(7.8, 9.1) # -1
cmp(8.4, 8.4) # 0
cmp(9.3, 2.2) # 1
#+END_SRC

[[#contents][茶]]

** Docker Development
:PROPERTIES:
:CUSTOM_ID: docker-development
:ORDERED:  t
:END:

You can use the statictea docker image as a development
environment.  It is a Debian system configured with the nim
compiler and other applications needed to build and test.

The statictea host source folder is shared with the docker
container, so you can use your own editor and applications on the
host as well.

Steps:

1. download code
2. start docker environment
3. build

*Download Code*

Download the statictea source code to a folder on your system in a terminal window:

#+BEGIN_SRC
mkdir ~/code/statictea
cd ~/code/statictea
git clone git@github.com:flenniken/statictea.git .
#+END_SRC

*Start Docker Environment*

You start the docker statictea environment with the nimble *drun*
command. The first time you run it, it builds the docker image
and stops so you can check for errors. You run it again to start
the env.

#+BEGIN_SRC
nimble drun
#+END_SRC

*Build*

You build the statictea executable in the environment using the
nimble *release* command.  It runs all the tests and builds the exe
and docs.

#+BEGIN_SRC
nimble release
#+END_SRC

[[#contents][茶]]

** Mac Development
:PROPERTIES:
:CUSTOM_ID: mac-development
:ORDERED:  t
:END:

Besides the docker environment, you can develop on a mac.

You setup for it is similar to the docker environment except you
need to install the needed apps to your mac manually. Once you’re
setup, you run the release command.

*Download Code*

Download the statictea source code to a folder on your system:

#+BEGIN_SRC
mkdir ~/code/statictea
cd ~/code/statictea
git clone git@github.com:flenniken/statictea.git .
#+END_SRC

*Download Nim*

Download nim following instructions on their website:
https://nim-lang.org/install.html.

*Install Helper Apps (optional)*

On the mac you install the helper applications using brew. They
help debugging issues.

- [[https://github.com/charmbracelet/glow/][glow]] —- for viewing markdown in your terminal
- [[https://github.com/stedolan/jq/][jq]] -— for viewing JSON
- [[https://github.com/joeyespo/grip][grip]] -— for viewing markdown in your browser
- [[https://formulae.brew.sh][tree]] —- for viewing the statictea directory structure
- [[https://graphviz.org][graphviz dot]] -— for creating dependency charts

Install using brew at the command line:

#+BEGIN_SRC
brew install glow
brew install jq
brew install grip
brew install tree
brew install graphviz
#+END_SRC

*Build*

Then you build the statictea executable using the nimble
*release* command.  It runs all the tests and builds the exe and
docs.

#+BEGIN_SRC
cd -/code/statictea
nimble release
#+END_SRC

[[#contents][茶]]

* Contents :notoc:
:PROPERTIES:
:CUSTOM_ID: contents
:END:

# You run the command below to make the table of contents. Copy
# to scratch to remove the leading pound signs.
# grep '^\* ' readme.org | grep -v ":notoc" | cut -c 3- | \
# awk '{a = $0; gsub(" ", "-", a); printf "- [[#%s][%s]]\n", tolower(a), $0 }'

- [[#advantages][Advantages]]
- [[#how-it-works][How it Works]]
- [[#commands][Commands]]
- [[#replacement-block][Replacement Block]]
- [[#statements][Statements]]
- [[#syntax][Syntax]]
- [[#variables][Variables]]
- [[#single-letter-dictionaries][Single Letter Dictionaries]]
- [[#types][Types]]
- [[#boolean-expression][Boolean Expression]]
- [[#code-files][Code Files]]
- [[#multiline-strings][Multiline Strings]]
- [[#user-functions][User Functions]]
- [[#run-statictea][Run StaticTea]]
- [[#how-to][How To]]
- [[#miscellaneous][Miscellaneous (+15)]]
- [[docs/md/teaFunctions.md][Functions]]

* Tea Info                                                            :notoc:

Tea plant: Camellia sinensis

Tea is the most popular manufactured drink consumed in the world,
equaling all others – including coffee, soft drinks, and alcohol
– combined. -- Wikipedia -- Macfarlane, Alan; Macfarlane, Iris
(2004). The Empire of Tea. The Overlook Press. p. 32. ISBN
978-1-58567-493-0.
