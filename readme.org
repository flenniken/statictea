* StaticTea

** A template processor and language.

StaticTea combines a template with data to produce a result.

Example template:

#+BEGIN_SRC
<!--$ nextline -->
hello {name}
#+END_SRC

The associated json data:

#+BEGIN_SRC
{"name": "world"}
#+END_SRC

The result:

#+BEGIN_SRC
hello world
#+END_SRC

** Basics

You specify each template command on one line. The command
applies to the current line, the next line or the next block of
lines called the replacement block.

You use variables in brackets to identify locations in the
replacement block for replacement. These variables typically get
replaced by their associated json value.

You can use two types of json files, a server json file and
shared json file.  The server json comes from the server and does
not contain any presentation markup. The shared json, maintained
by the template builder, contains shared presentation markup.

Since the template commands are encoded as comments, the template
file looks like a native file and you can view, edit, validate,
etc. the file with its normal tools. You develop templates as if
they were static pages.

** Commands

StaticTea commands:

- nextline -— make substitutions in the next line
- block —- make substitutions in the next block of lines
- endblock -- end of block
- replace -— replace block with a variable
- endreplace -- end of replace block
- # —- comment
- : -- continue line, used for continuation lines

example command lines:

#+BEGIN_SRC
<!--$ nextline -->
<!--$ block t.list = teaProducingCountries; tea="Darjeeling" -->
<!--$ replace t.content = header -->
<!--$ # this is a comment command -->
#+END_SRC

** Statements

A statement assigns a variable a value using the standard equal
sign. The varable being assigned is on the left hand side and on
the right hand side is either another variable or a function.
Here are examples of both:

#+BEGIN_SRC
var1 = var2
var3 = t.row
t.list = teaList
#+END_SRC

You define variables to use in the replacement block or you
assign system variables to control how the block behaves.

Statements go on the newline, block or replace command line. You
can use multiple statements separated with semicolons.

If you need more space, you can continue the line with the "\\"
character at the end.

Statements are executed from left to right. No statements are
allowed on the end commands.

*** Nextline Command

The nextline command tells the template system that the next line
in the file has variable content.

The content comes from text in the line and variables wrapped
with brackets.

In the following example there is some text and two variables, the
drink and drinkType variables.

template:

#+BEGIN_SRC
<!--$ nextline -->
Drink {drink} -- {drinkType} is my favorite.
#+END_SRC

json:

#+BEGIN_SRC
{
  "drink": "tea",
  "drinkType": "Earl Grey""
}
#+END_SRC

result:

#+BEGIN_SRC
Drink tea -- Earl Grey is my favorite.
#+END_SRC

*** Block Command

The block command targets multiple lines for replacement. The
block starts after the command and continues until the endblock
line is found. It behaves like the nextline command except with
multiple lines.

The content comes from text in the block and variables wrapped
with brackets.

In the following example the block has two lines. The block
contains three replacement variables, weekday, name and time.

template:

#+BEGIN_SRC
<!--$ block -->
Join our tea party on {weekday} at
{name}'s house at {time}.
<!--$ endblock -->
#+END_SRC

json:

#+BEGIN_SRC
{
  "weekday": "Friday",
  "name": "John",
  "time": "5:00 pm"
}
#+END_SRC

result:

#+BEGIN_SRC
Join our tea party on Friday at
John's house at 5:00 pm.
#+END_SRC

*** Replace Command

The replace command replaces the replacement block with a
variable's value. You set the block content by assigning the
t.content variable.

The lines in the block mirror the variable so you can
test the template as if it was a static file.

The command is useful for sharing common template lines between
templates and it has the special property that you can update the
replacement block to keep it in sync with the variable.

You can assign t.content the special "tempTesting" value and the
block content is used as is.  This is good for testing changes
you want to make to the shared value. The block is not updated in
this case, instead you get a warning.

The following example shares a common header between templates.

template:

#+BEGIN_SRC
<!--$ replace t.content=s.header -->
<!--$ endreplace -->
#+END_SRC

json:

#+BEGIN_SRC
{
  "header": "<!doctype html>\n<html lang="en">\n"
}
#+END_SRC

result:

#+BEGIN_SRC
<!doctype html>
<html lang="en">
#+END_SRC

The above example doesn’t work as a static template because the
template is missing the header lines.

You can fix this by adding the header lines inside the replace
block. The inside lines do not appear in the result, just the
data from the json variable.

template:

#+BEGIN_SRC
<!--$ replace t.content=s.header -->
<!doctype html>
<html lang="en">
<!--$ endreplace -—>
#+END_SRC

The template replacement block may get out of sync with the
variable.  You can update the replacement block to match the
variable with the update option.

The following example updates the mytea.html template's
replacement blocks to match their variables in the shared.json
file:

#+BEGIN_SRC
statictea --update --shared shared.json --template mytea.html
#+END_SRC

*** Comment Command

You can comment templates.  Comments are line based and use the #
character. They do not appear in the result.

template:

#+BEGIN_SRC
<!--$ # This is a comment. -->
<!--$ # How you make tea. -->
You make Oolong Tea in five time intensive steps.
#+END_SRC

result:

#+BEGIN_SRC
You make Oolong Tea in five time intensive steps.
#+END_SRC

*** Continue Command

You can continue a long command line with the "\\" character at
the end before the postfix. The line following is a continuation
command. The continuation command allows you to continue adding
statements as if it is one long line. You can continue the
continue command too, if you need more space.

The template's command line plus continuation lines length is
limited, see limits.

In the following example the nextline command continues on a
second line and third line.

template:

#+BEGIN_SRC
<!--$ nextline \-->
<!--$ : tea = 'Earl Grey' \-->
<!--$ : tea2 = 'Masala chai' -->
{tea}, {tea2}
#+END_SRC

result:

#+BEGIN_SRC
Earl Grey, Masala chai
#+END_SRC
** Types

StaticTea has several variable types:

- strings
- numbers
- variables
- functions

*** Strings

You define a string using single or double quotes. You use
strings in command statements. The literal strings you define
have a limited number of characters. See limits.

example strings:

- "this is a string"
- 'using single quote'
- "You can store black teas longer than green teas."

example usage:

#+BEGIN_SRC
<!--$ nextline message=t.if(admin, 'Earl Grey', 'Jasmine') -->
<h2>{message}</h2>
#+END_SRC

json:

#+BEGIN_SRC
{
  "admin": 1
}
#+END_SRC

result:

#+BEGIN_SRC
<h2>Earl Grey</h2>
#+END_SRC

*** Numbers

Numbers are 32 bit signed integers.

Example numbers:

#+BEGIN_SRC
12345
0
-8823
42
#+END_SRC

*** Variables

You use variables for block content and to control how a command
works.

You specify variables in json files or you create them in
template statements.

A json dictionary keys are the variable names and their value
becomes part of the template when they are used.

Internally two json namespaces exist, one for the shared json and
one for the server json.  You access the shared json with "s."
prefix the system variables with "t." and you access the server
variables with no prefix.

You can define new variables on the command line in
statements. These variables are local to the block and take
precedence over the json variables.

You can define any number of variables that will fit on the
line.

The variables are processed from left to right, so the last one
takes precedence when there are duplicates.

example variables:

#+BEGIN_SRC
t.row
serverVar
s.name
#+END_SRC

** Functions

A function returns a value.  You can assign the value to another
variable in a statement or you can use it in a replacement block.
There are a number of system functions.

The following example assigns the numberVars variable to the
number of variables in the t.server dictionary.  The t.version
function is used directly in the replacement block.

#+BEGIN_SRC
<!--$ nextline numberVars = t.len(t.server) -->
The server json contains {numberVars} variables.
Were running version {t.version} of StaticTea.
#+END_SRC

** System Variables and Functions

System variables and functions:

- t.case -- case function
- t.cmp -- spaceship compare function
- t.concat -- concatenate strings function
- t.content -- content of replace block
- t.else -- else condition of case function
- t.exists -- tells whether variables exists
- t.if -- if function
- t.len -- length of string function
- t.list -- where the block variables come from, may repeat
- t.maxLines -- maximum lines before block ends
- t.result -- where the block result goes
- t.row -- function returns the current row
- t.server -- the server json dictionary
- t.shared -- the shared json dictionary
- t.version -- function returns and verifies the version

*** t.case

The t.case function is a generalized if statement or case
statement. The first parameter's value determines which case is
returned. After the first you have pairs of parameters, the case
value, then the associated return value.

You need to specify a variable to return when none of the cases
match.  You do this with the t.else variable.

template:

#+BEGIN_SRC
<--$ nextline \-->
<--$ : abbr = t.case(tea, 'Darjeeling', "Darj", "Earl Gray", "EG", t.else, "unknown") \-->
The abbreviation for {tea} is {abbr}.
#+END_SRC

json:

#+BEGIN_SRC
{
  "tea": "Darjeeling"
}
#+END_SRC

result:

#+BEGIN_SRC
The abbreviation for Darjeeling is Darj.
#+END_SRC

The t.if statement is shorthand for the following t.case:

#+BEGIN_SRC
t.if(cond, v1, v2) is equivalent to: t.case(cond, 1, v1, t.else, v2)
#+END_SRC

*** t.cmp

The t.cmp function compares two numbers or two strings and
returns whether the first parameter is less than, equal to or
greater than the second parameter. It returns -1 for less, 0 for
equal and 1 for greater than. You get three compares for the
price of one!

The example does a greater than or equal compare.

template:

#+BEGIN_SRC
<!--$ nextline sold = t.cmp(earlgrey, oolong); \-->
<!--$ : bestSelling = t.case(sold, 1, earlgreyName, 0, earlgreyName, t.else, oolongName) -->
The best selling tea this week is {bestSelling}.
#+END_SRC

json:

#+BEGIN_SRC
{
  earlgrey: 500,
  oolong: 300,
  earlgreyName: "Earl Grey, Twinings",
  oolongName: "Oolon, Mighty Leaf Tea"
}
#+END_SRC

result:

#+BEGIN_SRC
The best selling tea this week is Earl Grey, Twinings.
#+END_SRC

*** t.concat
*** t.content: Content Variable

The t.content variable defines what goes in the replace block.

You assign your variable to the t.content variable and your
variable's value replaces the whole replace block.  The default
is "", which mean the block is replaced with nothing. The
t.content variable only applies to the replace command.

*** t.else
*** t.exists

The t.exists returns 1 when a variable exists, else it returns 0.

*** t.if:

You can use an if function in a template statement to create or
assign a variable.

The if function has three parameters. The first parameter is the
condition, the second is the 1 case and the third is the else
case. When the condition is 1, the second parameter is returned,
else the third parameter is returned.

The following example uses the template system to show how it
works.

template:

#+BEGIN_SRC
<--$ block \-->
<--$ var1=t.if(1, 'dog', 'cat'), \-->
<--$ var2=t.if(0, 'dog', 'cat'), -->

t.if(1, 'dog', 'cat') -> {var1}
t.if(0, 'dog', 'cat') -> {var2}
<--$ endblock -->
#+END_SRC

result:

#+BEGIN_SRC

t.if(1, 'dog', 'cat') -> dog
t.if(0, 'dog', 'cat') -> cat
#+END_SRC

*** t.len:

The t.len function returns the number of characters in a string,
the number of elements in a list or the number of elements in a
dictionary.

#+BEGIN_SRC
<!-- nextline strlen = t.len("Tetley"); \-->
<!-- : listLen = t.len(tea_list); serverJson = t.len(t.server) -->
The Tetley name has {length} characters.
The tea list has {listlen} elements.
The server json dictionary has {serverJson} elements.
#+END_SRC

json:

#+BEGIN_SRC
{
"tea_list": [
    {"tea": "Black"},
    {"tea": "Green"},
    {"tea": "Oolong"},
    {"tea": "Sencha"},
    {"tea": "Herbal"}
  ]
}
#+END_SRC


result:

#+BEGIN_SRC
The Tetley name has 6 characters.
The tea list has 5 elements.
The server json dictionary has 1 elements.
#+END_SRC

*** t.list: List Variable

The t.list variable controls how many times the command's block
repeats. You assign it with your list variable and the block
repeats for each item in the list. The values come from the list
items. The default is t.server which means show the block once
using values from the t.server. An empty list means don't show the
block at all. You can assign the t.list a list or dictionary value.

For the following example, tea_list is assigned to the t.list
variable. The tea_list has five items.

template:

#+BEGIN_SRC
<!--$ nextline t.list = tea_list -->
  * {tea}
#+END_SRC

json:

#+BEGIN_SRC
{
"tea_list": [
    {"tea": "Black"},
    {"tea": "Green"},
    {"tea": "Oolong"},
    {"tea": "Sencha"},
    {"tea": "Herbal"}
  ]
}
#+END_SRC

result:

#+BEGIN_SRC
  * Black
  * Green
  * Oolong
  * Sencha
  * Herbal
#+END_SRC

The following example builds a select list of tea companies where
one company is selected.

template:

#+BEGIN_SRC
<h4>Tea Companies</h3>
<select>
<!--$ nextline t.list=companyList; \-->
<!--$ : current=t.if(selected, ' selected="selected"', "") -->
  <option{current}>{company}</option>
</select>
#+END_SRC

json:

#+BEGIN_SRC
{
"companyList": [
    {"company": "Lipton"},
    {"company": "Tetley"},
    {"company": "Twinings, "selected": 1"},
    {"company": "American Tea Room"},
    {"company": "Argo Tea"},
    {"company": "Bigelow Tea Company"}
  ]
}
#+END_SRC

result:

#+BEGIN_SRC
<h3>Tea Companies</h3>
<select>
  <option>Lipton</option>
  <option>Tetley</option>
  <option selected="selected">Twinings</option>
  <option>Argo Tea</option>
  <option>American Tea Room</option>
  <option>Bigelow Tea Company</option>
</select>
#+END_SRC

*** t.maxLines: Max Lines Variable

StaticTea reads lines looking for the endblock or endreplace
commands.  By default, if it is not found in 10 lines, the 10
lines are used for the block and a warning is output.

You can increase this value to support blocks with more lines by
setting the t.maxLines system variable.

#+BEGIN_SRC
<!--$ block t.maxLines=20 -->
#+END_SRC

Note: only endblock ends a block command, and the same for
replace. Other commands inside a block are not treated as commands
but instead treated as replacement block text. For example:

template:

#+BEGIN_SRC
<!--$ block -->
<!--$ # this is not a comment, just text -->
fake nextline
<!--$ nextline -->
<!--$ endblock -->
#+END_SRC

result:

#+BEGIN_SRC
<!--$ # this is not a comment, just text -->
fake nextline
<!--$ nextline -->
#+END_SRC

*** t.result: Result Variable

You assign the system t.result variable to control where
replacement block's result goes, either the result file, standard
error or nowhere. By default it goes to the result file.

Result variable options:

- "result" - send the replacement block to the result file (default)
- "skip" - skip the block
- "stderr" - send the block to standard error, good for
  communicating that the json data is unexpected.

Skip Example:

The skip t.result case is good for building test lists.

When you view the following template fragment in a browser it
shows one item in the list.

template:

#+BEGIN_SRC
<h3>Tea</h3>
<ul>
<!--$ nextline t.list = teaList -->
  <li>{tea}</li>
</ul>
#+END_SRC

To create a static page that has more products for better testing
you could use the skip option like this:

template:

#+BEGIN_SRC
<h3>Tea</h3>
<ul>
<!--$ nextline t.list = teaList -->
  <li>{tea}</li>
<!--$ block t.result = 'skip' -->
  <li>Black</li>
  <li>Green</li>
  <li>Oolong</li>
  <li>Sencha</li>
  <li>Herbal</li>
<!--$ endblock -->
</ul>
#+END_SRC

json:

#+BEGIN_SRC
{
  "teaList": [
    {"tea": "Chamomile"},
    {"tea": "Chrysanthemum"},
    {"tea": "White"},
    {"tea": "Puer"}
  ]
}
#+END_SRC

result:

#+BEGIN_SRC
<h3>Tea</h3>
<ul>
  <li>Chamomile</li>
  <li>Chrysanthemum</li>
  <li>White</li>
  <li>Puer</li>
</ul>
#+END_SRC

*** t.row:

The special row function returns the current row for lists. The
function takes an option parameter which specifies the starting
number to return.

- t.row   — returns 0, 1, 2,...
- t.row 0 — returns 0, 1, 2,...
- t.row 1 — returns 1, 2, 3,...
- t.row N — returns N, N+1, N+2,... where N is some integer.

Here is an example using the row variable.

template:

#+BEGIN_SRC
<!--$ nextline t.list=companies -->
  <li id="r{t.row}>{t.row 1}. {teaCompany}</li>
#+END_SRC

json:

#+BEGIN_SRC
{
  "companies": [
    {"teaCompany": "Mighty Leaf Tea"},
    {"teaCompany": "Numi Organic Tea"},
    {"teaCompany": "Peet's Coffee & Tea"},
    {"teaCompany": "Red Diamond"}
  ]
}
#+END_SRC

result:

#+BEGIN_SRC
  <li id="r0">1. Mighty Leaf Tea</li>
  <li id="r1">2. Numi Organic Tea</li>
  <li id="r2">3. Peet's Coffee & Tea</li>
  <li id="r3">4. Red Diamond</li>
#+END_SRC

*** t.server
*** t.shared
*** t.version:

You use the version function to get the current version of
StaticTea or to verify that the version you are running works
with your template.

The version function takes 0, 1 or 2 parameters. The first parameter
is the minimum version supported and the second parameter is the
maximum version supported.

The default minimum is 0.0.0 and the default maximum is anything.

If the current version is below the minimum or above the maximum,
the function outputs a message to standard error.

You can use the function multiple times for fine grain checking.

StaticTea uses [[https://semver.org/][Semantic Versioning]] with the added restriction
that each version component is limited to three digits and all
components have at least one digit.

Below is typical useage:

template:

#+BEGIN_SRC
<--$ nextline version=t.version("1.20.3", "3.4.005") -->
<-- StaticTea current version is: {version}. -->
#+END_SRC

result:

#+BEGIN_SRC
<-- StaticTea current version is: 1.9.0. -->
#+END_SRC

If the current version is not between the min and max, a message
is output to standard error.  Example messages:

stdout:

#+BEGIN_SRC
template(line): the current version 4.0.2 is greater than the maximum
allowed verion of 3.4.5.

template(line): the current version 1.0.0 is less than the minumum
allowed verion of 1.2.3.
#+END_SRC

** Json Dictionaries

You have access to the server and shared dictionaries with the
t.server and t.shared system variables.

template:

#+BEGIN_SRC
<!-- block serverElements = t.len(t.server) \-->
<!-- : jsonElements = t.len(t.shared) -->
The server passed {serverElements} elements
and the shared json has {jsonElements}.
<!-- endblock -->
#+END_SRC

json:

#+BEGIN_SRC
{
  "tea1": "Black",
  "tea2": "Green",
  "tea3": "Oolong",
  "tea4": "Sencha",
  "tea5": "Herbal"
}
#+END_SRC

result:

#+BEGIN_SRC
The server passed 5 elements
and the shared json has 0.
#+END_SRC

** System Defaults

You can use the system variables in a replacement block to see
their default values. The following example shows the default
values of so of the system variables.

template:

#+BEGIN_SRC
<!--$ block -->
default t.row = {t.row}
default t.list = {t.list}
default t.content = {t.content}
default t.maxLines = {t.maxLines}
<!--$ endblock -->
<!--$ block t.maxLines = 20 -->
t.maxLines = {t.maxLines}
<!--$ endblock -->
#+END_SRC

result:

#+BEGIN_SRC
default t.row = 0
default t.list = ""
default t.content = ""
default t.maxLines = 10
t.maxLines = 20
#+END_SRC

** Optional Parentheses:

Functions take different numbers of parameters. If you call with
one parameter, you can drop the parentheses.

These are equivalent:

#+BEGIN_SRC
email = t.row(0)
email = t.row 0
#+END_SRC

** StaticTea as a Filter

You can use the statictea command as a filter and pipe template
lines to it and see the result output on the screen.

Below is an example you can copy and paste into your terminal. It
creates a template.txt file containing two lines, then it creates
the server.json file containing one line, then it runs statictea
using those files and the result goes to the screen.

#+BEGIN_SRC
# create template file
cat <<EOF >template.txt
<!--$ nextline -->
hello {name}
EOF

# create server json file
cat <<EOF >server.json
{"name": "world"}
EOF

statictea --template template.txt --server server.json
#+END_SRC

If you copy and paste those lines to your terminal, it will look
like:

#+BEGIN_SRC
$ cat <<EOF >template.txt
> <!--$ nextline -->
> hello {name}
> EOF
$
$ cat <<EOF >server.json
> {"name": "world"}
> EOF
$
$ statictea --template template.txt --server server.json
hello world
#+END_SRC

The following example pipes template.txt to statictea. The result
goes to the screen.

#+BEGIN_SRC
cat template.txt | statictea --template stdin --server server.json

hello world
#+END_SRC

** TODO Prefix Postfix

You make the template commands look like comments for your
template file type. This allows you to edit the template using
its native editor and run other native tools.  For example, you
can edit StaticTea html template with an html editor.

Comment syntax varies depending on the type of template file and
sometimes depending on the location within the file. StaticTea
supports several varieties and you can specify others.

You want to distinguish StaticTea commands from normal comments
when you create your own. The convention is to add a $ as the
last character of the prefix and only use $ with StaticTea
commands and space for normal comments.

Built in Prefixes:

- '<!--$' '-->' - for html
- '/!--$' '--*\slash{}' - for javascript in html
- '&lt;!--$' '--&gt;' - for html textarea elements
- '#$' - for bash scripts and others
- ';$' - for config files and others

You can define other comment types on the command line using the
prepost option one or more times.

You separate the prefix from the postfix with one space and the
postfix is optional. The second example below only specifies the
prefix and several prefixes with different amounts of leading
space.

examples:

#+BEGIN_SRC
statictea --prepost "@$" "|" --prepost "[comment$" "]"
statictea --prepost "  #$" --prepost "    #$" --prepost "      #$"
#+END_SRC

** Json Files

There are two types of json files the server json and the shared
json.

The server json comes from the server and doesn’t contain any
presentation data.

The share json is used by the template builder to share common
template lines and it contains presentation data.

The server json file is included with the server option.  Its
variables are referenced with the "s." namespace prefix.

You can specify multiple server or shared files on the statictea
command line. The server variables get added to the t.server
dictionary and the shared to the t.shared dictionary.

The get added from left to right so the last duplicate variable
wins.

** Warning Messages

When StaticTea detects a problem, a warning message is written to
standard error, the statement is skipped, and processing
continues.

If a variable in a replacement block is used but it doesn't
exist, the variable remains as is in the result, and a message is
output to standard error telling the line and the name of the
missing variable.  There are many different potential warnings.

It’s good style to change your template or json so no messages
get output.

The warning messages show the line number where the problem
happened. Every message has a unique number which doesn't
change. Don't count on the message text remaining constant.  All
new messages get added to the bottom.

example messages:

- template.html(45): w0001: Unknown server variable: teaMaster
- template.html(45): w0002: The postfix is missing.
- template.html(45): w0003: The command line doesn't have a valid
  command: blocker
- template.html(45): w0004: Unknown system variable: t.asdf.
- template.html(45): w0005: Server json file not found: server.json
- template.html(45): w0006: Unable to parse server.json.

The statictea program returns success, 0, when no message get
output, else it returns 1.

Example of running statictea when a variable is missing:

template:

#+BEGIN_SRC
<!--$ nextline -->
You're a {webmaster}, I'm a {teaMaster}!
#+END_SRC

json:

#+BEGIN_SRC
{
  "webmaster": "html wizard"
}
#+END_SRC

stderr:

#+BEGIN_SRC
template.html(2): w0001: Unknown server variable: teaMaster
#+END_SRC

result:

#+BEGIN_SRC
You're a html wizard, I'm a {teaMaster}!
#+END_SRC

You can write your own warning messages using the system t.result
set to stderr. In the following example a warning message is
written to standard error when the server admin variable is
missing. When it is not missing nothing gets output.

template:

#+BEGIN_SRC
<!--$ block t.result="stderr"; t.list = t.if(t.exists(admin), "", t.server) \-->
<!--$   "warning: the admin variable is missing") -->
<!--$ endblock -->
#+END_SRC

** Run StaticTea

You run StaticTea from the command line. The example below shows
a typical invocation which specifies four file arguments, the
server json, the shared json, the template and the result.

- Warning messages go to standard error.
- If you don't specify the result argument, the result goes to standard out.
- If you specify "stdin" for the template, the template comes
  from stdin.

#+BEGIN_SRC
statictea --server server.json --shared shared.json --template template.html --result result.html
#+END_SRC

*** Options

The StaticTea command line options:

- help - show the help, usage and options.
- version - outputs the version number.
- server - the server json file, you can specify multiple.
- shared - the shared json file, you can specify multiple.
- update - update the template replace blocks.

** General Limits

- max command line length
- max number of shared variables
- max number of server variables
- max literal string length
- max literal name length
- max json key name length
- max json string value length
- max json file size in bytes
- max number if items in a list

StaticTea checkes the json file size and if within the limit it
reads it and adds its elements to the shared or server
dictionaries. Duplicate elements overwrite existing elements.  If
a json key length or string value exceeds a limit, it is skipped
and a warning is output.

There is no limit on the size of the template.

** Encoding and Line Endings

Templates are utf-8 encoded or its ascii subset.  Three line
endings are supported on all platforms: LF, CR LF, or CR.
The template syntax only uses ascii.

** Ellipsize

#+BEGIN_SRC
<!--$ # If the name is longer than 10 characters, -->
<!--$ # clip it to 7 and add "...".               -->
<!--$ cmp = t.cmp(len(name), 10);                \-->
<!--$ name = t.case(cmd,                         \-->
<!--$ : 1, t.concat(substr(name, 0, 7), "..."),  \-->
<!--$ : t.else, name))                            -->
#+END_SRC

** Tea Info

Tea is the most popular manufactured drink consumed in the world,
equaling all others – including coffee, soft drinks, and alcohol
– combined. -- Wikipedia -- Macfarlane, Alan; Macfarlane, Iris
(2004). The Empire of Tea. The Overlook Press. p. 32. ISBN
978-1-58567-493-0.

There are five main groups of teas, white, green, oolong, black,
and pu'erh.

** Other

You can show a dictionary content using the t.show function.
Show list too?

#+BEGIN_SRC
<!--$ nextline tserver = t.show(t.server) -->
{tserver}
#+END_SRC

json:

#+BEGIN_SRC
{
  admin: 0,
  "teaList": [
    {"tea": "Chamomile"},
    {"tea": "Chrysanthemum"},
    {"tea": "White"},
    {"tea": "Puer"}
  ],
  "company": "Twinings",
  "example": true
  "dict": {}
}
#+END_SRC

result:

#+BEGIN_SRC
admin: 0
teaList: [4]
company: "Twinings"
example: true
dict: {0}
#+END_SRC

** t.limits

The t.limits dictionary contains the global limit values.
