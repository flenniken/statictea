#+TITLE: StaticTea
* A template processor and language.
:PROPERTIES:
:CUSTOM_ID: top
:END:

StaticTea combines a template with data to produce a result.

Example hello world template:

#+BEGIN_SRC
<!--$ nextline -->
hello {s.name}
#+END_SRC

The associated json data:

#+BEGIN_SRC
{"name": "world"}
#+END_SRC

The result:

#+BEGIN_SRC
hello world
#+END_SRC

[[#contents][茶]] (contents at the bottom)

* Advantages
:PROPERTIES:
:CUSTOM_ID: advantages
:END:

You can view, edit and validate your templates with its normal
tools.  You develop templates as if they were static pages.

The template designer has full control over the presentation.
You can change the look without changing the server.

You can share common template fragments between templates.

[[#contents][茶]]

* How it Works
  :PROPERTIES:
:CUSTOM_ID: how-it-works
:END:

You pass unformatted variable content from the server as json.
You format it in the template with commands to create new
variables that get inserted into the template.

You mark replacement text with brackets and with preceding command
lines.

The commands are encoded as comments to match the particular
template type.

[[#contents][茶]]

* Commands
:PROPERTIES:
:CUSTOM_ID: commands
:END:

StaticTea commands:

- [[#nextline-command][nextline]] -- make substitutions in the next line
- [[#block-command][block]] —- make substitutions in the next block of lines
- [[#replace-command][replace]] -— replace the block with a variable
- # —- [[#comment-command][comment command]]
- : -- [[#continue-command][continue command]], used to continue a command line
- [[#endblock-command][endblock]] -- end of block
- [[#endreplace-command][endreplace]] -- end of replace block

[[#contents][茶]]

** Nextline Command
:PROPERTIES:
:CUSTOM_ID: nextline-command
:END:

The nextline command targets the line following it for
replacement. The targeted line is called the replacement block.

The replacement block contains any number of variables wrapped
with brackets.  They get replaced with the variables's value.

The following example's replacement block contains two variables,
drink and drinkType.

template:

#+BEGIN_SRC
<!--$ nextline -->
Drink {s.drink} -- {s.drinkType} is my favorite.
#+END_SRC

server json:

#+BEGIN_SRC
{
  "drink": "tea",
  "drinkType": "Earl Grey""
}
#+END_SRC

result:

#+BEGIN_SRC
Drink tea -- Earl Grey is my favorite.
#+END_SRC

[[#contents][茶]]

** Block Command
:PROPERTIES:
:CUSTOM_ID: block-command
:END:

The block command targets multiple lines for replacement. The
replacement block starts after the command and continues until
the endblock line is found. It behaves like the nextline command
except with multiple lines.

In the following example the block has two lines. The block
contains three replacement variables, weekday, name and time.

template:

#+BEGIN_SRC
<!--$ block -->
Join our tea party on
{s.weekday} at {s.name}'s
house at {s.time}.
<!--$ endblock -->
#+END_SRC

server json:

#+BEGIN_SRC
{
  "weekday": "Friday",
  "name": "John",
  "time": "5:00 pm"
}
#+END_SRC

result:

#+BEGIN_SRC
Join our tea party on
Friday at John's
house at 5:00 pm.
#+END_SRC

[[#contents][茶]]

** Replace Command
:PROPERTIES:
:CUSTOM_ID: replace-command
:END:

The replace command's replacement block gets replaced with the
t.content variable.

The lines in the block mirror the variable so you can
test the template as if it was a static file.

The command is useful for sharing common template lines between
templates and it has the special property that you can
automatically update the replacement block to keep it in sync
with the variable.

If you don't assign the t.content variable, the block content is
used as is.  This is good for testing changes you want to make to
the shared value.

The following example shares a common header between templates.

template:

#+BEGIN_SRC
<!--$ replace t.content=h.header -->
<!--$ endreplace -->
#+END_SRC

shared json:

#+BEGIN_SRC
{
  "header": "<!doctype html>\n<html lang="en">\n"
}
#+END_SRC

result:

#+BEGIN_SRC
<!doctype html>
<html lang="en">
#+END_SRC

The above example generates the correct result but it doesn’t
work as a static template because the template is missing the
header lines.

You can fix this by adding the header lines inside the replace
block. The inside lines do not appear in the result, just the
data from the json variable.

template:

#+BEGIN_SRC
<!--$ replace t.content=h.header -->
<!doctype html>
<html lang="en">
<!--$ endreplace -—>
#+END_SRC

The template replacement block may get out of sync with the
variable.  You can update the replacement block to match the
variable with the update option.

The following example updates the mytea.html template's
replacement blocks to match their variables in the shared.json
file:

#+BEGIN_SRC
statictea --update \
   --shared shared.json \
   --template mytea.html
#+END_SRC

The shared variable may contain replacement content too.  Here is
another html header example:

template:

#+BEGIN_SRC
<!--$ replace t.content=h.header -->
<!DOCTYPE html>
<html lang="{s.languageCode}"
dir="{s.languageDirection}">
<head>
<meta charset="UTF-8"/>
<title>{s.title}</title>
<--$ endreplace -->
#+END_SRC

server json:

#+BEGIN_SRC
{
"languageCode": "en",
"languageDirection": "ltr",
"title": "Teas in England"
}
#+END_SRC

shared json:

#+BEGIN_SRC
{
  "header": "<!DOCTYPE html>\n
<html lang="{s.languageCode}"
dir="{s.languageDirection}">\n
<head>\n
<meta charset="UTF-8"/>\n
<title>{s.title}</title>\n"
}
#+END_SRC

result:

#+BEGIN_SRC
<!DOCTYPE html>
<html lang="en"
dir="ltr">
<head>
<meta charset="UTF-8"/>
<title>Teas in England</title>
#+END_SRC

[[#contents][茶]]

** Comment Command
:PROPERTIES:
:CUSTOM_ID: comment-command
:END:

You can comment templates.  Comments are line based and use the #
character. They do not appear in the result.

template:

#+BEGIN_SRC
<!--$ # How you make tea. -->
There are five main groups of teas:
white, green, oolong, black, and pu'erh.
You make Oolong Tea in five time
intensive steps.
#+END_SRC

result:

#+BEGIN_SRC
There are five main groups of teas:
white, green, oolong, black, and pu'erh.
You make Oolong Tea in five time
intensive steps.
#+END_SRC

[[#contents][茶]]

** Continue Command
:PROPERTIES:
:CUSTOM_ID: continue-command
:END:

You can continue a long command line with the "\\" character at
the end before the postfix. The following line must be a continue
command.

The continue command allows you to continue adding statements
when you need more space. You can continue the continue command
too.

In the following example the nextline command continues on a
second line and third line.

template:

#+BEGIN_SRC
<!--$ nextline \-->
<!--$ : tea = 'Earl Grey' \-->
<!--$ : tea2 = 'Masala chai' -->
{tea}, {tea2}
#+END_SRC

result:

#+BEGIN_SRC
Earl Grey, Masala chai
#+END_SRC

[[#contents][茶]]

** Endblock Command
:PROPERTIES:
:CUSTOM_ID: endblock-command
:END:

The endblock command ends the block command. Only the endblock
command ends a block command. All text until the endblock is part
of the replacement block. This includes lines that look like
commands. For example:

template:

#+BEGIN_SRC
<!--$ block -->
<!--$ # this is not a comment, just text -->
fake nextline
<!--$ nextline -->
<!--$ endblock -->
#+END_SRC

result:

#+BEGIN_SRC
<!--$ # this is not a comment, just text -->
fake nextline
<!--$ nextline -->
#+END_SRC

[[#contents][茶]]

** Endreplace Command
:PROPERTIES:
:CUSTOM_ID: endreplace-command
:END:

The endreplace command ends the replace command.

[[#contents][茶]]

* Statements
:PROPERTIES:
:CUSTOM_ID: statements
:END:

You format server content in variables you create in statements.

A statement consists of a variable, an equal sign, and a right
hand side. The right hand side is either another variable, a
string, a number or a function. Here are some examples:

#+BEGIN_SRC
tea = "Earl Grey"
num = 5
t.repeat = 8
nameLen = len(s.name)
#+END_SRC

Statements are allowed on the nextline, block and replace
commands. You can use multiple statements separated with
semicolons. If you need more space, you can continue the line
with the "\\" character at the end. Statements are executed from
left to right.

[[#contents][茶]]

* Variables
:PROPERTIES:
:CUSTOM_ID: variables
:END:

You use variables to format content for a block and to control
how a command works. You create them in json files or in template
statements. Internally one dictionary exists for each of the four
types of variables, you access them with different prefixes, and
they are stored in different dictionaries:

- [[#json-variables][Server Json Variables]] --  "s.", t.server
- [[#json-variables][Shared Json Variables]] -- "h.", t.shared
- [[#local-variables][Local Variables]] -- no prefix, t.local
- [[#tea-variables][Tea Variables]] -- "t.", built in

[[#contents][茶]]

** Json Variables
:PROPERTIES:
:CUSTOM_ID: json-variables
:END:

There are two types of json files, the server json and the shared
json.  The top level json dictionary key becomes the variable's
name and its value becomes the variable's value.

You can use multiple server and shared json files by specifying
multiple files on the command line. The files are processed
left to right which is important when there are duplicate
variables since the last one processed overwrites the previous
one.

The json null values get converted to the 0. Json True and False
get converted to 1 and 0.

You cannot change the json variables.

The server variables are stored in the t.server dictionary.

The shared variables are stored in the t.shared dictionary.

The server json comes from the server and shouldn't contain any
presentation data so the template designers have full control of
the presentation.

The shared json is created by the template designer for sharing
common template fragments and other presentation needs.

Here is an example showing the number of elements in the t.server
and t.shared dictionaries.

template:

#+BEGIN_SRC
<!--$ block \-->
<!--$ : serverElements = len(t.server) \-->
<!--$ : jsonElements = len(t.shared) -->
The server has {serverElements} elements
and the shared json has {jsonElements}.
<!--$ endblock -->
#+END_SRC

json:

#+BEGIN_SRC
{
 "tea1": "Black",
 "tea2": "Green",
 "tea3": "Oolong",
 "tea4": "Sencha",
 "tea5": "Herbal"
}
#+END_SRC

result:

#+BEGIN_SRC
The server has 5 elements
and the shared json has 0.
#+END_SRC

[[#contents][茶]]

** Local Variables
   :PROPERTIES:
   :CUSTOM_ID: local-variables
   :END:

You create local variables with template statements.  They are
local to the block where they are defined.  They are processed
from left to right. If there are duplicate variables, the last
one overwrites the previous one. There is no prefix for local
variables. They are stored in the t.local dictionary.

[[#contents][茶]]

*** Tea Variables
    :PROPERTIES:
    :CUSTOM_ID: tea-variables
    :END:

  The built in tea variables are prefixed with "t." and they
  control how the replacement block works.

  - [[#tcontent][t.content]] -- content of the replace block
  - [[#tlocal][t.local]] -- dictionary containing the current block's local variables.
  - [[#tmaxrepeat][t.maxRepeat]] -- maximum number of times to repeat the block
  - [[#tmaxlines][t.maxLines]] -- maximum lines before endblock or endreplace
  - [[#toutput][t.output]] -- where the block output goes
  - [[#trepeat][t.repeat]] -- controls how many times the block repeats
  - [[#tserver][t.server]] -- dictionary containing the server variables
  - [[#tshared][t.shared]] -- dictionary containing the shared variables

  [[#contents][茶]]

**** t.content
     :PROPERTIES:
     :CUSTOM_ID: tcontent
     :END:

  The t.content variable determines what content to use for the
  whole replace block.

  When the t.content is not set, the block content is used like a
  block command except a warning message is output. This is good
  for testing changes you want to make to the shared value and the
  warning reminds you to set the variable when done.

  The variable only applies to the replace command. See the [[#replace-command][replace
  command]] section for an example.

  [[#contents][茶]]

**** t.local
     :PROPERTIES:
     :CUSTOM_ID: tlocal
     :END:

  The t.local variable is the dictionary of local variables for the
  current command.

  [[#contents][茶]]

**** t.maxRepeat
     :PROPERTIES:
     :CUSTOM_ID: tmaxrepeat
     :END:

  The t.maxRepeat variable determines the maxiumum times a block
  can repeat.  The default is 100.  A warning message is output
  when you try to assign a bigger number to t.repeat and the value
  is clipped to the maximum.

  It prevents the case where you mistakenly assign a giant number,
  and it allows you to design your template to work well for the
  expected range of blocks.

  You can increase this value to support more blocks by setting the
  t.maxRepeat variable.

  [[#contents][茶]]

**** t.maxLines
     :PROPERTIES:
     :CUSTOM_ID: tmaxlines
     :END:

  The t.maxLines variable determines the maximum lines in a block.

  StaticTea reads lines looking for the endblock or endreplace
  commands.  By default, if it is not found in 10 lines, the 10
  lines are used for the block and a warning is output. This catches
  the case where you forget the end command.

  You can increase this value to support blocks with more lines by
  setting the t.maxLines system variable.

  #+BEGIN_SRC
  <!--$ block t.maxLines=20 -->
  #+END_SRC

  [[#contents][茶]]

**** t.output
     :PROPERTIES:
     :CUSTOM_ID: toutput
     :END:

  The t.output variable determines where the block output goes.  By
  default it goes to the result file specified when you run
  statictea.

  - "template" -- the block output goes to the result file
  - "stderr" -- the block output goes to standard error
  - "log" -- the block output goes to the log file
  - "skip" -- the block is skipped

  You can use the stderr option to write your own warning messages.

  template:

  #+BEGIN_SRC
  <!--$ nextline \-->
  <!--$ : t.output = if( \-->
  <!--$ :   exists(s.admin), "skip", \-->
  <!--$ :   "stderr"); \-->
  <!--$ : msg = concat( \-->
  <!--$ :   template(), "(", \-->
  <!--$ :   getLineNumber(), ")", \-->
  <!--$ :   "missing admin var") -->
  {msg}
  #+END_SRC

  result:

  #+BEGIN_SRC
  template.html(45): missing admin var
  #+END_SRC

  [[#contents][茶]]

**** t.repeat
     :PROPERTIES:
     :CUSTOM_ID: trepeat
     :END:

  The t.repeat variable is a number that tells hom many times to
  repeat the block.

  You use the row function to customize each block.  Each time
  the block repeats the local variables get recalculated.

  By default the block is output once. A value of zero means don't
  show the block at all.

  For the following example, tea_list is assigned to the t.repeat
  variable which outputs the block five times.

  template:

  #+BEGIN_SRC
  <!--$ nextline t.repeat = len(s.tea_list); \-->
  <!--$ : tea = get(s.tea_list, row()) -->
   * {tea}
  #+END_SRC

  server json:

  #+BEGIN_SRC
  {
  "tea_list": [
     "Black",
     "Green",
     "Oolong",
     "Sencha",
     "Herbal"
   ]
  }
  #+END_SRC

  result:

  #+BEGIN_SRC
   * Black
   * Green
   * Oolong
   * Sencha
   * Herbal
  #+END_SRC

  The following example builds an html select list of tea companies
  with the Twinings company selected and it shows how to access
  values from dictionaries.

  template:

  #+BEGIN_SRC
  <h3>Tea Companies</h3>
  <select>
  <!--$ nextline t.repeat=len(s.companyList); \-->
  <!--$ : d = get(s.companyList, row()); \-->
  <!--$ : company = get(d, "company"); \-->
  <!--$ : selected = get(d, "selected", 0); \-->
  <!--$ : current=if(selected, ' selected="selected"', "") -->
   <option{current}>{company}</option>
  </select>
  #+END_SRC

  server json:

  #+BEGIN_SRC
  {
  "companyList": [
     {"company": "Lipton"},
     {"company": "Tetley"},
     {"company": "Twinings, "selected": 1},
     {"company": "American Tea Room"},
     {"company": "Argo Tea"},
     {"company": "Bigelow Tea Company"}
   ]
  }
  #+END_SRC

  result:

  #+BEGIN_SRC
  <h3>Tea Companies</h3>
  <select>
   <option>Lipton</option>
   <option>Tetley</option>
   <option selected="selected">Twinings</option>
   <option>Argo Tea</option>
   <option>American Tea Room</option>
   <option>Bigelow Tea Company</option>
  </select>
  #+END_SRC

  Setting t.repeat to 0 is good for building test lists.

  When you view the following template fragment in a browser it
  shows one item in the list.

  template:

  #+BEGIN_SRC
  <h3>Tea</h3>
  <ul>
  <!--$ nextline t.repeat = len(s.teaList); \-->
  <!--$ : tea = get(s.teaList, row()) -->
   <li>{tea}</li>
  </ul>
  #+END_SRC

  To create a static page that has more products for better testing
  you could use the skip option like this:

  template:

  #+BEGIN_SRC
  <h3>Tea</h3>
  <ul>
  <!--$ nextline t.repeat = len(s.teaList) \-->
  <!--$ : tea = get(s.teaList, row()) -->
   <li>{tea}</li>
  <!--$ block t.repeat = 0 -->
   <li>Black</li>
   <li>Green</li>
   <li>Oolong</li>
   <li>Sencha</li>
   <li>Herbal</li>
  <!--$ endblock -->
  </ul>
  #+END_SRC

  server json:

  #+BEGIN_SRC
  {
   "teaList": [
     "Chamomile",
     "Chrysanthemum",
     "White",
     "Puer"
   ]
  }
  #+END_SRC

  result:

  #+BEGIN_SRC
  <h3>Tea</h3>
  <ul>
   <li>Chamomile</li>
   <li>Chrysanthemum</li>
   <li>White</li>
   <li>Puer</li>
  </ul>
  #+END_SRC

  [[#contents][茶]]

**** t.server
     :PROPERTIES:
     :CUSTOM_ID: tserver
     :END:

  The t.server variable contains the server json variables.

  [[#contents][茶]]

**** t.shared
     :PROPERTIES:
     :CUSTOM_ID: tshared
     :END:

  The t.shared variable contains the shared json variables

  [[#contents][茶]]

* Types
:PROPERTIES:
:CUSTOM_ID: types
:END:

StaticTea variables types:

- [[#string][string]]
- [[#integer][integer]]
- [[#float][float]]
- [[#dictionary][dictionary]]
- [[#list][list]]

[[#contents][茶]]

** String
:PROPERTIES:
:CUSTOM_ID: string
:END:

You define a string with single or double quotes and use them in
statements.

If you pass a string to a function taking a number, the string
is converted to a number.

It's easier to define long strings in the json files instead of
locally.

example strings:

- "this is a string"
- 'using single quotes'
- "You can store black teas longer than green teas."
- "100"

example usage:

#+BEGIN_SRC
<!--$ nextline tea = "Earl Grey" -->
<h2>{tea}</h2>
#+END_SRC

result:

#+BEGIN_SRC
<h2>Earl Grey</h2>
#+END_SRC

[[#contents][茶]]

** Integer
:PROPERTIES:
:CUSTOM_ID: integer
:END:

An integer is a 64 bit signed number.  When you pass an integer to
a function that takes a string, the number is converted to a
string. Plus signs are not used with numbers.

Example numbers:

#+BEGIN_SRC
12345
0
-8823
42
#+END_SRC

[[#contents][茶]]

** Float
:PROPERTIES:
:CUSTOM_ID: float
:END:

A float is a 64 bit real number. Like integers a float is
converted to a string when passed to a function taking a sring.
A float has a decimal point and starts with a digit or minus
sign.

Example floats:

#+BEGIN_SRC
3.14159
24.95
.123
-34.0
#+END_SRC

[[#contents][茶]]

** Dictionary
:PROPERTIES:
:CUSTOM_ID: dictionary
:END:

You access dictionary items with get and you define them in the
json files.

[[#contents][茶]]

** List
:PROPERTIES:
:CUSTOM_ID: list
:END:

Like dictionaires, you access list items with get and you
define them in the json files.

[[#contents][茶]]

* Functions
:PROPERTIES:
:CUSTOM_ID: functions
:ORDERED:  t
:END:

You use a function in a statement to generate a value. You either
assign the value to a variable or you pass it to another function.

Functions can take zero or more parameters and return a
value. Some functions have optional parameters.

List of functions:

- [[#case][case()]] -- generalized if function
- [[#cmp][cmp()]] -- spaceship compare function <=>
- [[#concat][concat()]] -- concatenate strings
- [[#currency][currency()]] -- format currency
- [[#exists][exists()]] -- whether a variables exists
- [[#find][find()]] -- find a substring in a string
- [[#format][format()]] -- format a string or a number
- [[#if][if()]] -- if function
- [[#len][len()]] -- length of string
- [[#lineNumber][lineNumber()]] -- the current line number
- [[#quotehtml][quoteHtml]] -- replace html special characters
- [[#row][row()]] -- function that returns the current row number
- [[#sizes][sizes()]] -- format bytes counts, KB, MB, GB, etc.
- [[#substr][substr()]] -- extract a substring from a string by indexes
- [[#time][time()]] -- format the date and time.
- [[#template][template()]] -- the filename of the current template
- [[#version][version()]] -- the current version and version checker

[[#contents][茶]]

** case()
:PROPERTIES:
:CUSTOM_ID: case
:END:

The case function is a generalized if statement.  You use it to
preform different actions depending on a condition.

It requires at least two parameters, the condition and the "else"
case.

The rest of the parameters you specify in pairs, the first is the
case value and the second is the return value when the condition
matches that case.

When none of the cases match the condition, the else case is
used.

For the example below the abbr variable is set to an abbreviation
depending on the type of tea.

template:

#+BEGIN_SRC
<--$ nextline \-->
<--$ : abbr = case( \-->
<--$ : s.tea, "unknown",  \-->
<--$ : 'Darjeeling', "Darj",  \-->
<--$ : "Earl Gray", "EG") -->
The abbreviation for {s.tea} is {s.abbr}.
#+END_SRC

server json:

#+BEGIN_SRC
{
  "tea": "Darjeeling"
}
#+END_SRC

result:

#+BEGIN_SRC
The abbreviation for Darjeeling is Darj.
#+END_SRC

The if statement is shorthand for a simple case:

#+BEGIN_SRC
if(cond, v1, v2)
#+END_SRC
is equivalent to:
#+BEGIN_SRC
case(cond, v2, 1, v1)
#+END_SRC

[[#contents][茶]]

** cmp()
:PROPERTIES:
:CUSTOM_ID: cmp
:END:

The cmp function compares two variables, either numbers or
strings (both the same type), and returns whether the first
parameter is less than, equal to or greater than the second
parameter. It returns -1 for less, 0 for equal and 1 for greater
than.

template:

#+BEGIN_SRC
#$ block \
#$ cond1 = cmp(4, 5); \
#$ cond2 = cmp(2, 2); \
#$ cond3 = cmp(5, 4)
cmp(4, 5) returns {cond1}
cmp(2, 2) returns {cond2}
cmp(5, 4) returns {cond3}
#$ endblock
#+END_SRC

result:

#+BEGIN_SRC
cmp(4, 5) returns -1
cmp(2, 2) returns 0
cmp(5, 4) returns 1
#+END_SRC

Here is another example using cmp to "ellipsize" a string when it
gets long. The following example ellipsizes when a name is longer
than 10 characters.

#+BEGIN_SRC
<!--$ # If the name is longer than 10 characters, -->
<!--$ # clip it to 7 and add "...".               -->
<!--$ nextline                                   \-->
<!--$ : cmp = cmp(len(s.name), 10);              \-->
<!--$ : name = case(cmd, s.name                  \-->
<!--$ : 1, concat(substr(s.name, 0, 7), "..."))   -->
#+END_SRC

[[#contents][茶]]

** concat()
:PROPERTIES:
:CUSTOM_ID: concat
:END:

The concat function concatenates strings. You can specify 0 or
more parameters. The following example also shows using the "#$"
prefix:

#+BEGIN_SRC
#$ block \
#$ : x1 = concat(); \
#$ : x2 = concat("Tea"); \
#$ : x3 = concat("Tea", "Time"); \
#$ : x4 = concat("Tea", " ",  "Time")
concat() => '{x1}'
concat("Tea") => '{x2}'
concat("Tea", "Time") => '{x3}'
concat("Tea", " ",  "Time") => '{x4}'
#$ endblock
#+END_SRC

Result:

#+BEGIN_SRC
concat() => ''
concat("Tea") => 'Tea'
concat("Tea", "Time") => 'TeaTime'
concat("Tea", " ",  "Time") => 'Tea Time'
#+END_SRC

[[#contents][茶]]

** exists()
:PROPERTIES:
:CUSTOM_ID: exists
:END:

The exists returns 1 when a variable exists, else it returns 0.

template:

#+BEGIN_SRC
<--$ block a = "apple"; \-->
<--$ : ax = exists(a); \-->
<--$ : bx = exists(b) -->
exists(a) => {ax}
exists(b) => {bx}
<--$ endblock -->
#+END_SRC

result:

#+BEGIN_SRC
exists(a) => 1
exists(b) => 0
#+END_SRC

[[#contents][茶]]

** currency()
:PROPERTIES:
:CUSTOM_ID: currency
:END:

The currency function formats numbers as currency.

[[#contents][茶]]

** find()
:PROPERTIES:
:CUSTOM_ID: find
:END:

The find function searches a string for a substring and returns
its position when found. When not found it returns -1. Positions
start at 0.

template:

#+BEGIN_SRC
<--$ nextline \-->
<--$ pos = find("Tea time at 4:00.", "time") -->
{pos}
#+END_SRC

result:

#+BEGIN_SRC
4
#+END_SRC

[[#contents][茶]]

** get()
:PROPERTIES:
:CUSTOM_ID: get
:END:

You use the get function to access list or dictionary
values. It takes three parameters. The first is the list or
dictionary to use. The second is the key name for dictionaries or
the index for lists. The third optional parameter is the default
value when the item doesn't exist. If you don't specify the
default, a warning is generated when the item doesn't exist.

#+BEGIN_SRC
var = get(t.server, "tea", "Earl Grey")
var = get(t.server, 0, "Earl Grey")
#+END_SRC

[[#contents][茶]]

** if()
:PROPERTIES:
:CUSTOM_ID: if
:END:

You use the if function to select a value based on a condition.

The if function has three parameters. The first parameter is the
condition value (1 or not 1), the second is the true case (1 case) and the
third is the else case (not 1 case).  When the condition value is 1, the second
parameter is returned, else the third parameter is returned.

The following example uses the template system to show how it
works.

template:

#+BEGIN_SRC
<--$ block \-->
<--$ var1=if(1, 'dog', 'cat'), \-->
<--$ var2=if(0, 'dog', 'cat'), \-->
<--$ var3=if(8, 'dog', 'cat'), -->

if(1, 'dog', 'cat') => {var1}
if(0, 'dog', 'cat') => {var2}
if(8, 'dog', 'cat') => {var3}
<--$ endblock -->
#+END_SRC

result:

#+BEGIN_SRC

if(1, 'dog', 'cat') -> dog
if(0, 'dog', 'cat') -> cat
if(8, 'dog', 'cat') -> cat
#+END_SRC

[[#contents][茶]]

** format()
:PROPERTIES:
:CUSTOM_ID: format
:END:

The format function is a powerful way to format your
variables. You can left, right or center the variable.  You can
specify the number of digits after the decimal point and other
things. For all the details see: https://nim-lang.org/docs/strformat.html.

template:

#+BEGIN_SRC
<--$ nextline cost=format(".2f", s.cost)-->
Kathleen spent ${cost} on tea for Steve's birthday.
#+END_SRC

server json:

#+BEGIN_SRC
{
  "cost": 52.436789
}
#+END_SRC

result:

#+BEGIN_SRC
Kathleen spent $52.44 on tea for Steve's birthday.
#+END_SRC

[[#contents][茶]]

** len()
:PROPERTIES:
:CUSTOM_ID: len
:END:

The len function returns the number of characters in a string,
the number of elements in a list or the number of elements in a
dictionary.

#+BEGIN_SRC
<!--$ block \-->
<!--$ : length = len("Tetley"); \-->
<!--$ : listLen = len(tea_list); \-->
<!--$ : serverLen = len(t.server) -->
The Tetley name has {length} characters.
The tea list has {listlen} elements.
The server json dictionary has {serverLen} elements.
<!--$ endblock -->
#+END_SRC

json:

#+BEGIN_SRC
{
"tea_list": [
    {"tea": "Black"},
    {"tea": "Green"},
    {"tea": "Oolong"},
    {"tea": "Sencha"},
    {"tea": "Herbal"}
  ]
}
#+END_SRC

result:

#+BEGIN_SRC
The Tetley name has 6 characters.
The tea list has 5 elements.
The server json dictionary has 1 elements.
#+END_SRC

[[#contents][茶]]

** lineNumber()
:PROPERTIES:
:CUSTOM_ID: lineNumber
:END:

Return the line in the template where the function is called.

[[#contents][茶]]

** quoteHtml()
:PROPERTIES:
:CUSTOM_ID: quoteHtml
:END:

The quoteHtml replaces special html characters with equivalents.

[[#contents][茶]]

** row()
:PROPERTIES:
:CUSTOM_ID: row
:END:

The row function returns the current row number for
blocks that repeat. The function takes a parameter which
specifies the starting point.

- row(0) -— returns 0, 1, 2,...
- row(1) -— returns 1, 2, 3,...
- row(N) -— returns N, N+1, N+2,...

Here is an example using the row variable.

template:

#+BEGIN_SRC
<!--$ nextline t.repeat=len(s.companies); \-->
<!--$ : company = get(s.companies, row()); \-->
<!--$ : id = row(0); num = row(1) -->
<li id="r{id}>{num}. {company}</li>
#+END_SRC

server json:

#+BEGIN_SRC
{
  "companies": [
    "Mighty Leaf Tea",
    "Numi Organic Tea",
    "Peet's Coffee & Tea",
    "Red Diamond"
  ]
}
#+END_SRC

result:

#+BEGIN_SRC
  <li id="r0">1. Mighty Leaf Tea</li>
  <li id="r1">2. Numi Organic Tea</li>
  <li id="r2">3. Peet's Coffee & Tea</li>
  <li id="r3">4. Red Diamond</li>
#+END_SRC

[[#contents][茶]]

** sizes()
:PROPERTIES:
:CUSTOM_ID: sizes
:END:

The sizes function formats number of bytes as KB, MB, GB, etc.

[[#contents][茶]]

** substr()
:PROPERTIES:
:CUSTOM_ID: substr
:END:

The substr function extracts a substring from a string by
indexes. The first parameter is the string to operate on, the
second is the starting index of the substring to extract and the
third is the ending index (one past it). The third parameter is
optional and defaults to one past the end of the string. The end
minus the start is equal to the length of the substring.

Showing the indexes under Earl Grey helps to understand how the
function works.

#+BEGIN_SRC
Earl Grey
0123456789
#+END_SRC

template:

#+BEGIN_SRC
<--$ nextline \-->
<--$ : sub1 = substr("Earl Grey", 5) \-->
<--$ : sub2 = substr("Earl Grey", 0, 4) -->
sub1 = {sub1}, sub2 = {sub2}
#+END_SRC

result:

#+BEGIN_SRC
sub1 = Grey, sub2 = Earl
#+END_SRC

[[#contents][茶]]

** time()
:PROPERTIES:
:CUSTOM_ID: time
:END:

The time function formats date and time values.

[[#contents][茶]]

** template()
:PROPERTIES:
:CUSTOM_ID: template
:END:

Return the template filename. It takes one optional string
parameter:

- "basename" -- returns the name without any path information,
  which is the default.
- "passed" -- returns the template name passed to statictea.

[[#contents][茶]]

** version()
:PROPERTIES:
:CUSTOM_ID: version
:END:

You use the version function to get the current version of
StaticTea or to verify that the version you are running works
with your template.

The version function takes 0, 1 or 2 parameters. The first parameter
is the minimum version supported and the second parameter is the
maximum version supported.

The default minimum is 0.0.0 and the default maximum is anything.

If the current version is below the minimum or above the maximum,
the function outputs a message to standard error.

You can use the function multiple times for fine grain checking.

StaticTea uses [[https://semver.org/][Semantic Versioning]] with the added restrictions
that each version component is limited to three digits and all
components have at least one digit.

Below is typical useage:

template:

#+BEGIN_SRC
<--$ nextline version=version("1.20.3", "3.4.005") -->
<-- StaticTea current version is: {version}. -->
#+END_SRC

result:

#+BEGIN_SRC
<-- StaticTea current version is: 1.9.0. -->
#+END_SRC

If the current version is not between the min and max, a message
is output to standard error.  Example messages:

stdout:

#+BEGIN_SRC
tea.html(45): w22: The current version 4.0.2 is greater than the maximum
allowed verion of 3.4.005.

tea.html(45): w23: The current version 1.0.0 is less than the minumum
allowed verion of 1.20.3.
#+END_SRC

[[#contents][茶]]

* Run StaticTea
:PROPERTIES:
:CUSTOM_ID: run-statictea
:END:

You run StaticTea from the command line.

- Warning messages go to standard error.
- If you don't specify the result argument, the result goes to standard out.
- If you specify "stdin" for the template, the template comes
  from stdin.

The example below shows a typical invocation which specifies four
file arguments, the server json, the shared json, the template
and the result.

#+BEGIN_SRC
statictea \
  --server server.json \
  --shared shared.json \
  --template template.html \
  --result result.html
#+END_SRC

The StaticTea command line options:

- help -- show options and usage documentation.
- version -- outputs the version number.
- server -- the server json file(s), you can specify multiple.
- shared -- the shared json file(s), you can specify multiple.
- template -- the template file, or "stdin".
- result -- the result file, or standard out when not specified.
- update -- update the template replace blocks. See the
  [[#replace-command][Replace Command]].
- prepost -- add a command prefix and postfix, you can specify
  multiple. When you specify values, the defaults are no longer
  used. See the [[#prefix-postfix][Prefix Postfix]] section.

[[#contents][茶]]

* Miscellaneous
:PROPERTIES:
:CUSTOM_ID: miscellaneous
:END:

Miscellaneous topics:

- [[#warning-messages][Warning Messages]]
- [[#prefix-postfix][Prefix Postfix]]
- [[#encoding-and-line-endings][Encoding and Line Endings]]
- [[#log-file][Log File]]
- [[#limits][Limits]]
- [[#system-defaults][System Defaults]]

** Warning Messages
   :PROPERTIES:
   :CUSTOM_ID: warning-messages
   :END:

 When StaticTea detects a problem, a warning message is written to
 standard error, the problem is skipped, and processing
 continues.

 For example, if a variable in a replacement block is used but it
 doesn't exist, the bracketed variable remains as is in the
 result, and a message is output to standard error. There are many
 other potential warnings.

 It’s good style to change your template or json to be free of
 messages.

 Each warning message shows the file and line number where the
 problem happened.

 example messages:

 - tea.html(45): w1: Unknown server variable: teaMaster.
 - tea.html(45): w2: The postfix is missing.
 - tea.html(45): w3: The command line doesn't have a valid
   command, found: blocker.
 - tea.html(45): w4: Unknown system variable: t.asdf.
 - tea.html(45): w5: Server json file not found: server.json.
 - tea.html(45): w6: Unable to parse server.json.

 The statictea program returns 0 when no message gets
 output to standard error, else it returns 1.

 Example of running statictea when a variable is missing:

 template:

 #+BEGIN_SRC
 <!--$ block -->
 You're a {s.webmaster},
 I'm a {s.teaMaster}!
 <!--$ endblock -->
 #+END_SRC

 server json:

 #+BEGIN_SRC
 {
   "webmaster": "html wizard"
 }
 #+END_SRC

 stderr:

 #+BEGIN_SRC
 template.html(2): w1: Unknown server variable: s.teaMaster
 #+END_SRC

 result:

 #+BEGIN_SRC
 You're a html wizard,
 I'm a {s.teaMaster}!
 #+END_SRC

 You can write your own warning messages using the system t.output
 set to stderr. In the following example a warning message is
 written to standard error when the server admin variable is
 missing. When it is not missing nothing gets output.

 template:

 #+BEGIN_SRC
 <--$ nextline t.output = if( \-->
 <--$ : exists(admin), "skip", "stderr") -->
 warning: the admin variable is missing
 #+END_SRC

 [[#contents][茶]]

** Prefix Postfix
   :PROPERTIES:
   :CUSTOM_ID: prefix-postfix
   :END:

 You make the template commands look like comments tailored for
 your template file type. This allows you to edit the template
 using its native editor and run other native tools.  For example,
 you can edit a StaticTea html template with an html editor and
 validate it online with w3.org (https://validator.w3.org).

 Comment syntax varies depending on the type of template file and
 sometimes depending on the location within the file. StaticTea
 supports several varieties and you can specify others.

 You want to distinguish StaticTea commands from normal comments
 when you create your own. The convention is to add a $ as the
 last character of the prefix and only use $ with StaticTea
 commands and space for normal comments.

 Built in Prefixes:

 - html: <!--$ and -->
 - html: &lt;!--$ and --&gt; for textarea elements
 - bash: #$
 - config files: ;$
 - C++: //$
 - C language: ​/\star$ and \star​/

 You can define other comment types on the command line using the
 prepost option one or more times. When you specify your own
 prepost values, the defaults no longer exist so you have control
 of which prefixes get used.

 You separate the prefix from the postfix with one space and the
 postfix is optional.

 examples:

 #+BEGIN_SRC
 --prepost="@$ |"
 --prepost="[comment$ ]"
 --prepost="#[$ ]#"
 #+END_SRC

 [[#contents][茶]]

** Encoding and Line Endings
:PROPERTIES:
:CUSTOM_ID: encoding-and-line-endings
:END:

 Templates are utf-8 encoded.  Two line endings are supported on
 all platforms: LF, and CR/LF.  Line endings are preserved.  The
 template syntax only uses ascii except unicode characters may
 appear in quoted strings.

 [[#contents][茶]]

** Log File
   :PROPERTIES:
   :CUSTOM_ID: log-file
   :END:

 The log file contains timing, memory usage and low priority
 warnings. The log file, statictea.log, is created in the current
 folder (system default log location?).  Log information is
 appended to the file and it grows without bounds. Make sure to
 setup log rotation.

 [[#contents][茶]]

** Limits
 :PROPERTIES:
   :CUSTOM_ID: limits
   :END:

 There is no limit on the size of the template. However there are
 several limits on variables and commands.

 Having limits may seem restrictive but there are many reasons for
 them.

 - It makes it easier to verify the limits and to test the warning messages.
 - It's easier to optimize statictea's memory usage when the
   limits are known.
 - Engineering time is better spent on more general needs than
   supporting the rarely needed unlimited cases.
 - Defining limits tells the users how to best use the program.

 You can override the t.maxLine limit but not others. Here are
 the limits:

 - t.maxLines -- number of lines before the end block
   command. Useful when you forget to end the block. You can
   override this with bigger or smaller values.  Default 10.
 - t.maxRepeat -- maximum number of times to repeat a block.
 - Maximum command line length -- 1024 characters.
 - Maximum variable name length -- 64 characters.
 - Maximum literal string length -- 256 characters.
 - Maximum json file size -- xxx bytes.
 - Maximum number of items in a list -- 500 items.  Use multiple lists
   if you need more.

 [[#contents][茶]]

** System Defaults
   :PROPERTIES:
   :CUSTOM_ID: system-defaults
   :END:

 You can use the system variables in a replacement block to see
 their default values. The following example shows the default
 values of some of the system variables.

 template:

 #+BEGIN_SRC
 <!--$ block -->
 default t.content = {t.content}
 default t.local = {t.local}
 default t.maxLines = {t.maxLines}
 default t.output = {t.output}
 default t.repeat = {t.repeat}
 default t.server = {t.server}
 <!--$ endblock -->
 #+END_SRC

 result:

 #+BEGIN_SRC
 default t.content = ""?
 default t.local = {}
 default t.maxLines = 10
 default t.output = "template"
 default t.repeat = 1
 default t.server = {}
 #+END_SRC

 [[#contents][茶]]

 # You run the command below to make the table of contents. Copy
 # to scratch to remove the leading pound signs.
 # grep '^\* ' readme.org | grep -v ":notoc" | cut -c 3- | \
 # awk '{a = $0; gsub(" ", "-", a); printf "- [[#%s][%s]]\n", tolower(a), $0 }'
* Contents :notoc:
:PROPERTIES:
:CUSTOM_ID: contents
:END:

- [[#top][Top]]
- [[#advantages][Advantages]]
- [[#how-it-works][How it Works]]
- [[#commands][Commands]]
- [[#statements][Statements]]
- [[#variables][Variables]]
- [[#types][Types]]
- [[#functions][Functions]]
- [[#run-statictea][Run StaticTea]]
- [[#miscellaneous][Miscellaneous]]

* Tea Info                                                            :notoc:

Tea is the most popular manufactured drink consumed in the world,
equaling all others – including coffee, soft drinks, and alcohol
– combined. -- Wikipedia -- Macfarlane, Alan; Macfarlane, Iris
(2004). The Empire of Tea. The Overlook Press. p. 32. ISBN
978-1-58567-493-0.
