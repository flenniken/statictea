#+TITLE: StaticTea
A template processor and language.

StaticTea produces a file from a template and json data.

Example hello world html template:

#+BEGIN_SRC
<!--$ nextline -->
hello {s.name}
#+END_SRC

The associated json data:

#+BEGIN_SRC
{"name": "world"}
#+END_SRC

The result:

#+BEGIN_SRC
hello world
#+END_SRC

[[#contents][茶]] (table of contents at the bottom)

* Advantages
:PROPERTIES:
:CUSTOM_ID: advantages
:END:

You can view, edit and validate your templates with its normal
tools as if they were static pages.

The template designer has full control over the presentation.
You can change the look without changing the server.

You can share common template fragments between templates.

In a general sense StaticTea is a program and language for
formatting json.

[[#contents][茶]]

* How it Works
:PROPERTIES:
:CUSTOM_ID: how-it-works
:END:

You create a template and add commands around your variable
content. This defines the replacement blocks.

In the replacement blocks you add variables in brackets for
substitutions.

In the commands you format the variables for the replacement
blocks.

You specify the commands so they look like comments for your
template type.

[[#contents][茶]]

* Commands
:PROPERTIES:
:CUSTOM_ID: commands
:END:

A StaticTea command marks a replacement block in the template and
it provides a place for your code statements.

- [[#nextline-command][nextline]] -- make substitutions in the next line
- [[#block-command][block]] —- make substitutions in the next block of lines
- [[#replace-command][replace]] -— replace the block with a variable
- [[#endblock-command][endblock]] -- end the block and replace commands
- : ([[#continue-command][continue]]) -- continue a command
- # ([[#comment-command][comment]]) -- code comment

[[#contents][茶]]

** Nextline Command
:PROPERTIES:
:CUSTOM_ID: nextline-command
:END:

The nextline command targets the line following it for
replacement. The targeted line is called the replacement block.

The following example's replacement block contains two variables,
drink and drinkType.

template:

#+BEGIN_SRC
<!--$ nextline -->
Drink {s.drink} -- {s.drinkType} is my favorite.
#+END_SRC

server json:

#+BEGIN_SRC
{
  "drink": "tea",
  "drinkType": "Earl Grey"
}
#+END_SRC

result:

#+BEGIN_SRC
Drink tea -- Earl Grey is my favorite.
#+END_SRC

[[#contents][茶]]

** Block Command
:PROPERTIES:
:CUSTOM_ID: block-command
:END:

The block command targets multiple lines for replacement. The
replacement block starts after the command and continues until
the endblock line is found. It behaves like the nextline command
except with multiple lines.

In the following example the block has three lines. The block
contains three replacement variables, weekday, name and time.

template:

#+BEGIN_SRC
<!--$ block -->
Join our tea party on
{s.weekday} at {s.name}'s
house at {s.time}.
<!--$ endblock -->
#+END_SRC

server json:

#+BEGIN_SRC
{
  "weekday": "Friday",
  "name": "John",
  "time": "5:00 pm"
}
#+END_SRC

result:

#+BEGIN_SRC
Join our tea party on
Friday at John's
house at 5:00 pm.
#+END_SRC

[[#contents][茶]]

** Replace Command
:PROPERTIES:
:CUSTOM_ID: replace-command
:END:

The replace command's replacement block gets replaced with the
t.content variable. Here is a simple example:

template:

#+BEGIN_SRC
<!--$ replace t.content=h.header -->
<!--$ endblock -->
#+END_SRC

shared json:

#+BEGIN_SRC
{
  "header": "<!doctype html>\n<html lang=\"en\">\n"
}
#+END_SRC

result:

#+BEGIN_SRC
<!doctype html>
<html lang="en">
#+END_SRC

The above example generates the correct result but it doesn’t
work as a static template because the template is missing the
header lines.

You can add lines to the replace command's replacement block to
mirror the t.content variable so you can develop and test the
template as if it was a static file.

The replace command allows you to share common template lines between
templates and at the same time work with them as static pages.

Since you are duplicating content in the replacement block, when
you want to edit the shared text it will get out of sync. You can
update your templates using the [[#update-option][Update Option]].

If you don't assign the t.content variable, a warning is
generated, and the command behaves like a block command.  This is
good for testing changes you want to make to the shared value.

The following example uses a common header from the shared json data
and it mirrors it in the replacement block.

template:

#+BEGIN_SRC
<!--$ replace t.content=h.header -->
<!doctype html>
<html lang="en">
<!--$ endblock -—>
#+END_SRC

The shared variable may contain replacement content too.  Here is
an example of that:

template:

#+BEGIN_SRC
<!--$ replace t.content=h.header -->
<!DOCTYPE html>
<html lang="{s.languageCode}" dir="{s.languageDirection}">
<head>
<meta charset="UTF-8"/>
<title>{s.title}</title>
<--$ endblock -->
#+END_SRC

server json:

#+BEGIN_SRC
{
"languageCode": "en",
"languageDirection": "ltr",
"title": "Teas in England"
}
#+END_SRC

shared json:

#+BEGIN_SRC
{
  "header": "<!DOCTYPE html>
<html lang=\"{s.languageCode}\" dir=\"{s.languageDirection}\">
<head>
<meta charset=\"UTF-8\"/>
<title>{s.title}</title>\n"
}
#+END_SRC

result:

#+BEGIN_SRC
<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8"/>
<title>Teas in England</title>
#+END_SRC

[[#contents][茶]]

** Comment Command
:PROPERTIES:
:CUSTOM_ID: comment-command
:END:

You can comment templates with the comment command.  Comments
are line based and use the # character. They do not appear in the
result.

template:

#+BEGIN_SRC
<!--$ # The main tea groups. -->
There are five main groups of teas:
white, green, oolong, black, and pu'erh.
You make Oolong Tea in five time
intensive steps.
#+END_SRC

result:

#+BEGIN_SRC
There are five main groups of teas:
white, green, oolong, black, and pu'erh.
You make Oolong Tea in five time
intensive steps.
#+END_SRC

You can also comment in statements with # to the end of the line,
see the [[#syntax][Syntax]] section.


[[#contents][茶]]

** Continue Command
:PROPERTIES:
:CUSTOM_ID: continue-command
:END:

The continue command allows you to continue adding statements to
the nextline, block and replace commands.

In the following example the nextline command continues on a
second line and third line.

template:

#+BEGIN_SRC
$$ nextline
$$ : tea = "Earl Grey"
$$ : tea2 = "Masala chai"
{tea}, {tea2}
#+END_SRC

result:

#+BEGIN_SRC
Earl Grey, Masala chai
#+END_SRC

[[#contents][茶]]

** Endblock Command
:PROPERTIES:
:CUSTOM_ID: endblock-command
:END:

The endblock command ends the replacement block for the block and
replace commands. Only the endblock command ends them. All text
until the endblock is part of the replacement block. This
includes lines that look like commands. For example:

template:

#+BEGIN_SRC
<!--$ block -->
<!--$ # this is not a comment, just text -->
fake nextline
<!--$ nextline -->
<!--$ endblock -->
#+END_SRC

result:

#+BEGIN_SRC
<!--$ # this is not a comment, just text -->
fake nextline
<!--$ nextline -->
#+END_SRC

[[#contents][茶]]

* Replacement Block
:PROPERTIES:
:CUSTOM_ID: replacement-block
:END:

A replacement block is a group of contiguous lines in a template
between a command and its endblock. For the nextline case the
block is one line.

The block contains any number of bracketed variables for
substitution. Each string variable gets replaced with its value.

You can repeat the block to make lists and other repeating
content. You control how many times the block repeats with the
t.repeat variable.  The t.row counts the number of times the
block has repeated and you use its value to customize each
repeated block.

[[#contents][茶]]

* Statements
:PROPERTIES:
:CUSTOM_ID: statements
:END:

You format server variables by creating new variables with
statements.

A statement is an expression consisting of a variable, an equal
sign, and a right hand side. The right hand side is either
another variable, a string, a number or a function. Here are a
few example statements:

#+BEGIN_SRC
tea = "Earl Grey"
num = 5
t.repeat = 2
nameLen = len(s.name)
name = concat(substr(s.name, 0, 7), "...")
#+END_SRC

Statements are allowed on the nextline, block, continue and
replace commands.

All operations are done with functions. For example to add 1 to
t.row you use the add function.

#+BEGIN_SRC
num = add(t.row, 1)
#+END_SRC

Statements are executed from top to bottom. There is no
traditional "if" statement to control statement flow.

You can loop at the replacement block level and run the command's
statements multiple times using t.repeat, and vary the output using
t.row. Here is an example that loops three times and outputs 1, 2, 3.

template:

#+BEGIN_SRC
$$ nextline t.repeat = 3
$$ : count = t.row
{count}
#+END_SRC

result:

#+BEGIN_SRC
1
2
3
#+END_SRC

There is no traditional "print" function. You print the
replacement block, either to the template or to other places by
setting the t.output variable.

If there is a syntax error or a function generates a warning, the
statement is skipped.

You can continue a long statement on the next line by using a "+"
character at the end.

[[#contents][茶]]

* Syntax
:PROPERTIES:
:CUSTOM_ID: syntax
:END:

A template consists of command lines and non-command lines.  The
command lines are line oriented and they have the same form and
they are limited to 1024 bytes. There are no restrictions on the
non-command lines in a template.

Each command line is a comment to match the template type. The
beginning comment characters are called the prefix and the
optional ending comment characters are called the postfix. For
example, in an html template the prefix is "<!--$" and the
postfix is "-->". See [[#prefix-postfix][Prefix Postfix]] for more information.

From left to right a command line consists of:

- a prefix at column 1.
- a command name
- an optional statement
- an optional comment
- an optional plus continuation character
- an optional postfix
- the end of line, either \r\n or \n.

Here is another chart showing line components and where spaces
are allowed:

#+BEGIN_SRC
prefix
|     command  [statement]
|     |        |   [comment]
|     |        |   |       [continuation]
|     |        |   |       |[postfix]
|     |        |   |       ||  [newline]
|     |        |   |       ||  |
<!--$ nextline a=5 # set a +-->
     |        |            |
     |        |      no spaces at the end
     |        one required space
     optional spaces
#+END_SRC

The chart below shows a nextline command with three continuation
commands and three statements: a = 5, b = "tea" and c = "The Earl
of Grey".

#+BEGIN_SRC
prefix
|     command  statement
|     |        |         continuation
|     |        |         |
|     |        |         |postfix
|     | +------+         ||  newline
|     | |      |         ||  |
<!--$ nextline a = 5      -->
<!--$ : b = "tea"         -->
<!--$ : c = "The Earl of +-->
<!--$ : Grey"             -->
#+END_SRC

A statement starts one space after the command. You can use more
spaces but they are part of the statement. This is important when
you wrap quoted strings with a continuation.

Space isn't allowed before the prefix, after the continuation or
after the postfix or between the function name and its opening
parentheses. Here are a few single line examples:

#+BEGIN_SRC
$$ nextline
$$ nextline a=5
$$ nextline a = 5
$$ nextline num = len(s.tea_list)
$$ nextline num = len( s.tea_list )
$$nextline
$$   nextline
#+END_SRC

The statements may flow between lines by using the continuation
plus character. The following two nextline commands are
equivalent:

#+BEGIN_SRC
<!--$ nextline com = "Bigelow Tea Company" -->

<!--$ nextline com = "Big+-->
<!--$ : elow Tea Company" -->
#+END_SRC

You can have blank statements that do nothing.

#+BEGIN_SRC
$$ nextline
$$ :
$$ : a = 5
$$ : # comment
#+END_SRC

[[#contents][茶]]

* Variables
:PROPERTIES:
:CUSTOM_ID: variables
:END:

You use variables to add variable content to your template in its
replacement blocks. Each string variable gets replaced with it
value, the other variable types get replaced with their json
equivalent.

You use tea variables to control where the output goes, how many
times it repeats and other aspects controlling a command.

A variable name starts with a letter followed by letters, digits
and underscores limited to a total of 64 ASCII characters. Some
single letters are reserved, see the next section.

Local variables and tea variables, except row, args and version,
are cleared after processing each replacement block.

You can append a new variable to a list or dictionary but you
cannot change an existing variable.

[[#contents][茶]]

* Single Letter Variables
:PROPERTIES:
:CUSTOM_ID: single-letter-dictionaries
:END:

Statictea reserves single letters variable names f - u to refer
to important dictionaries. Five are currently used: g, h, l, s,
t.  You can use single letters a, b, c, d, e and v, w, x, y, z
for your variable names.

- f -- Reserved
- g -- [[#global-variables][Global Variables]]
- h -- [[#json-variables][Shared Json Variables]]
- i, j, k -- Reserved
- l -- [[#local-variables][Local Variables]]
- m, n, o, p, q, r -- Reserved
- s -- [[#json-variables][Server Json Variables]]
- t -- [[#tea-variables][Tea Variables]]
- u -- Reserved

[[#contents][茶]]

** Json Variables
:PROPERTIES:
:CUSTOM_ID: json-variables
:END:

You pass variables to the template in json files.

The variables are defined by the top level dictionary items. Each
item's key is the name of a variable and the item's value is
the variables' value.

There are two types of json files, the server json and the shared
json. The server file populates the s dictionary and the
shared file populates the h dictionary.

You can use multiple server and shared json files by specifying
multiple files on the command line. The files are processed
left to right.

The json null values get converted to the 0. Json True and False
get converted to 1 and 0.

To give full control of the presentation to the template
designers, the server json shouldn't contain any presentation
data.

The shared json is created and maintained by the template
designer for sharing common template fragments and other
presentation needs.

[[#contents][茶]]

** Local Variables
:PROPERTIES:
:CUSTOM_ID: local-variables
:END:

You create local variables with template statements.  They are
local to the command where they are defined. You do not have to
specify a prefix for local variables but you can use l. They are
stored in the l dictionary. The local variables are cleared and
recalculated for each repeated block.

[[#contents][茶]]

** Global Variables
:PROPERTIES:
:CUSTOM_ID: global-variables
:END:

Like local variables, you create global variables with template
statements.  All commands have access to them and they are stored
in the g dictionary.

[[#contents][茶]]

** Tea Variables
:PROPERTIES:
    :CUSTOM_ID: tea-variables
    :END:

The tea variables control how the replacement block works and
they provide information about the system.  They are stored in
the t dictionary.

Tea variables:

- [[#targs][t.args]] -- arguments passed on the command line
- [[#tcontent][t.content]] -- content of the replace block
- [[#tmaxrepeat][t.maxRepeat]] -- maximum number of times to repeat the block
- [[#tmaxlines][t.maxLines]] -- maximum number of replacement block lines allowed
  before the endblock
- [[#toutput][t.output]] -- where the block output goes
- [[#trepeat][t.repeat]] -- how many times the block repeats
- [[#trow][t.row]] -- the current index number of a repeating block
- [[#tversion][t.version]] -- the StaticTea version number

[[#contents][茶]]

*** t.args
:PROPERTIES:
:CUSTOM_ID: targs
:END:

The t.args variable contains the arguments passed to
statictea on the command line.

For example using the command line below results in a t.args
value shown:

#+BEGIN_SRC
statictea -l -s=server.json -j=shared.json \
  -s=server2.json -j=shared2.json \
  -p='abc$,def' -p='$$' \
  -t=template.html -r=result.html

t.args => {
  "help":0,
  "version":0,
  "update":0,
  "log":1,
  "serverList":["server.json","server2.json"],
  "sharedList":["shared.json","shared2.json"],
  "resultFilename":"result.html",
  "templateList":["template.html"],
  "logFilename":"",
  "prepostList":[["abc$","def"],["$$",""]]
}
#+END_SRC

[[#contents][茶]]

*** t.content
:PROPERTIES:
:CUSTOM_ID: tcontent
:END:

The t.content variable determines the content used for the
replace command's whole replacement block.

#+BEGIN_SRC
t.content = h.header
#+END_SRC

You use [[#update-option][Update Option]] to keep the template's blocks in sync with
their variables.

When t.content is not set, the command behaves like a block
command except a warning message is output. This is good for
testing changes you want to make to the shared value and the
warning reminds you to set the variable when you're done testing.

The variable only applies to the replace command. See the
[[#replace-command][replace command]] section for an example.

[[#contents][茶]]

*** t.maxRepeat
:PROPERTIES:
:CUSTOM_ID: tmaxrepeat
:END:

The t.maxRepeat variable determines the maximum times a block can
repeat.  The default is 100. You can increase it to repeat more
times. You cannot assign a number to t.repeat bigger than
maxRepeat.

It prevents the case where you mistakenly assign a giant number,
and it allows you to design your template to work well for the
expected range of blocks.

[[#contents][茶]]

*** t.maxLines
:PROPERTIES:
:CUSTOM_ID: tmaxlines
:END:

The t.maxLines variable determines the maximum lines in a
replacement block.

StaticTea reads lines looking for the endblock.  By default, if
it is not found in 50 lines, the 50 lines are used for the block
and a warning is output. This catches the case where you forget
the endblock command. You can increase or decrease the value.

#+BEGIN_SRC
<!--$ block t.maxLines=200 -->
#+END_SRC

[[#contents][茶]]

*** t.output
:PROPERTIES:
    :CUSTOM_ID: toutput
    :END:

The t.output variable determines where the block output goes.  By
default it goes to the result file.

- "result" -- to the result file (default)
- "stdout" -- to standard out
- "stderr" -- to standard error
- "log" -- to the log file
- "skip" -- to the bit bucket

[[#contents][茶]]

*** t.repeat
    :PROPERTIES:
    :CUSTOM_ID: trepeat
    :END:

The t.repeat variable is an integer that tells how many times to
repeat the block. A value of 0 means don't show the block at
all. If you don't set it, the block repeats one time.

Each time the block repeats the local variables get cleared then
recalculated.

The t.row variable counts the number of times the block repeats
and is used with t.repeat to customize each block.

You cannot assign a number bigger than t.maxRepeat to
t.repeat. You can set t.maxRepeat to anything you want, the
default is 100.

For the following example, the number of items in teaList is
assigned to the t.repeat variable which outputs the block five
times.

template:

#+BEGIN_SRC
<!--$ nextline t.repeat = len(s.teaList) -->
<!--$ : tea = get(s.teaList, t.row) -->
 * {tea}
#+END_SRC

server json:

#+BEGIN_SRC
{
"teaList": [
  "Black",
  "Green",
  "Oolong",
  "Sencha",
  "Herbal"
]
}
#+END_SRC

result:

#+BEGIN_SRC
 * Black
 * Green
 * Oolong
 * Sencha
 * Herbal
#+END_SRC

The following example builds an html select list of tea companies
with the Twinings company selected and it shows how to access
values from dictionaries.

template:

#+BEGIN_SRC
<h3>Tea Companies</h3>
<select>
<!--$ block t.repeat=len(s.companyList) -->
<!--$ : d = get(s.companyList, t.row) -->
<!--$ : selected = get(d, "selected", 0) -->
<!--$ : current = if1(selected, " selected=\"selected\"", "") -->
  <option{current}>{d.company}</option>
$$ endblock
</select>
#+END_SRC

server json:

#+BEGIN_SRC
{
"companyList": [
  {"company": "Lipton"},
  {"company": "Tetley"},
  {"company": "Twinings", "selected": 1},
  {"company": "American Tea Room"},
  {"company": "Argo Tea"},
  {"company": "Bigelow Tea Company"}
]
}
#+END_SRC

result:

#+BEGIN_SRC
<h3>Tea Companies</h3>
<select>
  <option>Lipton</option>
  <option>Tetley</option>
  <option selected="selected">Twinings</option>
  <option>American Tea Room</option>
  <option>Argo Tea</option>
  <option>Bigelow Tea Company</option>
</select>
#+END_SRC

Setting t.repeat to 0 is good for building test lists.

When you view the following template fragment in a browser it
shows one item in the list.

template:

#+BEGIN_SRC
<h3>Tea</h3>
<ul>
<!--$ nextline t.repeat = len(s.teaList)-->
<!--$ : tea = get(s.teaList, t.row) -->
  <li>{tea}</li>
</ul>
#+END_SRC

server json:

#+BEGIN_SRC
{
"teaList": [
  "Black",
  "Green",
  "Oolong",
  "Sencha",
  "Herbal"
]
}
#+END_SRC

To create a static page that has more products for better testing
you could create a test list of teas using t.repeat of 0. It will
appear when testing but not when generating the final result. In
the following example the test list will show: {tea}, Chamomile,
Chrysanthemum, White, and Puer.

template:

#+BEGIN_SRC
<h3>Tea</h3>
<ul>
<!--$ nextline t.repeat = len(s.teaList) -->
<!--$ : tea = get(s.teaList, t.row) -->
  <li>{tea}</li>
<!--$ block t.repeat = 0 -->
  <li>Chamomile</li>
  <li>Chrysanthemum</li>
  <li>White</li>
  <li>Puer</li>
<!--$ endblock -->
</ul>
#+END_SRC

result:

#+BEGIN_SRC
<h3>Tea</h3>
<ul>
  <li>Black</li>
  <li>Green</li>
  <li>Oolong</li>
  <li>Sencha</li>
  <li>Herbal</li>
</ul>
#+END_SRC

[[#contents][茶]]

*** t.row
    :PROPERTIES:
    :CUSTOM_ID: trow
    :END:

The t.row variable contains the current row number for blocks
that repeat. The row numbers start at 0 and increase.  You use it
to format lists and other repeating content in the template.

Here is an example using the row variable.  In the example the
row is used in three places.

template:

#+BEGIN_SRC
<ul>
<!--$ nextline t.repeat=len(s.companies)-->
<!--$ : company = get(s.companies, t.row) -->
<!--$ : num = add(t.row, 1) -->
  <li id="r{t.row}">{num}. {company}</li>
</ul>
#+END_SRC

server json:

#+BEGIN_SRC
{
  "companies": [
    "Mighty Leaf Tea",
    "Numi Organic Tea",
    "Peet's Coffee & Tea",
    "Red Diamond"
  ]
}
#+END_SRC

result:

#+BEGIN_SRC
<ul>
  <li id="r0">1. Mighty Leaf Tea</li>
  <li id="r1">2. Numi Organic Tea</li>
  <li id="r2">3. Peet's Coffee & Tea</li>
  <li id="r3">4. Red Diamond</li>
</ul>
#+END_SRC

[[#contents][茶]]

*** t.version
:PROPERTIES:
:CUSTOM_ID: tversion
:END:

The t.version variable contains the current version number of
StaticTea. See the [[#cmpversion][cmpVersion]] function for more information.

[[#contents][茶]]

* Types
:PROPERTIES:
:CUSTOM_ID: types
:END:

StaticTea variable types:

# Note: these links don't work in emacs but they work in Github.
- [[#string][string]]
- [[#int][int]]
- [[#float][float]]
- [[#dict][dict]]
- [[#list][list]]

[[#contents][茶]]

** String
:PROPERTIES:
:CUSTOM_ID: string
:END:

A string is an immutable sequence of unicode characters. You
define a literal string with double quotes.

The example below defines a literal string and assigns it to the
variable str:

#+BEGIN_SRC
str = "You can store black teas longer than green teas."
#+END_SRC

Strings are encoded as UTF-8 and invalid byte sequences generate
a warning.

Strings follow the same escaping rules as json strings.  You can
escape 8 special control characters using a slash followed by a
letter. Special escape letters:

- " -> quotation mark (U+0022)
- \ -> reverse solidus (U+005C)
- / -> solidus (U+002F)
- b -> backspace (U+0008)
- f -> form feed (U+000C)
- n -> line feed (U+000A)
- r -> carriage return (U+000D)
- t -> tab (U+0009)

Examples with escaping:

- "ending newline\n"
- "tab \t in the middle"
- "Mad Hatter: \\\"... you must have a cup of tea!\\\" - 'Alice In Wonderland'."
- "Unicode tea character '茶' is '\u8336'"
- "smiley face 😀 by escaping: \uD83D\uDE00."

You can enter any unicode value with \u and four hex digits or, for
values greater the U-FFFF, two pairs.  The two pairs are
called surrogate pairs.

#+BEGIN_SRC
The unicode code point U-8336 is 茶 and escaped is \u8336.
The unicode code point U-1F600 is 😀 and escaped is \uD83D\uDE00.
#+END_SRC

You can generate the surrogate pair for a unicode code point
using Russell Cottrell's surrogate pair calculator:
[[http://russellcottrell.com/greek/utilities/SurrogatePairCalculator.htm][
Surrogate Pair Calculator]].

[[#contents][茶]]

** Int
:PROPERTIES:
:CUSTOM_ID: int-type
:END:

An int is a 64 bit signed integer.  Plus signs are not used
with numbers.

Example numbers:

#+BEGIN_SRC
12345
0
-8823
42
#+END_SRC

[[#contents][茶]]

** Float
:PROPERTIES:
:CUSTOM_ID: float-type
:END:

A float is a 64 bit real number, it has a decimal point and
starts with a digit or minus sign.

Example floats:

#+BEGIN_SRC
3.14159
24.95
0.123
-34.0
#+END_SRC

[[#contents][茶]]

** Dict
:PROPERTIES:
:CUSTOM_ID: dict-type
:END:

The dict type is an ordered key value store with fast lookup. It
maps a string key to a value which can be any type. The dict is
ordered by insertion order.

- You create a dict in a json file or with the dict function.
- You append to a dict when you create new variables.
- You access dict items with variable names or with the get
  function.

In the following json data, the container element is a dictionary and
the d element is a dictionary.  The d dictionary has two key/value
pairs, ("x", 100) and ("y", 200).

server json:

#+BEGIN_SRC
{
  "a": 1,
  "b": 2,
  "d": {
    "x": 100,
    "y": 200
  }
}
#+END_SRC

If the key is a valid variable name, you can access it using dot
notation. For the json example above, you can access the data as:

#+BEGIN_SRC
s.a => 1
s.b => 2
s.d.x => 100
s.d.y => 200
#+END_SRC

Or you access the elements with the get function. The get
function has an optional default parameter and it works with keys
that don't look like variables.  Examples:

#+BEGIN_SRC
get(s, "a") => 1
get(s, "b") => 2
get(s, "d") => dict("x", 100, "y", 200)

d = get(s, "d")
get(d, "x") => 100
get(d, "y") => 200
#+END_SRC

You can append to a dictionary by creating a new variable. In the
following example the "a" and "str" elements are appended to the
d dictionary.

#+BEGIN_SRC
d = dict()
d.a = 5
d.str = "black"
d => {
  "a": 5,
  "str": "black"
}
#+END_SRC

[[#contents][茶]]

** List
:PROPERTIES:
:CUSTOM_ID: list-type
:END:

A list contains a sequence of values of any type.

You can create a list with the list function or with brackets:

#+BEGIN_SRC
a = list()
a = list(1)
a = list(1, 2, 3)
a = list("a", 5, "b")

a = []
a = [1]
a = [1, 2, 3]
a = ["a", 5, "b"]
#+END_SRC

You can append to a list by assigning a value to a variable with
the &= operator.  It will create the list if it doesn't exist. In
the example below, the first line creates the list variable then
assign "black" to it.  The second line appends "green":

#+BEGIN_SRC
teas &= "black"
teas &= "green"
teas => ["black", "green"]
#+END_SRC

The next example creates a g.names list from names contained in a
list of dictionaries:

#+BEGIN_SRC
$$ block
$$ : t.repeat = len(s.entries)
$$ : entry = get(s.entries, t.row)
$$ : g.names &= entry.name
$$ endblock
#+END_SRC

You can access list elements with the get function:

#+BEGIN_SRC
list = list(1, 3.3, "a")
get(list, 0) => 1
get(list, 1) => 3.3
get(list, 2) => "a"
get(list, 3, 99) => 99
#+END_SRC

[[#contents][茶]]

* Run StaticTea
:PROPERTIES:
:CUSTOM_ID: run-statictea
:END:

You run StaticTea from the command line. You specify the template
file to process along with the json data files and a result file
is generated.

- Warning messages go to standard error.
- If you don't specify the result file, the result goes to standard out.
- If you specify "stdin" for the template, the template comes
  from stdin.
- StaticTea returns success, return code 0, when there are no
  warning messages, else it returns 1.

The example below shows a typical invocation which specifies four
file arguments, the server json, the shared json, the template
and the result.

#+BEGIN_SRC
statictea \
  --server=server.json \
  --shared=shared.json \
  --template=template.html \
  --result=result.html
#+END_SRC

The StaticTea command line options:

- help -- show options and usage documentation.
- version -- outputs the version number.
- server -- the server json file(s), you can specify multiple.
- shared -- the shared json file(s), you can specify multiple.
- template -- the template file, or "stdin" for input from
  standard input.
- result -- the result file, or standard out when not specified.
- update -- update the template replace blocks. See the
  [[#replace-command][Replace Command]].
- prepost -- add a command prefix and postfix, you can specify
  multiple. When you specify values, the defaults are no longer
  used. See the [[#prefix-postfix][Prefix Postfix]] section.
- log - log to a file, see [[#log-file][Log File]] section.

[[#contents][茶]]

* Miscellaneous
:PROPERTIES:
:CUSTOM_ID: miscellaneous
:END:

Miscellaneous topics:

- [[#warning-messages][Warning Messages]]
- [[#prefix-postfix][Prefix Postfix]]
- [[#encoding-and-line-endings][Encoding and Line Endings]]
- [[#update-option][Update Option]]
- [[#logging][Logging]]
- [[#module-docs][Module Docs]]
- [[#html-formatted-json][HTML Formatted Json]]
- [[#nimble-tasks][Nimble Tasks]]
- [[#stf-runner][Stf Runner]]
- [[#example-templates][Example Templates]]

** Warning Messages
:PROPERTIES:
   :CUSTOM_ID: warning-messages
   :END:

When StaticTea detects a problem, a warning message is written to
standard error, the problem is skipped, and processing
continues.

For example, if a variable in a replacement block is used but it
doesn't exist, the bracketed variable remains as is in the
result, and a message is output to standard error. There are many
other potential warnings.

It’s good style to change your template to be free of messages.

Each warning message shows the file and line number where the
problem happened.

example messages:

- tea.html(0): w15: "Unable to parse the json file. Skipping file: test.json.
- tea.html(45): w61: No space after the command.
- tea.html(121): w52: The get function takes 2 or 3 parameters.
- tea.html(243): w36: The variable 'teaMaster' does not exist.
- tea.html(3044): w47: Concat parameter 45 is not a string."

Statement errors generate multi-line messages showing the
statement and problem location, for example:

#+BEGIN_SRC
template.html(16): w33: Expected a string, number, variable, list or function.
statement: tea = len("abc",)
                           ^
#+END_SRC

Warnings are suppressed after the first 10. When you reach the
limit you will see the message:

#+BEGIN_SRC
You reached the maximum number of warnings, suppressing the rest.
#+END_SRC

Statictea returns success, return code 0, when there are no
warning messages, else it returns 1.

Example of running statictea when a variable is missing:

template:

#+BEGIN_SRC
<!--$ block -->
You're a {s.webmaster},
I'm a {s.teaMaster}!
<!--$ endblock -->
#+END_SRC

server json:

#+BEGIN_SRC
{
 "webmaster": "html wizard"
}
#+END_SRC

stderr:

#+BEGIN_SRC
template.html(3): w58: The replacement variable doesn't exist: s.teaMaster.
#+END_SRC

result:

#+BEGIN_SRC
You're a html wizard,
I'm a {s.teaMaster}!
#+END_SRC

[[#contents][茶]]

** Prefix Postfix
:PROPERTIES:
   :CUSTOM_ID: prefix-postfix
   :END:

You make the template commands look like comments tailored for
your template file type. This allows you to edit the template
using its native editors and run other native tools.  For example,
you can edit a StaticTea html template with an html editor and
validate it online with w3.org's validator.

Comment syntax varies depending on the type of template file and
sometimes depending on the location within the file. StaticTea
supports several varieties and you can specify others.

You want to distinguish StaticTea commands from normal comments
when you create your own. The convention is to add a $ as the
last character of the prefix and only use $ with StaticTea
commands and space for normal comments.

Some file types, like markdown, don't support comments, for
them use $$.

Built in Prefixes:

- html: <!--$ and -->
- html: &lt;!--$ and --&gt; for textarea elements
- bash: #$
- org mode: # $
- config files: ;$
- C++: //$
- C language: ​/\star$ and \star​/
- markdown: $$

You can define other comment types on the command line using the
prepost option one or more times. When you specify your own
prepost values, the defaults no longer exist so you have control
of which prefixes get used.

You specify the prepost option with the prefix separated from the
postfix with a comma and the postfix is optional,
"prefix[,postfix]". A prefix and postfix contain 1 to 20 ASCII
characters including spaces but without control characters or
commas.

examples:

#+BEGIN_SRC
--prepost="pre$,post"
--prepost="a$,b"
--prepost="@$,|"
--prepost="#[$,]#"
--prepost="# $"
#+END_SRC

[[#contents][茶]]

** Encoding and Line Endings
:PROPERTIES:
:CUSTOM_ID: encoding-and-line-endings
:END:

Templates are treated as a stream of bytes. The embedded
statictea commands only use ASCII except for quoted strings which
are UTF-8 encoded.

Two line endings are supported on all platforms: LF, and CR/LF
and they are preserved.

The maximum command line length is 1024 bytes. There is
no limit on non-command lines.

Since line endings are preserved and there are no encoding or
line length restrictions on non-command lines, you can make
templates out of binary or mixed binary and text files like EPS
or PDF files.

[[#contents][茶]]

** Update Option
:PROPERTIES:
:CUSTOM_ID: update-option
:END:

The update option updates the template's replace blocks to
match their t.content text.  The text normally comes from the
shared template files but it doesn't have to.

You use this to keep the template blocks in sync with the shared
content so you can work with them as static pages.

If the t.content does not end with a newline, one is added so the
endcommand starts on a new line.

The following example shows a typical invocation:

#+BEGIN_SRC
statictea \
  --server=server.json \
  --shared=shared.json \
  --template=template.html \
  --update
#+END_SRC

See the [[#replace-command][replace command]] for update examples.

[[#contents][茶]]

** Logging
:PROPERTIES:
   :CUSTOM_ID: logging
   :END:

Statictea writes statistics to the log file.  Template commands
can also write to the log file.

Log information is appended to the file.  When the file size
exceeds 1 GB, a warning message is generated each time a template
is processed.

Logging is off by default. You turn it on with the log option.
If you don't specify a filename, the log lines are written to the
platform default location:

- Mac: ~/Library/log/statictea.log
- Other: ~/statictea.log

You can specify a full path. If you don't include path
information, the log is written to the current directory.

#+BEGIN_SRC
statictea --log=mylog.txt
#+END_SRC

When you write a replacement block to the log file, the template
file and line of the block appear there.

#+BEGIN_SRC
2021-12-07 22:03:59.908; statictea.nim(42); Starting: argv: @["-l=log.txt", "-t=tmpl.txt", "-r=result.txt"]
2021-12-07 22:03:59.908; statictea.nim(43); Version: 0.1.0
2021-12-07 22:03:59.909; tmpl.txt(2); ┌─────────┐
2021-12-07 22:03:59.909; tmpl.txt(3); │log block│
2021-12-07 22:03:59.909; tmpl.txt(4); └─────────┘
2021-12-07 22:03:59.910; statictea.nim(66); Warnings: 0
2021-12-07 22:03:59.910; statictea.nim(69); Return code: 0
2021-12-07 22:03:59.910; statictea.nim(70); Done
#+END_SRC

[[#contents][茶]]

** Module Docs
:PROPERTIES:
   :CUSTOM_ID: module-docs
   :END:

You can read the StaticTea source code documentation in Github
because it is formatted as github markdown. Statictea created the
markdown files from the source code's embedded doc comments.

- [[docs/index.md][StaticTea Source Docs]] --- Index to the
  source code documents.

The nimble *docsix* task builds the module index by running the
following process:

1. create a json file from the doc comments at the top of all the source files
2. format the json as markdown using the
   [[templates/nimModuleIndex.md][nimModuleIndex.md]] statictea
   template. Click the link then "View Raw".

The nimble *docs* task builds the module markdown files by running
the following process for each module:

1. create a json file of a module's docs using nim's jsondoc command
2. format the json as markdown using the [[templates/nimModule.md][nimModule.md]] statictea template

[[#contents][茶]]

** HTML Formatted Json
:PROPERTIES:
   :CUSTOM_ID: html-formatted-json
   :END:

The nim jsondoc command produces html formatted json data.  Our
desired final format is Github markdown so having html
presentation data in the json is a problem.

It was discovered that single paragraph comments are unformatted.
This is the basis for a workaround. You make all the
documentation look like one paragraph by inserting some symbols
in strategic places, then the json data does not contain html
formatting.

Workaround Rules:

- use @: at the beginning of lines, except the first line.
- use ~~~ to begin a code block
- use ~~~~ to end a code block
- use @{ for [ in an http link
- use }@ for ] in an http link
- use @@: for a : in an http link

#+BEGIN_SRC
[Semantic Versioning](https://semver.org/)
@{Semantic Versioning}@(https@@://semver.org/)
#+END_SRC

[[#contents][茶]]

** Nimble Tasks
:PROPERTIES:
   :CUSTOM_ID: nimble-tasks
   :END:

You can run commands to build, test, make docs etc. using nimble
task commands. Run them from the statictea root folder. The n
task lists the available tasks. Create an alias for nimble.

#+BEGIN_SRC
alias n='nimble --silent'
cd ~/code/statictea
n n
#+END_SRC

Here is the output:

#+BEGIN_SRC
n           Show available tasks.
t           Run all tests at once.
test        Run one or more tests; specify part of test filename.
b           Build the statictea exe.
docsall     Create all the docs, docsix, docs, readmefun, dot.
docs        Create one or more markdown docs; specify part of source filename.
docsix      Create markdown docs index.
json        Display one or more source file's json doc comments; specify part of name.
jsonix      Display markdown docs index json.
readmefun   Create the readme function section.
dot         Create a dependency graph of the StaticTea source.
dot2        Create a dependency graph of the system modules used by StaticTea.
tt          Compile and run t.nim.
tree        Show the project directory tree.
args        Show command line arguments.
br          Build the test runner.
rt        	Run one or more stf tests in testfiles; specify part of the name.
stf        	List stf tests with newest last.
newstf      Create new stf as a starting point for a new test.
runhelp     Show the runner help text with glow.
helpme      Show the statictea help text.
#+END_SRC

[[#contents][茶]]

** Stf Runner
:PROPERTIES:
   :CUSTOM_ID: stf-runner
   :END:

The Single Test File (stf) runner is a standalone program used
for testing command line applications. A stf file contains the
test which the runner executes to determine whether the test
passed. The stf files are designed to look good in markdown
readers.

The stf file contains instructions for creating files, running
files and comparing files. See the runner help message for more
information about stf files.

The testfiles folder contains statictea stf files.

- [[testfiles/readme.md][StaticTea Stf Files]] --- Index to the
  stf files.

[[#contents][茶]]

** Example Templates
:PROPERTIES:
   :CUSTOM_ID: example-templates
   :END:

You can examine simple self contained statictea templates
in the testfiles folder.

The [[#module-docs][Module Docs]] section has more complex examples.

[[#contents][茶]]

* Functions
:PROPERTIES:
:CUSTOM_ID: functions
:ORDERED:  t
:END:

Functions allow you to format variables for presentation.  They
return a value that you assign to a variable or pass to another
function.

This section was created from the nim source code by running the
readmefun nimble task which uses the StaticTea template
[[templates/readmeFuncSection.org][readmeFuncSection.org]].

List of functions:

# Dynamic Content Begins


# Dynamic Content Ends
* Contents :notoc:
:PROPERTIES:
:CUSTOM_ID: contents
:END:

# You run the command below to make the table of contents. Copy
# to scratch to remove the leading pound signs.
# grep '^\* ' readme.org | grep -v ":notoc" | cut -c 3- | \
# awk '{a = $0; gsub(" ", "-", a); printf "- [[#%s][%s]]\n", tolower(a), $0 }'

- [[#advantages][Advantages]]
- [[#how-it-works][How it Works]]
- [[#commands][Commands]]
- [[#replacement-block][Replacement Block]]
- [[#statements][Statements]]
- [[#syntax][Syntax]]
- [[#variables][Variables]]
- [[#single-letter-dictionaries][Single Letter Variables]]
- [[#types][Types]]
- [[#run-statictea][Run StaticTea]]
- [[#miscellaneous][Miscellaneous]]
- [[#functions][Functions]]

* Tea Info                                                            :notoc:

Tea is the most popular manufactured drink consumed in the world,
equaling all others – including coffee, soft drinks, and alcohol
– combined. -- Wikipedia -- Macfarlane, Alan; Macfarlane, Iris
(2004). The Empire of Tea. The Overlook Press. p. 32. ISBN
978-1-58567-493-0.
