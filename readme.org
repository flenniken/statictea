#+TITLE: StaticTea
A template processor and language.

StaticTea produces a file from a template and optional json and
code files.

Example hello world html template:

#+BEGIN_SRC
<!--$ nextline -->
hello {s.name}
#+END_SRC

The associated json data:

#+BEGIN_SRC
{"name": "world"}
#+END_SRC

The result:

#+BEGIN_SRC
hello world
#+END_SRC

[[#contents][茶]] (table of contents at the bottom)

* Advantages
:PROPERTIES:
:CUSTOM_ID: advantages
:END:

You can view, edit and validate your templates with its normal
tools as if they were static pages and at the same time share
common template fragments between templates.

The template designer has full control over the presentation
providing a clear separation of concerns. They can change the
look without changing the server.

[[#contents][茶]]

* How it Works
:PROPERTIES:
:CUSTOM_ID: how-it-works
:END:

You create a template and add command lines around your variable
content. This defines the replacement blocks.

In the replacement blocks you add variables in brackets for
substitutions.

In the commands you format the variables for the replacement
blocks.

You specify the commands so they look like comments for your
template type.

[[#contents][茶]]

* Commands
:PROPERTIES:
:CUSTOM_ID: commands
:END:

A StaticTea command marks a replacement block in the template and
it provides a place for your code statements.

- [[#nextline-command][nextline]] -- make substitutions in the next line
- [[#block-command][block]] —- make substitutions in the next block of lines
- [[#replace-command][replace]] -— replace the block with a variable
- [[#endblock-command][endblock]] -- end the block and replace commands
- : ([[#continue-command][continue]]) -- continue a command
- # ([[#comment-command][comment]]) -- code comment

[[#contents][茶]]

** Nextline Command
:PROPERTIES:
:CUSTOM_ID: nextline-command
:END:

The nextline command targets the line following it for
replacement. The targeted line is called the replacement block.

The following example's replacement block contains two variables,
drink and drinkType.

template:

#+BEGIN_SRC
<!--$ nextline -->
Drink {s.drink} -- {s.drinkType} is my favorite.
#+END_SRC

server json:

#+BEGIN_SRC
{
  "drink": "tea",
  "drinkType": "Earl Grey"
}
#+END_SRC

result:

#+BEGIN_SRC
Drink tea -- Earl Grey is my favorite.
#+END_SRC

[[#contents][茶]]

** Block Command
:PROPERTIES:
:CUSTOM_ID: block-command
:END:

The block command targets multiple lines for replacement. The
replacement block starts after the command and continues until
the endblock line is found. It behaves like the nextline command
except with multiple lines.

In the following example the block has three lines. The block
contains three replacement variables, weekday, name and time.

template:

#+BEGIN_SRC
<!--$ block -->
Join our tea party on
{s.weekday} at {s.name}'s
house at {s.time}.
<!--$ endblock -->
#+END_SRC

server json:

#+BEGIN_SRC
{
  "weekday": "Friday",
  "name": "John",
  "time": "5:00 pm"
}
#+END_SRC

result:

#+BEGIN_SRC
Join our tea party on
Friday at John's
house at 5:00 pm.
#+END_SRC

[[#contents][茶]]

** Replace Command
:PROPERTIES:
:CUSTOM_ID: replace-command
:END:

The replace command's replacement block gets replaced with the
t.content variable. Here is a simple example:

template:

#+BEGIN_SRC
<!--$ replace t.content = o.header -->
<!--$ endblock -->
#+END_SRC

shared code file:

#+BEGIN_SRC
o.header = """
<!doctype html>
<html lang="en">
"""
#+END_SRC

result:

#+BEGIN_SRC
<!doctype html>
<html lang="en">
#+END_SRC

The above example generates the correct result but it doesn’t
work as a static template because the template is missing the
header lines.

You can add lines to the replace command's replacement block to
mirror the t.content variable so you can develop and test the
template as if it was a static file.

The replace command allows you to share common template lines between
templates and at the same time work with them as static pages.

Since you are duplicating content in the replacement block, when
you want to edit the shared text it will get out of sync. You can
update your templates using the [[#update-option][Update Option]].

If you don't assign the t.content variable, a warning is
generated, and the command behaves like a block command.  This is
good for testing changes you want to make to the shared value.

The following example uses a common header from the shared code
file and it mirrors it in the replacement block.

template:

#+BEGIN_SRC
<!--$ replace t.content = o.header -->
<!doctype html>
<html lang="en">
<!--$ endblock -—>
#+END_SRC

The shared variable may contain replacement content too.  Here is
an example of that:

template:

#+BEGIN_SRC
<!--$ replace t.content = o.header -->
<!DOCTYPE html>
<html lang="{s.languageCode}" dir="{s.languageDirection}">
<head>
<meta charset="UTF-8"/>
<title>{s.title}</title>
<--$ endblock -->
#+END_SRC

server json:

#+BEGIN_SRC
{
"languageCode": "en",
"languageDirection": "ltr",
"title": "Teas in England"
}
#+END_SRC

shared code file:

#+BEGIN_SRC
o.header = """
<!DOCTYPE html>
<html lang="{s.languageCode}" dir="{s.languageDirection}">
<head>
<meta charset="UTF-8"/>
<title>{s.title}</title>
"""
#+END_SRC

result:

#+BEGIN_SRC
<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8"/>
<title>Teas in England</title>
#+END_SRC

[[#contents][茶]]

** Comment Command
:PROPERTIES:
:CUSTOM_ID: comment-command
:END:

You can comment templates with the comment command.  Comments
are line based and use the # character. They do not appear in the
result.

template:

#+BEGIN_SRC
<!--$ # The main tea groups. -->
There are five main groups of teas:
white, green, oolong, black, and pu'erh.
You make Oolong Tea in five time
intensive steps.
#+END_SRC

result:

#+BEGIN_SRC
There are five main groups of teas:
white, green, oolong, black, and pu'erh.
You make Oolong Tea in five time
intensive steps.
#+END_SRC

You can also comment in statements with # to the end of the line,
see the [[#syntax][Syntax]] section.


[[#contents][茶]]

** Continue Command
:PROPERTIES:
:CUSTOM_ID: continue-command
:END:

The continue command allows you to continue adding statements to
the nextline, block and replace commands.

In the following example the nextline command continues on a
second line and third line.

template:

#+BEGIN_SRC
$$ nextline
$$ : tea = "Earl Grey"
$$ : tea2 = "Masala chai"
{tea}, {tea2}
#+END_SRC

result:

#+BEGIN_SRC
Earl Grey, Masala chai
#+END_SRC

[[#contents][茶]]

** Endblock Command
:PROPERTIES:
:CUSTOM_ID: endblock-command
:END:

The endblock command ends the replacement block for the block and
replace commands. Only the endblock command ends them. All text
until the endblock is part of the replacement block. This
includes lines that look like commands. For example:

template:

#+BEGIN_SRC
<!--$ block -->
<!--$ # this is not a comment, just text -->
fake nextline
<!--$ nextline -->
<!--$ endblock -->
#+END_SRC

result:

#+BEGIN_SRC
<!--$ # this is not a comment, just text -->
fake nextline
<!--$ nextline -->
#+END_SRC

[[#contents][茶]]

* Replacement Block
:PROPERTIES:
:CUSTOM_ID: replacement-block
:END:

A replacement block is a group of contiguous lines in a template
between a command and its endblock. For the nextline command the
block is one line.

The block contains any number of bracketed variables for
substitution. Each variable gets replaced with its value.

You can repeat the block to make lists and other repeating
content. You control how many times the block repeats with the
t.repeat variable.  You can skip and exit early with the return
function. The t.row counts the number of times the block has
repeated and you use its value to customize each repeated block.
See [[#trow][t.row]] for an example.

[[#contents][茶]]

* Statements
:PROPERTIES:
:CUSTOM_ID: statements
:END:

You create a new variable with a statement. A statement is an
expression consisting of a variable, an operator and a right hand
side.

The operator is an equal sign or an "&=". The equal sign appends
to a dictionary and the &= appends to a list.

The right hand side is either a variable, a string, a
number, a list or a boolean expression.

Here are a few example statements:

#+BEGIN_SRC
tea = "Earl Grey"
num = 5
t.repeat = 2
b &= 3
nums = [1, 2, 3]
nameLen = len(s.name)
name = concat(substr(s.name, 0, 7), "...")
#+END_SRC

Statements are allowed on the nextline, block, continue and
replace commands.

All operations are done with functions. For example, to add 1 to
t.row you use the add function.

#+BEGIN_SRC
num = add(t.row, 1)
#+END_SRC

Statements are executed from top to bottom. You can use the warn
function to exit a statement early and use the return function to
exit a command early.

You can loop at the replacement block level and run the command's
statements multiple times using t.repeat, and vary the output using
t.row. Here is an example that loops three times and outputs 0, 1, 2.

template:

#+BEGIN_SRC
$$ nextline t.repeat = 3
{t.row}
#+END_SRC

result:

#+BEGIN_SRC
0
1
2
#+END_SRC

You have control over where the replacement block goes, either
the result file, standard out, standard error, or the log file
using the t.output variable.

If there is a syntax error or a function generates a warning, the
statement is skipped.

You can continue a long statement on the next line by using a "+"
character at the end.

You can have a bare if function on a statement which is an
exception to the rule, see [[#if-functions][If Functions]].

[[#contents][茶]]

* Syntax
:PROPERTIES:
:CUSTOM_ID: syntax
:END:

A template consists of command lines and non-command lines.  The
command lines are line oriented and they have the same form and
they are limited to 1024 bytes. There are no restrictions on the
non-command lines in a template.

Each command line is a comment to match the template type. The
beginning comment characters are called the prefix and the
optional ending comment characters are called the postfix. For
example, in an html template the prefix is "<!--$" and the
postfix is "-->". See [[#prefix-postfix][Prefix Postfix]] for more information.

From left to right a command line consists of:

- a prefix at column 1.
- a command name
- an optional statement
- an optional comment
- an optional plus continuation character
- an optional postfix
- the end of line, either \r\n or \n.

Here is a chart showing line components and where spaces
are allowed:

#+BEGIN_SRC
prefix
|     command  [statement]
|     |        |   [comment]
|     |        |   |       [continuation]
|     |        |   |       |[postfix]
|     |        |   |       ||  [newline]
|     |        |   |       ||  |
<!--$ nextline a=5 # set a +-->
     |        |            |
     |        |      no spaces at the end
     |        one required space
     optional spaces
#+END_SRC

The chart below shows a nextline command with three continuation
commands and three statements: a = 5, b = "tea" and c = "The Earl
of Grey".

#+BEGIN_SRC
prefix
|     command  statement
|     |        |         continuation
|     |        |         |
|     |        |         |postfix
|     | +------+         ||  newline
|     | |      |         ||  |
<!--$ nextline a = 5      -->
<!--$ : b = "tea"         -->
<!--$ : c = "The Earl of +-->
<!--$ : Grey"             -->
#+END_SRC

A statement starts one space after the command. You can use more
spaces but they are part of the statement. This is important when
you wrap quoted strings with a continuation.

Space isn't allowed before the prefix, after the continuation or
after the postfix or between the function name and its opening
parentheses. Here are a few single line examples:

#+BEGIN_SRC
$$ nextline
$$ nextline a=5
$$ nextline a = 5
$$ nextline num = len(s.tea_list)
$$ nextline  num = len( s.tea_list )
$$nextline
$$   nextline
#+END_SRC

The statements may flow between lines by using the continuation
plus character. The following two nextline commands are
equivalent:

#+BEGIN_SRC
<!--$ nextline com = "Bigelow Tea Company" -->

<!--$ nextline com = "Big+-->
<!--$ : elow Tea Company" -->
#+END_SRC

You can have blank statements that do nothing.

#+BEGIN_SRC
$$ nextline
$$ :
$$ : a = 5
$$ : # comment
#+END_SRC

[[#contents][茶]]

* Variables
:PROPERTIES:
:CUSTOM_ID: variables
:END:

You use variables to add variable content to your template in its
replacement blocks. A string variable gets replaced with its
value, a function variable with its name, and the other variable
types get replaced with their json equivalent.

In the example below, "name" and "teas" are variables that are
defined in the command. Both variables are used in the
replacement block.

Template:

#+BEGIN_SRC
$$ block
$$ : name = "Eary Grey"
$$ : teas = list("Black", "Green", "Oolong")
Popular tea: {name}
Available kinds: {teas}
$$ endblock
#+END_SRC

Result:

#+BEGIN_SRC
Popular tea: Earl Grey
Available kinds: ["Black","Green","Oolong"]
#+END_SRC

You use variables in the t dictionary (tea variables), to
control where the output goes, how many times it repeats and
other aspects controlling a command.

A variable name starts with a letter followed by letters, digits
and underscores limited to a total of 64 ASCII characters. Some
single letters are reserved for important dictionaries, see the
next section.

#+BEGIN_SRC
a = 5
last_letter = "z"
nameLen = len(s.name)
#+END_SRC

Local variables and writable tea variables are cleared after
processing each replacement block.

You can append a new variable to a list or dictionary but you
cannot change an existing variable.

A dot name is a fully qualified variable name where variables are
connected with dots.

You can combine up to five variable names together to make a dot
name. For example:

#+BEGIN_SRC
s.tea.black.earlgrey.vanilla
#+END_SRC

[[#contents][茶]]

* Single Letter Dictionaries
:PROPERTIES:
:CUSTOM_ID: single-letter-dictionaries
:END:

All variables are stored in one of the reserved one letter top
level dictionaries f - u. Six are currently used: f, g, l, o, s, t.

The server json variables are stored in the s dictionary. You
reference them with "s.", for example:

#+BEGIN_SRC
s.name
s.address
#+END_SRC

A local variable is stored in the l (local) dictionary. L is
implied for an unqualified name.

You can use the unreserved letters a, b, c, d, e and v, w, x, y, z
for your variable names.

Reserved single letter variables:

- f -- [[#function-variables][Function Variables]]
- g -- [[#global-variables][Global Variables]]
- h, i, j, k -- Reserved
- l -- [[#local-variables][Local Variables]]
- m, n -- Reserved
- o -- [[#code-variables][Shared Code Variables]]
- p, q, r -- Reserved
- s -- [[#json-variables][Server Json Variables]]
- t -- [[#tea-variables][Tea Variables]]
- u -- Reserved

[[#contents][茶]]

** Json Variables
:PROPERTIES:
:CUSTOM_ID: json-variables
:END:

You pass variables from the server to the template in json files.

The variables are defined by the top level dictionary items. Each
item's key is the name of a variable and the item's value is
the variables' value.

You can use multiple server json files by specifying multiple
files on the command line. The files are processed left to right.

The server json files populate the s dictionary.

The json null values get converted to the 0.

To give full control of the presentation to the template
designers, the server json shouldn't contain any presentation
data.

** Code Variables
:PROPERTIES:
:CUSTOM_ID: code-variables
:END:

You create code variables with statements in code files. Code
files are good for sharing common template variables between
templates. The variables go in the o dictionary.

[[#contents][茶]]

** Local Variables
:PROPERTIES:
:CUSTOM_ID: local-variables
:END:

You create local variables with template statements.  They are
local to the command where they are defined. You do not have to
specify a prefix for local variables but you can use l. They are
stored in the l dictionary. The local variables are cleared and
recalculated for each repeated block.

#+BEGIN_SRC
a = 5
pot = "black"
l.tea = "earl grey"
#+END_SRC

[[#contents][茶]]

** Function Variables
:PROPERTIES:
:CUSTOM_ID: function-variables
:END:

All the built in functions exist in the f dictionary.  See [[#func-type][Func Type]]
for more information.

#+BEGIN_SRC
myCmp = cmp
a = myCmp(7,2) => 1
#+END_SRC

[[#contents][茶]]

** Global Variables
:PROPERTIES:
:CUSTOM_ID: global-variables
:END:

Like local variables, you create global variables with template
statements.  All commands have access to them and they are stored
in the g dictionary.

#+BEGIN_SRC
g.names &= entry.name
#+END_SRC

[[#contents][茶]]

** Tea Variables
:PROPERTIES:
    :CUSTOM_ID: tea-variables
    :END:

The tea variables control how the replacement block works and
they provide information about the system.  They are stored in
the t dictionary.

Tea variables:

- [[#targs][t.args]] -- arguments passed on the command line
- [[#tcontent][t.content]] -- content of the replace block
- [[#tmaxrepeat][t.maxRepeat]] -- maximum number of times to repeat the block
- [[#tmaxlines][t.maxLines]] -- maximum number of replacement block lines allowed
  before the endblock
- [[#toutput][t.output]] -- where the block output goes
- [[#trepeat][t.repeat]] -- how many times the block repeats
- [[#trow][t.row]] -- the current index number of a repeating block
- [[#tversion][t.version]] -- the StaticTea version number

[[#contents][茶]]

*** t.args
:PROPERTIES:
:CUSTOM_ID: targs
:END:

The read-only t.args variable contains the arguments passed to
statictea on the command line.

For example using the command line below results in a t.args
value shown:

#+BEGIN_SRC
statictea -l -s server.json -o codefile.tea \
  -s server2.json -o codefile2.tea \
  -p 'abc$,def' -p '$$' \
  -t template.html -r result.html

t.args => {
  "help":0,
  "version":0,
  "update":0,
  "log":1,
  "serverList":["server.json","server2.json"],
  "codeList":["codefile.tea","codefile2.tea"],
  "resultFilename":"result.html",
  "templateFilename":"template.html",
  "logFilename":"",
  "prepostList":[["abc$","def"],["$$",""]]
}
#+END_SRC

[[#contents][茶]]

*** t.content
:PROPERTIES:
:CUSTOM_ID: tcontent
:END:

The t.content variable determines the content used for the
replace command's whole replacement block.

#+BEGIN_SRC
t.content = h.header
#+END_SRC

You use [[#update-option][Update Option]] to keep the template's blocks in sync with
their variables.

When t.content is not set, the command behaves like a block
command except a warning message is output. This is good for
testing changes you want to make to the shared value and the
warning reminds you to set the variable when you're done testing.

The variable only applies to the replace command. See the
[[#replace-command][replace command]] section for an example.

[[#contents][茶]]

*** t.maxRepeat
:PROPERTIES:
:CUSTOM_ID: tmaxrepeat
:END:

The t.maxRepeat variable determines the maximum times a block can
repeat.  The default is 100. You can increase it to repeat more
times. You cannot assign a number to t.repeat bigger than
maxRepeat.

It prevents the case where you mistakenly assign a giant number,
and it allows you to design your template to work well for the
expected range of blocks.

[[#contents][茶]]

*** t.maxLines
:PROPERTIES:
:CUSTOM_ID: tmaxlines
:END:

The t.maxLines variable determines the maximum lines in a
replacement block.

StaticTea reads lines looking for the endblock.  By default, if
it is not found in 50 lines, the 50 lines are used for the block
and a warning is output. This catches the case where you forget
the endblock command. You can increase or decrease the value.

#+BEGIN_SRC
<!--$ block t.maxLines=200 -->
#+END_SRC

[[#contents][茶]]

*** t.output
:PROPERTIES:
    :CUSTOM_ID: toutput
    :END:

The t.output variable determines where the block output goes.  By
default it goes to the result file.

- "result" -- to the result file (default)
- "stdout" -- to standard out
- "stderr" -- to standard error
- "log" -- to the log file
- "skip" -- to the bit bucket

[[#contents][茶]]

*** t.repeat
    :PROPERTIES:
    :CUSTOM_ID: trepeat
    :END:

The t.repeat variable is an integer that tells how many times to
repeat the block. A value of 0 means don't show the block at
all. If you don't set it, the block repeats one time.

Each time the block repeats the local variables get cleared then
recalculated.

The t.row variable counts the number of times the block repeats
and is used with t.repeat to customize each block.

You cannot assign a number bigger than t.maxRepeat to
t.repeat. You can set t.maxRepeat to anything you want, the
default is 100.

When you set t.repeat to 0, the command exits.  The commands'
statements following are not run. This makes a difference when
the command has side effects, like setting global variables. You
can move the "t.repeat = 0" line around to compensate.

For the following example, the number of items in teaList is
assigned to the t.repeat variable which outputs the block five
times.

template:

#+BEGIN_SRC
<!--$ nextline t.repeat = len(s.teaList) -->
<!--$ : tea = get(s.teaList, t.row) -->
 * {tea}
#+END_SRC

server json:

#+BEGIN_SRC
{
"teaList": [
  "Black",
  "Green",
  "Oolong",
  "Sencha",
  "Herbal"
]
}
#+END_SRC

result:

#+BEGIN_SRC
 * Black
 * Green
 * Oolong
 * Sencha
 * Herbal
#+END_SRC

The following example builds an html select list of tea companies
with the Twinings company selected and it shows how to access
values from dictionaries.

template:

#+BEGIN_SRC
<h3>Tea Companies</h3>
<select>
<!--$ block t.repeat=len(s.companyList) -->
<!--$ : d = get(s.companyList, t.row) -->
<!--$ : selected = get(d, "selected", false) -->
<!--$ : current = if(selected, " selected=\"selected\"", "") -->
  <option{current}>{d.company}</option>
$$ endblock
</select>
#+END_SRC

server json:

#+BEGIN_SRC
{
"companyList": [
  {"company": "Lipton"},
  {"company": "Tetley"},
  {"company": "Twinings", "selected": true},
  {"company": "American Tea Room"},
  {"company": "Argo Tea"},
  {"company": "Bigelow Tea Company"}
]
}
#+END_SRC

result:

#+BEGIN_SRC
<h3>Tea Companies</h3>
<select>
  <option>Lipton</option>
  <option>Tetley</option>
  <option selected="selected">Twinings</option>
  <option>American Tea Room</option>
  <option>Argo Tea</option>
  <option>Bigelow Tea Company</option>
</select>
#+END_SRC

Setting t.repeat to 0 is good for building test lists.

When you view the following template fragment in a browser it
shows one item in the list.

template:

#+BEGIN_SRC
<h3>Tea</h3>
<ul>
<!--$ nextline t.repeat = len(s.teaList)-->
<!--$ : tea = get(s.teaList, t.row) -->
  <li>{tea}</li>
</ul>
#+END_SRC

server json:

#+BEGIN_SRC
{
"teaList": [
  "Black",
  "Green",
  "Oolong",
  "Sencha",
  "Herbal"
]
}
#+END_SRC

To create a static page that has more products for better testing
you could create a test list of teas using t.repeat of 0. It will
appear when testing but not when generating the final result. In
the following example the test list will show: {tea}, Chamomile,
Chrysanthemum, White, and Puer.

template:

#+BEGIN_SRC
<h3>Tea</h3>
<ul>
<!--$ nextline t.repeat = len(s.teaList) -->
<!--$ : tea = get(s.teaList, t.row) -->
  <li>{tea}</li>
<!--$ block t.repeat = 0 -->
  <li>Chamomile</li>
  <li>Chrysanthemum</li>
  <li>White</li>
  <li>Puer</li>
<!--$ endblock -->
</ul>
#+END_SRC

result:

#+BEGIN_SRC
<h3>Tea</h3>
<ul>
  <li>Black</li>
  <li>Green</li>
  <li>Oolong</li>
  <li>Sencha</li>
  <li>Herbal</li>
</ul>
#+END_SRC

[[#contents][茶]]

*** t.row
:PROPERTIES:
    :CUSTOM_ID: trow
    :END:

The t.row read-only variable counts the number of times the
replacement block repeats.

You use it to format lists and other repeating content in the
template.

Here is an example using the row variable.  In the example, row
is used in three places.

template:

#+BEGIN_SRC
<ul>
<!--$ nextline t.repeat=len(s.companies)-->
<!--$ : company = get(s.companies, t.row) -->
<!--$ : num = add(t.row, 1) -->
  <li id="r{t.row}">{num}. {company}</li>
</ul>
#+END_SRC

server json:

#+BEGIN_SRC
{
  "companies": [
    "Mighty Leaf Tea",
    "Numi Organic Tea",
    "Peet's Coffee & Tea",
    "Red Diamond"
  ]
}
#+END_SRC

result:

#+BEGIN_SRC
<ul>
  <li id="r0">1. Mighty Leaf Tea</li>
  <li id="r1">2. Numi Organic Tea</li>
  <li id="r2">3. Peet's Coffee & Tea</li>
  <li id="r3">4. Red Diamond</li>
</ul>
#+END_SRC

[[#contents][茶]]

*** t.version
:PROPERTIES:
:CUSTOM_ID: tversion
:END:

The read-only t.version variable contains the current version
number of StaticTea. See the [[#cmpversion][cmpVersion]] function for more
information.

[[#contents][茶]]

* Types
:PROPERTIES:
:CUSTOM_ID: types
:END:

StaticTea variable types:

- [[#string-type][String Type]]
- [[#int-type][Int Type]]
- [[#float-type][Float Type]]
- [[#dict-type][Dict Type]]
- [[#list-type][List Type]]
- [[#bool-type][Bool Type]]
- [[#func-type][Func Type]]

[[#contents][茶]]

** String Type
:PROPERTIES:
:CUSTOM_ID: string-type
:END:

A string is an immutable sequence of unicode characters.

You define a literal string with double quotes. The example below
defines a literal string and assigns it to the variable str:

#+BEGIN_SRC
str = "black teas vs. green teas"
#+END_SRC

Strings are encoded as UTF-8 and invalid byte sequences generate
a warning.

Strings follow the same escaping rules as json strings.  You can
escape 8 special control characters using a slash followed by a
letter. Special escape letters:

- " -- quotation mark (U+0022)
- \ -- reverse solidus (U+005C)
- / -- solidus (U+002F)
- b -- backspace (U+0008)
- f -- form feed (U+000C)
- n -- line feed (U+000A)
- r -- carriage return (U+000D)
- t -- tab (U+0009)

Examples with escaping:

- "ending newline\n"
- "tab \t in the middle"
- "Mad Hatter: \\\"... you must have a cup of tea!\\\" - 'Alice In Wonderland'."
- "Unicode tea character '茶' is '\u8336'"
- "smiley face 😀 by escaping: \uD83D\uDE00."

You can enter any unicode value with \u and four hex digits or, for
values greater the U-FFFF, two pairs.  The two pairs are
called surrogate pairs.

#+BEGIN_SRC
The unicode code point U-8336 is 茶 and escaped is \u8336.
The unicode code point U-1F600 is 😀 and escaped is \uD83D\uDE00.
#+END_SRC

You can generate the surrogate pair for a unicode code point
using Russell Cottrell's surrogate pair calculator:
[[http://russellcottrell.com/greek/utilities/SurrogatePairCalculator.htm][
Surrogate Pair Calculator]].

[[#contents][茶]]

** Int Type
:PROPERTIES:
:CUSTOM_ID: int-type
:END:

An int is a 64 bit signed integer.  Plus signs are not used
with numbers. You can use underscores in long number literals to
make them more readable.

Example numbers:

#+BEGIN_SRC
12345
0
-8823
42
1_234_567
#+END_SRC

[[#contents][茶]]

** Float Type
:PROPERTIES:
:CUSTOM_ID: float-type
:END:

A float is a 64 bit real number, it has a decimal point and
starts with a digit or minus sign. You can use underscores in
long number literals to make them more readable.

Example floats:

#+BEGIN_SRC
3.14159
24.95
0.123
-34.0
1_234.56
#+END_SRC

[[#contents][茶]]

** Dict Type
:PROPERTIES:
:CUSTOM_ID: dict-type
:END:

The dict type is an ordered key value store with fast lookup. It
maps a string key to a value which can be any type. The dict is
ordered by insertion order.

- You create a dict in a json file or with the dict function.
- You append to a dict when you create new variables with a statement.
- You access dict items with dot names or with the get
  function.

In the following json data, the container element is a dictionary and
the d element is a dictionary.  The d dictionary has two key/value
pairs, ("x", 100) and ("y", 200).

server json:

#+BEGIN_SRC
{
  "a": 1,
  "b": 2,
  "d": {
    "x": 100,
    "y": 200
  }
}
#+END_SRC

If the key is a valid variable name, you can access it using dot
notation. For the json example above, you can access the data as:

#+BEGIN_SRC
s.a => 1
s.b => 2
s.d.x => 100
s.d.y => 200
#+END_SRC

Or you access the elements with the get function. The get
function has an optional default parameter and it works with keys
that don't look like variables.  Examples:

#+BEGIN_SRC
get(s, "a") => 1
get(s, "b") => 2
get(s, "d") => dict("x", 100, "y", 200)

d = get(s, "d")

get(d, "x") => 100
get(d, "y") => 200
get(d, "missing", 99) => 99
#+END_SRC

You append to a dictionary when you create a new variable. In the
following example the "a" and "str" elements are appended to the
d dictionary.

#+BEGIN_SRC
d = dict()
d.a = 5
d.str = "black"

d => {
  "a": 5,
  "str": "black"
}
#+END_SRC

[[#contents][茶]]

** List Type
:PROPERTIES:
:CUSTOM_ID: list-type
:END:

A list contains a sequence of values of any type.

You can create a list with the list function or with brackets:

#+BEGIN_SRC
a = list()
a = list(1)
a = list(1, 2, 3)
a = list("a", 5, "b")

a = []
a = [1]
a = [1, 2, 3]
a = ["a", 5, "b"]
#+END_SRC

You can append to a list by assigning a value to a variable with
the &= operator.  It will create the list if it doesn't exist. In
the example below, the first line creates the list variable then
assign "black" to it.  The second line appends "green":

#+BEGIN_SRC
teas &= "black"
teas &= "green"
teas => ["black", "green"]
#+END_SRC

The next example creates a g.names list from names contained in a
list of dictionaries:

#+BEGIN_SRC
$$ block
$$ : t.repeat = len(s.entries)
$$ : entry = get(s.entries, t.row)
$$ : g.names &= entry.name
$$ endblock
#+END_SRC

You can access list elements with the get function:

#+BEGIN_SRC
list = list(1, 3.3, "a")
get(list, 0) => 1
get(list, 1) => 3.3
get(list, 2) => "a"
get(list, 3, 99) => 99
#+END_SRC

[[#contents][茶]]

** Bool Type
:PROPERTIES:
:CUSTOM_ID: bool-type
:END:

A bool is a true or false value.

You can create a bool value using true or false or with the bool
function.

#+BEGIN_SRC
a = true
b = false
c = bool(0) # false
d = bool(1) # true (not 0)
#+END_SRC

You can define variables called true and false except in the
local dictionary.

#+BEGIN_SRC
s.true = "server true"
#+END_SRC

[[#contents][茶]]

** Func Type
:PROPERTIES:
:CUSTOM_ID: func-type
:END:

A func variable refers to a function. You use it to call the
function, to get information about it, and to pass it around.

You create a func variable from an existing func variable.

All the functions exist in the f dictionary by name. The
dictionary value is a list of func values with the same name.

In the following example the “a” func variable is defined to be
equal to the second built in cmp function.

#+BEGIN_SRC
a = get(f.cmp, 1)
#+END_SRC

You call it with parentheses:

#+BEGIN_SRC
b = a(4, 7) => -1
#+END_SRC

You can have multiple functions with the same name as long as
their signatures differ.

There are three cmp functions so the f dictionary value for it is
a list of three function variables:

#+BEGIN_SRC
cmp => [func, func, func]
#+END_SRC

You can call a list of func variables. The function called is
determined by the parameters passed, the one with the matching
signature is called. All the built in functions are lists
containing one or more items.

Example calling a function given a list:

#+BEGIN_SRC
value = f.cmp(1,2)
#+END_SRC

When you use a variable without a prefix, Statictea searches for
it first in the l dictionary then the f dictionary.

#+BEGIN_SRC
a = cmp
#+END_SRC

When a name has more than one function assigned to it is called
overloaded.  When none of the overloaded functions match the
passed arguments, statictea shows a different message depending
on whether any of the signatures matched the first argument or
not.

When the first argument doesn't match any signatures, you get a
message saying that. Otherwise, the function that matches the
most arguments is returned and the error message applies to
it. The next examples show both cases. Notice for the cmp(1, 4.5)
case the 1 matches the first parameter of "cmp(int, int) int" so
the error message expects an int for the second parameter too.

#+BEGIN_SRC
shared.tea(1): w207: None of the 3 functions matched the first argument.
statement: o.a = cmp(l, f)
                     ^
o.b = cmp(1, 4.5)
shared.tea(2): w120: Wrong argument type, expected int.
statement: o.b = cmp(1, 4.5)
                        ^
o.c = cmp(1.9, 5)
shared.tea(2): w120: Wrong argument type, expected float.
statement: o.b = cmp(1.9, 5)
                          ^

#+END_SRC

[[#contents][茶]]

* Boolean Expression
:PROPERTIES:
:CUSTOM_ID: boolean-expression
:END:

You use a boolean expression with an if statement to make a
decision.

A boolean expression is an infix expression wrapped with
parentheses containing logical and compare operators that returns
a true or false value.

In the following example the (3 == 4) is an expression and the e
variable is assigned false because 3 does not equal 4.

#+BEGIN_SRC
e = (3 == 4)
  => false
#+END_SRC

You can write boolean expressions with the following operators:

- and
- or
- ==
- !=
- <
- >
- <=
- >=

You typically use a boolean expression with an if statement. In
the next example v is set to “s” because 3 is less than 5.

#+BEGIN_SRC
v = if((3 < 5), “s”, “l”)
  => “s”
#+END_SRC

Note: a conditional is wrapped in parentheses and there is no
name on the left, so the following statement is invalid:

#+BEGIN_SRC
v = if(3 < 5, “s”, “l”)
       ^ invalid syntax
#+END_SRC

The comparisons have the highest precedence, then the logical
“and” and “or”.  Highest precedence to lowest:

- <, >, ==, !=, <=, >=
- and, or

You can control precedence with parentheses. The following two
expressions are equivalent:

#+BEGIN_SRC
(a < b and c > d) =>
( (a < b) and ( c > d) )
#+END_SRC

You can use multiple and’s or or’s in an expression.  For example:

#+BEGIN_SRC
(a < b and c > d and e == f)
(a < b or c > d or e == f)
#+END_SRC

If you mix and’s and or’s, you need to specify the precedence
with parentheses. For example:

#+BEGIN_SRC
( (a < b or c > d) and e == f)
#+END_SRC

The arguments are processed left to right and it uses short
circuit evaluation. “Or” returns true on the first true argument
and “and” returns false on the first false argument and the rest
are skipped.

And and or work with bool arguments. The comparisons work with
numbers and strings.

“Not” is not a logical operator but it is a function.  You can
pass a logical expression to it to invert it.  Here are a couple
of examples:

#+BEGIN_SRC
x = not( (a < b and c > d) )
y = (a < b and not((c > d)))
#+END_SRC

There is an equivalent function for each boolean operator:

- and — and
- or — or
- == — eq (equal)
- != — ne (not equal)
- < — lt (less than)
- > — gt (greater than)
- <= — lte (less than or equal)
- >= — gte (greater than or equal)
- not

The following  code fragments are equivalent:

#+BEGIN_SRC
(a < b) => lt(a, b)

(a < b and c > d) =>
  and(lt(a, b), gt(c,d))

(a or b or c) =>
  or(or(a, b), c)

(a and (b or c)) =>
  and(a, or(b, c))
#+END_SRC

Note: If you need case insensitive string compare, use the cmp
function.

[[#contents][茶]]

* Code Files
:PROPERTIES:
:CUSTOM_ID: code-files
:END:

You share common template fragments with code files. The template
designer controls the code files to factor templates and for
other presentation needs.

You import them from the command line with the -o or --code
option. You can import multiple code files and they run in the
order specified.

The code populates the o dictionary that is available to the
template commands.

A code file is a list of statements.  There are no prefix,
postfix and other line decorations that you use in templates so
the code is easier to read and write.

The maximum line length is 1024 bytes.  An ending plus sign
continues a long statement on the next line.

Here is an example of a code file that defines two variables, pi
and footer.

#+BEGIN_SRC
o.pi = 3.14159
o.footer = "</html>"
#+END_SRC

You primarily use a code file for sharing template fragments
using multiline strings.  See the [[#multiline-strings][Multiline Strings]] section.

The code files run after importing the JSON files so they have
access to the server variables.

You can use the local variables for intermediate values but the
disappear when the code file finishes running.  For example the
"a" variable is local:

#+BEGIN_SRC
a = 5
o.x = a + 6
#+END_SRC

[[#contents][茶]]

* Multiline Strings
:PROPERTIES:
:CUSTOM_ID: multiline-strings
:END:

Code files support multiline strings. They are useful for
sharing template fragments without escaping characters.

Multiline strings are triple quoted UTF-8 encode strings. In the
following example the header variable is assigned a two line
string containing quotes and newlines.

#+BEGIN_SRC
o.header = """
<!doctype html>
<html lang="en">
"""
#+END_SRC

Both the leading and ending triple quotes end the line. Nothing
follows the quotes except the lf or crlf.

The next couple of examples compare multiline strings with normal
strings.

#+BEGIN_SRC
str = """
All the tea in China.
"""
#+END_SRC

is equivalent to:

#+BEGIN_SRC
str = "All the tea in China.\n"
#+END_SRC

The multiline string:

#+BEGIN_SRC
str = """
All the tea in China."""
#+END_SRC

is equivalent to:

#+BEGIN_SRC
str = "All the tea in China."
#+END_SRC

The advantage of a multiline string over a regular string is no
quoting of the newline and other special characters.  For example
you can copy and past HTML directly into the code file then mark
variables in it:

#+BEGIN_SRC
o.header = """
<!DOCTYPE html>
<html lang="{s.languageCode}"
dir="{s.languageDirection}">
<head>
<meta charset="UTF-8"/>
<title>{s.title}</title>
"""
#+END_SRC

A multiline string literal cannot be a argument to a
function. The workaround is to assign it to a local variable and
pass that to the function.

#+BEGIN_SRC
str = """
Teas of China"""
count = len(str)
#+END_SRC

[[#contents][茶]]

* Run StaticTea
:PROPERTIES:
:CUSTOM_ID: run-statictea
:END:

You run StaticTea from the command line. You specify the template
file to process along with the json data files and a result file
is generated.

- Warning messages go to standard error.
- If you don't specify the result file, the result goes to standard out.
- If you specify "stdin" for the template, the template comes
  from stdin.
- StaticTea returns success, return code 0, when there are no
  warning messages, else it returns 1.

The example below shows a typical invocation which specifies four
file arguments, the server json, the shared code file, the template
and the result.

#+BEGIN_SRC
statictea \
  --server server.json \
  --code shared.tea \
  --template template.html \
  --result result.html
#+END_SRC

The StaticTea command line options:

- help -- show options and usage then quit.
- version -- outputs the version number.
- server -- a server json file. You can specify multiple server
  options.
- code -- a shared code file. You can specify multiple shared
  options.
- template -- the template file, or "stdin" for input from
  standard input.
- result -- the result file. When not specified, standard out is
  used.
- update -- update the template replace blocks. See the
  [[#replace-command][Replace Command]].
- prepost -- a command prefix and postfix. You can specify
  multiple prepost options. When you specify a value, the
  defaults are no longer used. See the [[#prefix-postfix][Prefix
  Postfix]] section.
- log - log to a file, see [[#logging][Logging]] section.

[[#contents][茶]]

* Miscellaneous
:PROPERTIES:
:CUSTOM_ID: miscellaneous
:END:

Miscellaneous topics:

- [[#warning-messages][Warning Messages]]
- [[#if-functions][If Functions]]
- [[#prefix-postfix][Prefix Postfix]]
- [[#encoding-and-line-endings][Encoding and Line Endings]]
- [[#update-option][Update Option]]
- [[#logging][Logging]]
- [[#module-docs][Module Docs]]
- [[#html-formatted-json][HTML Formatted Json]]
- [[#nimble-tasks][Nimble Tasks]]
- [[#stf-runner][Stf Runner]]
- [[#example-templates][Example Templates]]
- [[#repl-environment][REPL Environment]]

** Warning Messages
:PROPERTIES:
   :CUSTOM_ID: warning-messages
   :END:

When StaticTea detects a problem, a warning message is written to
standard error, the problem is skipped, and processing
continues.

For example, if a variable in a replacement block is used but it
doesn't exist, the bracketed variable remains as is in the
result, and a message is output to standard error. There are many
other potential warnings.

It’s good style to change your template to be free of messages.

Each warning message shows the file and line number where the
problem happened.

example messages:

- tea.html(0): w15: "Unable to parse the json file. Skipping file: test.json.
- tea.html(45): w61: No space after the command.

Statement errors generate multi-line messages showing the
statement and problem location, for example:

#+BEGIN_SRC
template.html(16): w33: Expected a string, number, variable, list or condition.
statement: tea = len("abc",)
                           ^
#+END_SRC

Warnings are suppressed after the first 32. When you reach the
limit you will see the message:

#+BEGIN_SRC
You reached the maximum number of warnings, suppressing the rest.
#+END_SRC

Statictea returns success, return code 0, when there are no
warning messages, else it returns 1. If you want to treat
warnings as errors, check for the 1 return code.

Example of running statictea when a variable is missing:

template:

#+BEGIN_SRC
<!--$ block -->
You're a {s.webmaster},
I'm a {s.teaMaster}!
<!--$ endblock -->
#+END_SRC

server json:

#+BEGIN_SRC
{
 "webmaster": "html wizard"
}
#+END_SRC

stderr:

#+BEGIN_SRC
template.html(3): w58: The replacement variable doesn't exist: s.teaMaster.
#+END_SRC

result:

#+BEGIN_SRC
You're a html wizard,
I'm a {s.teaMaster}!
#+END_SRC

You can generate your own warnings messsage using the warn
function. Like the system warning messages it skips the current
statement, increments the warning count and produces a non-zero
return code.

For example if the server item list should contain one or more
items, you could output a warning when it's zero:

#+BEGIN_SRC
if0(s.items, warn("no items"))
#+END_SRC

[[#contents][茶]]

** If Functions
:PROPERTIES:
   :CUSTOM_ID: if-functions
   :END:

The if and if0 functions are special in a couple of ways. They
conditionally evaluate their arguments and they can be used in a
statement without an assignment.

There are two forms, one with assignment and one without. The
assignment form has three parameters and the other one has two.
Here is an example of each:

#+BEGIN_SRC
a = if(true, 1, 2)
if(c, warn("c is true"))
#+END_SRC

The no assignment form is uses with the warn and return functions
for their side effects.

The if functions evaluates their condition argument first to
determine which argument to evaluate next and the non-matching
argument is skipped. This is important when you use the warn or
return functions to control the statement flow and it is
different from the other functions which evaluate all their
arguments before passing them to the function.

In the following example do1 is executed and doOther is skipped.

#+BEGIN_SRC
a = if(true, do1(), doOther())
#+END_SRC

The next example has a warn call in it.  If all the arguments
were evaluated, the warn would run everytime.

#+BEGIN_SRC
a = if0(0, do0(), warn("not zero"))
#+END_SRC

The warn and return functions modify the statement flow.  The
warn function skips the current statement and the return function
ends the current block.

[[#contents][茶]]

** Prefix Postfix
:PROPERTIES:
   :CUSTOM_ID: prefix-postfix
   :END:

You make the template commands look like comments tailored for
your template file type. This allows you to edit the template
using its native editors and run other native tools.  For example,
you can edit a StaticTea html template with an html editor and
validate it online with w3.org's validator.

Comment syntax varies depending on the type of template file and
sometimes depending on the location within the file. StaticTea
supports several varieties and you can specify others.

You want to distinguish StaticTea commands from normal comments
when you create your own. The convention is to add a $ as the
last character of the prefix and only use $ with StaticTea
commands and space for normal comments.

Some file types, like markdown, don't support comments, for
them use $$.

Built in Prefixes:

- markdown: $$
- html: <!--$ and -->
- html inside a textarea: &lt;!--$ and --&gt;
- bash: #$
- config files: ;$
- C++: //$
- org mode: # $
- C language: ​/\star$ and \star​/

You can define other comment types on the command line using the
prepost option one or more times. When you specify your own
prepost values, the defaults no longer exist so you have control
of which prefixes get used.

You specify the prepost option with the prefix separated from the
postfix with a comma and the postfix is optional,
'prefix[,postfix]'. A prefix and postfix contain 1 to 20 ASCII
characters including spaces but without control characters or
commas.

Note: It's recommended that you use single quotes so the command
line doesn't interpret $ as an environment variable.

examples:

#+BEGIN_SRC
--prepost 'pre$,post'
--prepost 'a$,b'
--prepost '@$,|'
--prepost '#[$,]#'
--prepost '# $'
#+END_SRC

[[#contents][茶]]

** Encoding and Line Endings
:PROPERTIES:
:CUSTOM_ID: encoding-and-line-endings
:END:

Templates are treated as a stream of bytes. The embedded
statictea commands only use ASCII except for quoted strings which
are UTF-8 encoded.

Two line endings are supported on all platforms: LF, and CR/LF
and they are preserved.

The maximum command line length is 1024 bytes. There is
no limit on non-command lines.

Since line endings are preserved and there are no encoding or
line length restrictions on non-command lines, you can make
templates out of binary or mixed binary and text files like EPS
or PDF files.

[[#contents][茶]]

** Update Option
:PROPERTIES:
:CUSTOM_ID: update-option
:END:

The update option updates the template's replace blocks to
match their t.content text.  The text normally comes from the
shared code files but it doesn't have to.

You use this to keep the template blocks in sync with the shared
content so you can work with them as static pages.

If the t.content does not end with a newline, one is added so the
endcommand starts on a new line.

The following example shows a typical invocation:

#+BEGIN_SRC
statictea \
  --server server.json \
  --code shared.tea \
  --template template.html \
  --update
#+END_SRC

If the template content comes from the standard input stream the
result goes to the standard output stream.

See the [[#replace-command][replace command]] for update examples.

[[#contents][茶]]

** Logging
:PROPERTIES:
   :CUSTOM_ID: logging
   :END:

Statictea writes statistics to the log file.  Template commands
can also write to the log file.

Log information is appended to the file.  When the file size
exceeds 1 GB, a warning message is generated each time a template
is processed.

Logging is off by default. You turn it on with the log option.
If you don't specify a filename, the log lines are written to the
platform default location:

- Mac: ~/Library/Logs/statictea.log
- Other: ~/statictea.log

You can specify a full path. If you don't include path
information, the log is written to the current directory.

#+BEGIN_SRC
statictea --log mylog.txt
#+END_SRC

When you write a replacement block to the log file, the template
file and line number of the replacement block appear there.

#+BEGIN_SRC
2021-12-07 22:03:59.908; statictea.nim(42); Starting: argv: @["-l log.txt", "-t tmpl.txt", "-r result.txt"]
2021-12-07 22:03:59.908; statictea.nim(43); Version: 0.1.0
2021-12-07 22:03:59.909; tmpl.txt(2); ┌─────────┐
2021-12-07 22:03:59.909; tmpl.txt(3); │log block│
2021-12-07 22:03:59.909; tmpl.txt(4); └─────────┘
2021-12-07 22:03:59.910; statictea.nim(66); Warnings: 0
2021-12-07 22:03:59.910; statictea.nim(69); Return code: 0
2021-12-07 22:03:59.910; statictea.nim(70); Done
#+END_SRC

[[#contents][茶]]

** Module Docs
:PROPERTIES:
   :CUSTOM_ID: module-docs
   :END:

You can read the StaticTea source code documentation in Github
because it is formatted as github markdown. Statictea created the
markdown files from the source code's embedded doc comments.

- [[docs/index.md][StaticTea Source Docs]] --- Index to the
  source code documents.

The nimble *docsix* task builds the module index by running the
following process:

1. create a json file from the doc comments at the top of all the source files
2. format the json as markdown using the
   [[templates/nimModuleIndex.md][nimModuleIndex.md]] statictea
   template. Click the link then "View Raw".

The nimble *docs* task builds the module markdown files by running
the following process for each module:

1. create a json file of a module's docs using nim's jsondoc command
2. format the json as markdown using the [[templates/nimModule.md][nimModule.md]] statictea template

[[#contents][茶]]

** HTML Formatted Json
:PROPERTIES:
   :CUSTOM_ID: html-formatted-json
   :END:

The nim jsondoc command produces html formatted json data.  Our
desired final format is Github markdown so having html
presentation data in the json is a problem.

It was discovered that single paragraph comments are mostly
unformatted.  This is the basis for a workaround. You avoid the
formatting by making all the documentation look like one
paragraph by inserting some symbols in strategic places.

Workaround Rules:

- use @: at the beginning of lines, except the first line.
- use ~~~ to begin a code block
- use ~~~~ to end a code block
- use @{ for [ in an http link
- use }@ for ] in an http link
- use @@: for a : in an http link
- use @. for *
- use @! for |

Change:

#+BEGIN_SRC
[Semantic Versioning](https://semver.org/)
#+END_SRC
to:

#+BEGIN_SRC
@{Semantic Versioning}@(https@@://semver.org/)
#+END_SRC

See the [[src/runFunction.nim][runFunction.nim]] file for other examples.

[[#contents][茶]]

** Nimble Tasks
:PROPERTIES:
   :CUSTOM_ID: nimble-tasks
   :END:

You can run commands to build, test, make docs etc. using nimble
task commands. Run them from the statictea root folder. The n
task lists the available tasks.

#+BEGIN_SRC
cd ~/code/statictea
nimble n
#+END_SRC

Nimble Tasks:

#+BEGIN_SRC
n          Show available tasks.
test       Run one or more tests; specify part of test filename.
other      Run other tests and build tests.
b          Build the statictea exe.
docsall    Create all the docs, docsix, docs, readmefun, dot.
docs       Create one or more markdown docs; specify part of source filename.
docsix     Create markdown docs index.
json       Display one or more source file's json doc comments; specify part of name.
jsonix     Display markdown docs index json.
stfix      Display markdown testfiles index json.
readmefun  Create the readme function section.
dot        Create a dependency graph of the StaticTea source.
dot2       Create a dependency graph of the system modules used by StaticTea.
tt         Compile and run t.nim.
tree       Show the project directory tree.
args       Show command line arguments.
br         Build the stf test runner.
rt         Run one or more stf tests in testfiles; specify part of the name.
stfrm      Create testfiles readme.md.
newstf     Create new stf as a starting point for a new test.
runhelp    Show the runner help text with glow.
helpme     Show the statictea help text.
remote     Check whether the remote code needs updating.
cmdline    Build cmdline.
#+END_SRC

[[#contents][茶]]

** Stf Runner
:PROPERTIES:
   :CUSTOM_ID: stf-runner
   :END:

The Single Test File (stf) runner is a standalone program used
for testing command line applications. A stf file contains the
test which the runner executes to determine whether the test
passed. The stf files are designed to look good in markdown
readers.

The stf file contains instructions for creating files, running
files and comparing files. See the runner help message for more
information about stf files.

The testfiles folder contains statictea stf files.

[[#contents][茶]]

** Example Templates
:PROPERTIES:
   :CUSTOM_ID: example-templates
   :END:

You can examine simple self contained statictea templates
in the testfiles folder.

- [[testfiles/readme.md][StaticTea Stf Files]] --- Index to the stf files.

The [[#module-docs][Module Docs]] section has more real world examples.

[[#contents][茶]]

** REPL Environment
:PROPERTIES:
   :CUSTOM_ID: repl-environment
   :END:

You can run static tea interactively with a prompt. You run
statements at the prompt and print variables with commands.

The -x option starts the Read Eval Print Loop (REPL).

#+BEGIN_SRC
statictea -x
tea>
#+END_SRC

The prompt appears after processing code files and importing json
files, so you can inspect values they create.

#+BEGIN_SRC
stawtictea -x -o codefile.tea -s in.json
tea>
#+END_SRC

In the following example the statement “z = 5” is entered then
z is printed. P is short for print.

#+BEGIN_SRC
statictea -x
tea> z = 5
tea> p z
5
#+END_SRC

You can use several commands for printing out values. The help
command (h) shows them.

#+BEGIN_SRC
tea> h
Available commands:
* h — this help
* p — print the value of a variable
* pd — print a dictionary as dot names
* pj — print a variable as json 
* v — show number of variables in the top level dictionaries
* q — quit
#+END_SRC

[[#contents][茶]]

* Functions
:PROPERTIES:
:CUSTOM_ID: functions
:ORDERED:  t
:END:

Functions allow you to format variables for presentation.  They
return a value that you assign to a variable or pass to another
function.

This section was created from the nim source code by running the
readmefun nimble task which uses the StaticTea template
[[templates/readmeFuncSection.org][readmeFuncSection.org]].

List of functions:

# Dynamic Content Begins
- [[#add][add]] -- Add two floats.
- [[#add][add]] -- Add two integers.
- [[#and][and]] -- Boolean and with short circuit.
- [[#bool][bool]] -- Create an bool from an int.
- [[#case][case]] -- Compare integer cases and return the matching value.
- [[#case][case]] -- Compare string cases and return the matching value.
- [[#cmpVersion][cmpVersion]] -- Compare two StaticTea version numbers.
- [[#cmp][cmp]] -- Compare two floats.
- [[#cmp][cmp]] -- Compare two ints.
- [[#cmp][cmp]] -- Compare two strings.
- [[#concat][concat]] -- Concatentate two strings.
- [[#dict][dict]] -- Create a dictionary from a list of key, value pairs.
- [[#dup][dup]] -- Duplicate a string x times.
- [[#eq][eq]] -- Return true when the a equals b.
- [[#eq][eq]] -- Return true when the a equals b.
- [[#eq][eq]] -- Return true when the a equals b.
- [[#exists][exists]] -- Determine whether a key exists in a dictionary.
- [[#find][find]] -- Find the position of a substring in a string.
- [[#float][float]] -- Create a float from an int.
- [[#float][float]] -- Create a float from a number string.
- [[#float][float]] -- Create a float from a number string.
- [[#format][format]] -- Format a string using replacement variables similar to a replacement block.
- [[#get][get]] -- Get a dictionary value by its key.
- [[#get][get]] -- Get a list value by its index.
- [[#githubAnchor][githubAnchor]] -- Create Github anchor names from heading names.
- [[#githubAnchor][githubAnchor]] -- Create a Github anchor name from a heading name.
- [[#gt][gt]] -- Return true when the a is greater than b.
- [[#gt][gt]] -- Return true when the a is greater than b.
- [[#gte][gte]] -- Return true when the a is greater than to equal to b.
- [[#gte][gte]] -- Return true when the a is greater than or equal to b.
- [[#if0][if0]] -- If the condition is 0, return the second argument, else return the third argument.
- [[#if][if]] -- If the condition is true, return the second argument, else return the third argument.
- [[#int][int]] -- Create an int from a float.
- [[#int][int]] -- Create an int from a number string.
- [[#int][int]] -- Create an int from a number string.
- [[#joinPath][joinPath]] -- Join the path components with a path separator.
- [[#join][join]] -- Join a list of strings with a separator.
- [[#keys][keys]] -- Create a list from the keys in a dictionary.
- [[#len][len]] -- Number of elements in a dictionary.
- [[#len][len]] -- Number of elements in a list.
- [[#len][len]] -- Number of unicode characters in a string.
- [[#list][list]] -- You create a list with the list function or with brackets.
- [[#lower][lower]] -- Lowercase a string.
- [[#lt][lt]] -- Return true when the a is less than b.
- [[#lt][lt]] -- Return true when the a is less than b.
- [[#lte][lte]] -- Return true when the a is less than or equal to b.
- [[#lte][lte]] -- Return true when the a is less than or equal to b.
- [[#ne][ne]] -- Return true when the a does not equal b.
- [[#ne][ne]] -- Return true when the a does not equal b.
- [[#ne][ne]] -- Return true when the a does not equal b.
- [[#not][not]] -- Boolean not.
- [[#or][or]] -- Boolean or with short circuit.
- [[#path][path]] -- Split a file path into its component pieces.
- [[#replaceRe][replaceRe]] -- Replace multiple parts of a string using regular expressions.
- [[#replace][replace]] -- Replace a substring specified by its position and length with another string.
- [[#return][return]] -- Return the given value and control command looping.
- [[#slice][slice]] -- Extract a substring from a string by its position and length.
- [[#sort][sort]] -- Sort a list of values of the same type.
- [[#sort][sort]] -- Sort a list of lists.
- [[#sort][sort]] -- Sort a list of dictionaries.
- [[#startsWith][startsWith]] -- Check whether a strings starts with the given prefix.
- [[#string][string]] -- Convert the variable to a string.
- [[#string][string]] -- Convert the dictionary variable to dot names were you specify the name of the dictionary.
- [[#type][type]] -- Return the parameter type, one of: int, float, string, list, dict, bool or func.
- [[#values][values]] -- Create a list out of the values in the specified dictionary.
- [[#warn][warn]] -- Return a warning message and skip the current statement.

[[#contents][茶]]

** add
:PROPERTIES:
:CUSTOM_ID: add
:END:

Add two floats. A warning is generated on overflow.

#+BEGIN_SRC
add(a: float, b: float) float
#+END_SRC

Examples:

#+BEGIN_SRC
add(1.5, 2.3) => 3.8
add(3.2, -2.2) => 1.0
#+END_SRC

[[#contents][茶]]

** add
:PROPERTIES:
:CUSTOM_ID: add
:END:

Add two integers. A warning is generated on overflow.

#+BEGIN_SRC
add(a: int, b: int)) int
#+END_SRC

Examples:

#+BEGIN_SRC
add(1, 2) => 3
add(3, -2) => 1
add(-2, -5) => -7
#+END_SRC

[[#contents][茶]]

** and
:PROPERTIES:
:CUSTOM_ID: and
:END:

Boolean and with short circuit. If the first argument is false, the second argument is not evaluated.

#+BEGIN_SRC
and(a: bool, b: bool) bool
#+END_SRC

Examples:

#+BEGIN_SRC
and(true, true) => true
and(false, true) => false
and(true, false) => false
and(false, false) => false
and(false, warn("not hit")) => false
#+END_SRC

[[#contents][茶]]

** bool
:PROPERTIES:
:CUSTOM_ID: bool
:END:

Create an bool from an int. A 0 is false and all other values are true.

#+BEGIN_SRC
bool(num: int) bool
#+END_SRC

Examples:

#+BEGIN_SRC
bool(0) => false
bool(1) => true
bool(2) => true
bool(3) => true
bool(-1) => true
#+END_SRC

[[#contents][茶]]

** case
:PROPERTIES:
:CUSTOM_ID: case
:END:

Compare integer cases and return the matching value.  It takes a
main integer condition, a list of case pairs and an optional
value when none of the cases match.

The first element of a case pair is the condition and the
second is the return value when that condition matches the main
condition. The function compares the conditions left to right and
returns the first match.

When none of the cases match the main condition, the default
value is returned if it is specified, otherwise a warning is
generated.  The conditions must be integers. The return values
can be any type.

#+BEGIN_SRC
case(condition: int, pairs: list, optional default: any) any
#+END_SRC

Examples:

#+BEGIN_SRC
cases = list(0, "tea", 1, "water", 2, "beer")
case(0, cases) => "tea"
case(1, cases) => "water"
case(2, cases) => "beer"
case(2, cases, "wine") => "beer"
case(3, cases, "wine") => "wine"
#+END_SRC

[[#contents][茶]]

** case
:PROPERTIES:
:CUSTOM_ID: case
:END:

Compare string cases and return the matching value.  It takes a
main string condition, a list of case pairs and an optional
value when none of the cases match.

The first element of a case pair is the condition and the
second is the return value when that condition matches the main
condition. The function compares the conditions left to right and
returns the first match.

When none of the cases match the main condition, the default
value is returned if it is specified, otherwise a warning is
generated.  The conditions must be strings. The return values
can be any type.

#+BEGIN_SRC
case(condition: string, pairs: list, optional default: any) any
#+END_SRC

Examples:

#+BEGIN_SRC
cases = list("tea", 15, "water", 2.3, "beer", "cold")
case("tea", cases) => 15
case("water", cases) => 2.3
case("beer", cases) => "cold"
case("bunch", cases, "other") => "other"
#+END_SRC

[[#contents][茶]]

** cmpVersion
:PROPERTIES:
:CUSTOM_ID: cmpVersion
:END:

Compare two StaticTea version numbers. Returns -1 for less, 0 for
equal and 1 for greater than.

#+BEGIN_SRC
cmpVersion(versionA: string, versionB: string) int
#+END_SRC

StaticTea uses [[https://semver.org/][Semantic Versioning]]
with the added restriction that each version component has one
to three digits (no letters).

Examples:

#+BEGIN_SRC
cmpVersion("1.2.5", "1.1.8") => 1
cmpVersion("1.2.5", "1.3.0") => -1
cmpVersion("1.2.5", "1.2.5") => 0
#+END_SRC

[[#contents][茶]]

** cmp
:PROPERTIES:
:CUSTOM_ID: cmp
:END:

Compare two floats. Returns -1 for less, 0 for
equal and 1 for greater than.

#+BEGIN_SRC
cmp(a: float, b: float) int
#+END_SRC

Examples:

#+BEGIN_SRC
cmp(7.8, 9.1) => -1
cmp(8.4, 8.4) => 0
cmp(9.3, 2.2) => 1
#+END_SRC

[[#contents][茶]]

** cmp
:PROPERTIES:
:CUSTOM_ID: cmp
:END:

Compare two ints. Returns -1 for less, 0 for equal and 1 for
 greater than.

#+BEGIN_SRC
cmp(a: int, b: int) int
#+END_SRC

Examples:

#+BEGIN_SRC
cmp(7, 9) => -1
cmp(8, 8) => 0
cmp(9, 2) => 1
#+END_SRC

[[#contents][茶]]

** cmp
:PROPERTIES:
:CUSTOM_ID: cmp
:END:

Compare two strings. Returns -1 for less, 0 for equal and 1 for
greater than.

You have the option to compare case insensitive. Case sensitive
is the default.

#+BEGIN_SRC
cmp(a: string, b: string, optional insensitive: bool) int
#+END_SRC

Examples:

#+BEGIN_SRC
cmp("coffee", "tea") => -1
cmp("tea", "tea") => 0
cmp("Tea", "tea") => 1
cmp("Tea", "tea", true) => 1
cmp("Tea", "tea", false) => 0
#+END_SRC

[[#contents][茶]]

** concat
:PROPERTIES:
:CUSTOM_ID: concat
:END:

Concatentate two strings. See join for more that two arguments.

#+BEGIN_SRC
concat(a: string, b: string) string
#+END_SRC

Examples:

#+BEGIN_SRC
concat("tea", " time") => "tea time"
concat("a", "b") => "ab"
#+END_SRC

[[#contents][茶]]

** dict
:PROPERTIES:
:CUSTOM_ID: dict
:END:

Create a dictionary from a list of key, value pairs.  The keys
must be strings and the values can be any type.

#+BEGIN_SRC
dict(pairs: optional list) dict
#+END_SRC

Examples:

#+BEGIN_SRC
dict() => {}
dict(list("a", 5)) => {"a": 5}
dict(list("a", 5, "b", 33, "c", 0)) =>
  {"a": 5, "b": 33, "c": 0}
#+END_SRC

[[#contents][茶]]

** dup
:PROPERTIES:
:CUSTOM_ID: dup
:END:

Duplicate a string x times.  The result is a new string built by
concatenating the string to itself the specified number of times.

#+BEGIN_SRC
dup(pattern: string, count: int) string
#+END_SRC

Examples:

#+BEGIN_SRC
dup("=", 3) => "==="
dup("abc", 0) => ""
dup("abc", 1) => "abc"
dup("abc", 2) => "abcabc"
dup("", 3) => ""
#+END_SRC

[[#contents][茶]]

** eq
:PROPERTIES:
:CUSTOM_ID: eq
:END:

Return true when the a equals b.

#+BEGIN_SRC
eq(a: float, b: float) bool
#+END_SRC

Examples:

#+BEGIN_SRC
eq(1.2, 1.2) => true
eq(1.2, 3.2) => false
#+END_SRC

[[#contents][茶]]

** eq
:PROPERTIES:
:CUSTOM_ID: eq
:END:

Return true when the a equals b.

#+BEGIN_SRC
eq(a: int, b: int) bool
#+END_SRC

Examples:

#+BEGIN_SRC
eq(1, 1) => true
eq(2, 3) => false
#+END_SRC

[[#contents][茶]]

** eq
:PROPERTIES:
:CUSTOM_ID: eq
:END:

Return true when the a equals b.

#+BEGIN_SRC
eq(a: string, b: string) bool
#+END_SRC

Examples:

#+BEGIN_SRC
eq("tea", "tea") => true
eq("1.2", "3.2") => false
#+END_SRC

[[#contents][茶]]

** exists
:PROPERTIES:
:CUSTOM_ID: exists
:END:

Determine whether a key exists in a dictionary. Return true when it exists, else false.

#+BEGIN_SRC
exists(dictionary: dict, key: string) bool
#+END_SRC

Examples:

#+BEGIN_SRC
d = dict("tea", "Earl")
exists(d, "tea") => true
exists(d, "coffee") => false
#+END_SRC

[[#contents][茶]]

** find
:PROPERTIES:
:CUSTOM_ID: find
:END:

Find the position of a substring in a string.  When the substring
is not found, return an optional default value.  A warning is
generated when the substring is missing and you don't specify a
default value.

#+BEGIN_SRC
find(str: string, substring: string, optional default: any) any
#+END_SRC

Examples:

#+BEGIN_SRC
       0123456789 1234567
msg = "Tea time at 3:30."
find(msg, "Tea") = 0
find(msg, "time") = 4
find(msg, "me") = 6
find(msg, "party", -1) = -1
find(msg, "party", len(msg)) = 17
find(msg, "party", 0) = 0
#+END_SRC

[[#contents][茶]]

** float
:PROPERTIES:
:CUSTOM_ID: float
:END:

Create a float from an int.

#+BEGIN_SRC
float(num: int) float
#+END_SRC

Examples:

#+BEGIN_SRC
float(2) => 2.0
float(-33) => -33.0
#+END_SRC

[[#contents][茶]]

** float
:PROPERTIES:
:CUSTOM_ID: float
:END:

Create a float from a number string. If the string is not a number, return the default.

#+BEGIN_SRC
float(numString: string, default: any) any
#+END_SRC

Examples:

#+BEGIN_SRC
float("2") => 2.0
float("notnum", "nan") => nan
#+END_SRC

[[#contents][茶]]

** float
:PROPERTIES:
:CUSTOM_ID: float
:END:

Create a float from a number string.

#+BEGIN_SRC
float(numString: string) float
#+END_SRC

Examples:

#+BEGIN_SRC
float("2") => 2.0
float("2.4") => 2.4
float("33") => 33.0
#+END_SRC

[[#contents][茶]]

** format
:PROPERTIES:
:CUSTOM_ID: format
:END:

Format a string using replacement variables similar to a replacement block. To enter a left bracket use two in a row.

#+BEGIN_SRC
format(str: string) string
#+END_SRC

Example:

#+BEGIN_SRC
let first = "Earl"
let last = "Grey"
str = format("name: {first} {last}")

str => "name: Earl Grey"
#+END_SRC

To enter a left bracket use two in a row.

#+BEGIN_SRC
str = format("use two {{ to get one")

str => "use two { to get one"
#+END_SRC

[[#contents][茶]]

** get
:PROPERTIES:
:CUSTOM_ID: get
:END:

Get a dictionary value by its key.  If the key doesn't exist, the
default value is returned if specified, else a warning is
generated.

#+BEGIN_SRC
get(dictionary: dict, key: string, optional default: any) any
#+END_SRC

Note: For dictionary lookup you can use dot notation. It's the
same as get without the default.

Examples:

#+BEGIN_SRC
d = dict("tea", "Earl Grey")
get(d, "tea") => "Earl Grey"
get(d, "coffee", "Tea") => "Tea"
#+END_SRC

Using dot notation:
#+BEGIN_SRC
d = dict("tea", "Earl Grey")
d.tea => "Earl Grey"
#+END_SRC

[[#contents][茶]]

** get
:PROPERTIES:
:CUSTOM_ID: get
:END:

Get a list value by its index.  If the index is invalid, the
default value is returned when specified, else a warning is
generated. You can use negative index values. Index -1 gets the
last element. It is short hand for len - 1. Index -2 is len - 2,
etc.

#+BEGIN_SRC
get(list: list, index: int, optional default: any) any
#+END_SRC

Examples:

#+BEGIN_SRC
list = list(4, "a", 10)
get(list, 0) => 4
get(list, 1) => "a"
get(list, 2) => 10
get(list, 3, 99) => 99
get(list, -1) => 10
get(list, -2) => "a"
get(list, -3) => 4
get(list, -4, 11) => 11
#+END_SRC

[[#contents][茶]]

** githubAnchor
:PROPERTIES:
:CUSTOM_ID: githubAnchor
:END:

Create Github anchor names from heading names. Use it for Github
markdown internal links. It handles duplicate heading names.

#+BEGIN_SRC
githubAnchor(names: list) list
#+END_SRC

Examples:

#+BEGIN_SRC
list = list("Tea", "Water", "Tea")
githubAnchor(list) =>
  ["tea", "water", "tea-1"]
#+END_SRC

[[#contents][茶]]

** githubAnchor
:PROPERTIES:
:CUSTOM_ID: githubAnchor
:END:

Create a Github anchor name from a heading name. Use it for
Github markdown internal links. If you have duplicate heading
names, the anchor name returned only works for the
first. Punctuation characters are removed so you can get
duplicates in some cases.

#+BEGIN_SRC
githubAnchor(name: string) string
#+END_SRC

Examples:

#+BEGIN_SRC
githubAnchor("MyHeading") => "myheading"
githubAnchor("Eary Gray") => "eary-gray"
githubAnchor("$Eary-Gray#") => "eary-gray"
#+END_SRC

Example in a markdown template:

#+BEGIN_SRC
$$ : anchor = githubAnchor(entry.name)
- {type]{{entry.name}](#{anchor}) &mdash; {short}
...
# {entry.name}
#+END_SRC

[[#contents][茶]]

** gt
:PROPERTIES:
:CUSTOM_ID: gt
:END:

Return true when the a is greater than b.

#+BEGIN_SRC
gt(a: float, b: float) bool
#+END_SRC

Examples:

#+BEGIN_SRC
gt(2.8, 4.3) => false
gt(3.1, 2.5) => true
#+END_SRC

[[#contents][茶]]

** gt
:PROPERTIES:
:CUSTOM_ID: gt
:END:

Return true when the a is greater than b.

#+BEGIN_SRC
gt(a: int, b: int) bool
#+END_SRC

Examples:

#+BEGIN_SRC
gt(2, 4) => false
gt(3, 2) => true
#+END_SRC

[[#contents][茶]]

** gte
:PROPERTIES:
:CUSTOM_ID: gte
:END:

Return true when the a is greater than to equal to b.

#+BEGIN_SRC
gte(a: float, b: float) bool
#+END_SRC

Examples:

#+BEGIN_SRC
gte(2.8, 4.3) => false
gte(3.1, 3.1) => true
#+END_SRC

[[#contents][茶]]

** gte
:PROPERTIES:
:CUSTOM_ID: gte
:END:

Return true when the a is greater than or equal to b.

#+BEGIN_SRC
gte(a: int, b: int) bool
#+END_SRC

Examples:

#+BEGIN_SRC
gte(2, 4) => false
gte(3, 3) => true
#+END_SRC

[[#contents][茶]]

** if0
:PROPERTIES:
:CUSTOM_ID: if0
:END:

If the condition is 0, return the second argument, else return the third argument.  You can use any type for the condition.  The condition is 0 for strings, lists and dictionaries when their length is 0.

The condition types and what is considered 0:

- bool -- false
- int -- 0
- float -- 0.0
- string -- when the length of the string is 0
- list -- when the length of the list is 0
- dict -- when the length of the dictionary is 0
- func -- always 0

The if functions are special in a couple of ways, see
[[#if-functions][If Functions]]

#+BEGIN_SRC
if0(condition: any, then: any, else: any) any
if0(condition: any, then: any)
#+END_SRC

Examples:

#+BEGIN_SRC
a = if0(0, "tea", "beer") => tea
a = if0(1, "tea", "beer") => beer
a = if0(4, "tea", "beer") => beer
a = if0("", "tea", "beer") => tea
a = if0("abc", "tea", "beer") => beer
a = if0([], "tea", "beer") => tea
a = if0([1,2], "tea", "beer") => beer
a = if0(dict(), "tea", "beer") => tea
a = if0(dict("a",1), "tea", "beer") => beer
a = if0(false, "tea", "beer") => tea
a = if0(true, "tea", "beer") => beer
#+END_SRC

You don't have to assign the result of an if0 function which is
useful when using a warn or return function for its side effects.
The if takes two arguments when there is no assignment.

#+BEGIN_SRC
c = 0
if0(c, warn("got zero value"))
#+END_SRC

[[#contents][茶]]

** if
:PROPERTIES:
:CUSTOM_ID: if
:END:

If the condition is true, return the second argument, else return the third argument.

- The if functions are special in a couple of ways, see
[[#if-functions][If Functions]]
- You usually use boolean expressions for the condition, see:
[[#boolean-expressions][Boolean Expressions]]

#+BEGIN_SRC
if(condition: bool, then: any, optional else: any) any
#+END_SRC

Examples:

#+BEGIN_SRC
a = if(true, "tea", "beer") => tea
b = if(false, "tea", "beer") => beer
c = if((d < 5), "tea", "beer") => beer
#+END_SRC

You don't have to assign the result of an if function which is
useful when using a warn or return function for its side effects.
The if takes two arguments when there is no assignment.

#+BEGIN_SRC
if(c, warn("c is true"))
if(c, return("skip"))
#+END_SRC

[[#contents][茶]]

** int
:PROPERTIES:
:CUSTOM_ID: int
:END:

Create an int from a float.

#+BEGIN_SRC
int(num: float, optional roundOption: string) int
#+END_SRC

Round options:

- "round" - nearest integer, the default.
- "floor" - integer below (to the left on number line)
- "ceiling" - integer above (to the right on number line)
- "truncate" - remove decimals

Examples:

#+BEGIN_SRC
int(2.34) => 2
int(2.34, "round") => 2
int(-2.34, "round") => -2
int(6.5, "round") => 7
int(-6.5, "round") => -7
int(4.57, "floor") => 4
int(-4.57, "floor") => -5
int(6.3, "ceiling") => 7
int(-6.3, "ceiling") => -6
int(6.3456, "truncate") => 6
int(-6.3456, "truncate") => -6
#+END_SRC

[[#contents][茶]]

** int
:PROPERTIES:
:CUSTOM_ID: int
:END:

Create an int from a number string.

#+BEGIN_SRC
int(numString: string, optional roundOption: string) int
#+END_SRC

Round options:

- "round" - nearest integer, the default
- "floor" - integer below (to the left on number line)
- "ceiling" - integer above (to the right on number line)
- "truncate" - remove decimals

Examples:

#+BEGIN_SRC
int("2") => 2
int("2.34") => 2
int("-2.34", "round") => -2
int("6.5", "round") => 7
int("-6.5", "round") => -7
int("4.57", "floor") => 4
int("-4.57", "floor") => -5
int("6.3", "ceiling") => 7
int("-6.3", "ceiling") => -6
int("6.3456", "truncate") => 6
int("-6.3456", "truncate") => -6
#+END_SRC

[[#contents][茶]]

** int
:PROPERTIES:
:CUSTOM_ID: int
:END:

Create an int from a number string. If the string is not a number, return the default value.

#+BEGIN_SRC
int(numString: string, roundOption: string, default: any) any
#+END_SRC

Round options:

- "round" - nearest integer, the default
- "floor" - integer below (to the left on number line)
- "ceiling" - integer above (to the right on number line)
- "truncate" - remove decimals

Examples:

#+BEGIN_SRC
int("2", "round", "nan") => 2
int("notnum", "round", "nan") => nan
#+END_SRC

[[#contents][茶]]

** joinPath
:PROPERTIES:
:CUSTOM_ID: joinPath
:END:

Join the path components with a path separator.

You pass a list of components to join. For the second optional
parameter you specify the separator to use, either "/", "" or
"". If you specify "" or leave off the parameter, the current
platform separator is used.

If the separator already exists between components, a new one
is not added. If a component is "", the platform separator is
used for it.

#+BEGIN_SRC
joinPath(components: list, optional separator: string) string
#+END_SRC

Examples:

#+BEGIN_SRC
joinPath(["images", "tea"]) =>
  "images/tea"

joinPath(["images", "tea"], "/") =>
  "images/tea"

joinPath(["images", "tea"], "\") =>
  "images\tea"

joinPath(["images/", "tea"]) =>
  "images/tea"

joinPath(["", "tea"]) =>
  "/tea"

joinPath(["/", "tea"]) =>
  "/tea"
#+END_SRC

[[#contents][茶]]

** join
:PROPERTIES:
:CUSTOM_ID: join
:END:

Join a list of strings with a separator.  An optional parameter determines whether you skip empty strings or not. You can use an empty separator to concatenate the arguments.

#+BEGIN_SRC
join(strs: list, sep: string, optional skipEmpty: int) string
#+END_SRC

Examples:

#+BEGIN_SRC
join(["a", "b"], ", ") => "a, b"
join(["a", "b"], "") => "ab"
join(["a", "b", "c"], "") => "abc"
join(["a"], ", ") => "a"
join([""], ", ") => ""
join(["a", "b"], "") => "ab"
join(["a", "", "c"], "|") => "a||c"
join(["a", "", "c"], "|", 1) => "a|c"
#+END_SRC

[[#contents][茶]]

** keys
:PROPERTIES:
:CUSTOM_ID: keys
:END:

Create a list from the keys in a dictionary.

#+BEGIN_SRC
keys(dictionary: dict) list
#+END_SRC

Examples:

#+BEGIN_SRC
d = dict("a", 1, "b", 2, "c", 3)
keys(d) => ["a", "b", "c"]
values(d) => ["apple", 2, 3]
#+END_SRC

[[#contents][茶]]

** len
:PROPERTIES:
:CUSTOM_ID: len
:END:

Number of elements in a dictionary.

#+BEGIN_SRC
len(dictionary: dict) int
#+END_SRC

Examples:

#+BEGIN_SRC
len(dict()) => 0
len(dict("a", 4)) => 1
len(dict("a", 4, "b", 3)) => 2
#+END_SRC

[[#contents][茶]]

** len
:PROPERTIES:
:CUSTOM_ID: len
:END:

Number of elements in a list.

#+BEGIN_SRC
len(list: list) int
#+END_SRC

Examples:

#+BEGIN_SRC
len(list()) => 0
len(list(1)) => 1
len(list(4, 5)) => 2
#+END_SRC

[[#contents][茶]]

** len
:PROPERTIES:
:CUSTOM_ID: len
:END:

Number of unicode characters in a string.

#+BEGIN_SRC
len(str: string) int
#+END_SRC

Examples:

#+BEGIN_SRC
len("tea") => 3
len("añyóng") => 6
#+END_SRC

[[#contents][茶]]

** list
:PROPERTIES:
:CUSTOM_ID: list
:END:

You create a list with the list function or with brackets.

#+BEGIN_SRC
list(...) list
#+END_SRC

Examples:

#+BEGIN_SRC
a = list()
a = list(1)
a = list(1, 2, 3)
a = list("a", 5, "b")
a = []
a = [1]
a = [1, 2, 3]
a = ["a", 5, "b"]
#+END_SRC

[[#contents][茶]]

** lower
:PROPERTIES:
:CUSTOM_ID: lower
:END:

Lowercase a string.

#+BEGIN_SRC
lower(str: string) string
#+END_SRC

Examples:

#+BEGIN_SRC
lower("Tea") => "tea"
lower("TEA") => "tea"
lower("TEĀ") => "teā"
#+END_SRC

[[#contents][茶]]

** lt
:PROPERTIES:
:CUSTOM_ID: lt
:END:

Return true when the a is less than b.

#+BEGIN_SRC
lt(a: float, b: float) bool
#+END_SRC

Examples:

#+BEGIN_SRC
lt(2.8, 4.3) => true
lt(3.1, 2.5) => false
#+END_SRC

[[#contents][茶]]

** lt
:PROPERTIES:
:CUSTOM_ID: lt
:END:

Return true when the a is less than b.

#+BEGIN_SRC
lt(a: int, b: int) bool
#+END_SRC

Examples:

#+BEGIN_SRC
gt(2, 4) => true
gt(3, 2) => false
#+END_SRC

[[#contents][茶]]

** lte
:PROPERTIES:
:CUSTOM_ID: lte
:END:

Return true when the a is less than or equal to b.

#+BEGIN_SRC
lte(a: float, b: float) bool
#+END_SRC

Examples:

#+BEGIN_SRC
lte(2.3, 4.4) => true
lte(3.0, 3.0) => true
lte(4.0, 3.0) => false
#+END_SRC

[[#contents][茶]]

** lte
:PROPERTIES:
:CUSTOM_ID: lte
:END:

Return true when the a is less than or equal to b.

#+BEGIN_SRC
lte(a: int, b: int) bool
#+END_SRC

Examples:

#+BEGIN_SRC
lte(2, 4) => true
lte(3, 3) => true
lte(4, 3) => false
#+END_SRC

[[#contents][茶]]

** ne
:PROPERTIES:
:CUSTOM_ID: ne
:END:

Return true when the a does not equal b.

#+BEGIN_SRC
ne(a: float, b: float) bool
#+END_SRC

Examples:

#+BEGIN_SRC
ne(1.2, 1.2) => false
ne(1.2, 3.2) => true
#+END_SRC

[[#contents][茶]]

** ne
:PROPERTIES:
:CUSTOM_ID: ne
:END:

Return true when the a does not equal b.

#+BEGIN_SRC
ne(a: int, b: int) bool
#+END_SRC

Examples:

#+BEGIN_SRC
ne(1, 1) => false
ne(2, 3) => true
#+END_SRC

[[#contents][茶]]

** ne
:PROPERTIES:
:CUSTOM_ID: ne
:END:

Return true when the a does not equal b.

#+BEGIN_SRC
ne(a: string, b: string) bool
#+END_SRC

Examples:

#+BEGIN_SRC
ne("tea", "tea") => false
ne("earl", "grey") => true
#+END_SRC

[[#contents][茶]]

** not
:PROPERTIES:
:CUSTOM_ID: not
:END:

Boolean not.

#+BEGIN_SRC
not(value: bool) bool
#+END_SRC

Examples:

#+BEGIN_SRC
not(true) => false
not(false) => true
#+END_SRC

[[#contents][茶]]

** or
:PROPERTIES:
:CUSTOM_ID: or
:END:

Boolean or with short circuit. If the first argument is true, the second argument is not evaluated.

#+BEGIN_SRC
or(a: bool, b: bool) bool
#+END_SRC

Examples:

#+BEGIN_SRC
or(true, true) => true
or(false, true) => true
or(true, false) => true
or(false, false) => false
or(true, warn("not hit")) => true
#+END_SRC

[[#contents][茶]]

** path
:PROPERTIES:
:CUSTOM_ID: path
:END:

Split a file path into its component pieces. Return a dictionary
with the filename, basename, extension and directory.

You pass a path string and the optional path separator, forward
slash or or backwards slash. When no separator, the current
system separator is used.

#+BEGIN_SRC
path(filename: string, optional separator: string) dict
#+END_SRC

Examples:

#+BEGIN_SRC
path("src/runFunction.nim") => {
  "filename": "runFunction.nim",
  "basename": "runFunction",
  "ext": ".nim",
  "dir": "src/",
}

path("src\runFunction.nim", "\") => {
  "filename": "runFunction.nim",
  "basename": "runFunction",
  "ext": ".nim",
  "dir": "src\",
}
#+END_SRC

[[#contents][茶]]

** replaceRe
:PROPERTIES:
:CUSTOM_ID: replaceRe
:END:

Replace multiple parts of a string using regular expressions.

You specify one or more pairs of regex patterns and their string
replacements.

#+BEGIN_SRC
replaceRe(str: string, pairs: list) string
#+END_SRC

Examples:

#+BEGIN_SRC
list = list("abc", "456", "def", "")
replaceRe("abcdefabc", list))
  => "456456"
#+END_SRC

For developing and debugging regular expressions see the
website: https://regex101.com/

[[#contents][茶]]

** replace
:PROPERTIES:
:CUSTOM_ID: replace
:END:

Replace a substring specified by its position and length with another string.  You can use the function to insert and append to
a string as well.

#+BEGIN_SRC
replace(str: string, start: int, length: int, replacement: string) string
#+END_SRC

- str: string
- start: substring start index
- length: substring length
- replacement: substring replacement

Examples:

Replace:
#+BEGIN_SRC
replace("Earl Grey", 5, 4, "of Sandwich")
  => "Earl of Sandwich"
replace("123", 0, 1, "abcd") => abcd23
replace("123", 0, 2, "abcd") => abcd3

replace("123", 1, 1, "abcd") => 1abcd3
replace("123", 1, 2, "abcd") => 1abcd

replace("123", 2, 1, "abcd") => 12abcd
#+END_SRC
Insert:
#+BEGIN_SRC
replace("123", 0, 0, "abcd") => abcd123
replace("123", 1, 0, "abcd") => 1abcd23
replace("123", 2, 0, "abcd") => 12abcd3
replace("123", 3, 0, "abcd") => 123abcd
#+END_SRC
Append:
#+BEGIN_SRC
replace("123", 3, 0, "abcd") => 123abcd
#+END_SRC
Delete:
#+BEGIN_SRC
replace("123", 0, 1, "") => 23
replace("123", 0, 2, "") => 3
replace("123", 0, 3, "") => ""

replace("123", 1, 1, "") => 13
replace("123", 1, 2, "") => 1

replace("123", 2, 1, "") => 12
#+END_SRC
Edge Cases:
#+BEGIN_SRC
replace("", 0, 0, "") =>
replace("", 0, 0, "a") => a
replace("", 0, 0, "ab") => ab
replace("", 0, 0, "abc") => abc
replace("", 0, 0, "abcd") => abcd
#+END_SRC

[[#contents][茶]]

** return
:PROPERTIES:
:CUSTOM_ID: return
:END:

Return the given value and control command looping. A return in a
statement causes the command to stop processing the current
statement and following statements in the command. You can
control whether the replacement block is output or not.

- "stop" -- stop processing the command
- "skip" -- skip this replacement block and continue with the next
- "" -- output the replacement block and continue

#+BEGIN_SRC
return(value: string) string
#+END_SRC

Examples:

#+BEGIN_SRC
if(c, return("stop"))
if(c, return("skip"))
if(c, return(""))
#+END_SRC

[[#contents][茶]]

** slice
:PROPERTIES:
:CUSTOM_ID: slice
:END:

Extract a substring from a string by its position and length. You
pass the string, the substring's start index and its length.  The
length is optional. When not specified, the slice returns the
characters from the start to the end of the string.

The start index and length are by unicode characters not bytes.

#+BEGIN_SRC
slice(str: string, start: int, optional length: int) string
#+END_SRC

Examples:

#+BEGIN_SRC
slice("Earl Grey", 1, 3) => "arl"
slice("Earl Grey", 6) => "rey"
slice("añyóng", 0, 3) => "añy"
#+END_SRC

[[#contents][茶]]

** sort
:PROPERTIES:
:CUSTOM_ID: sort
:END:

Sort a list of values of the same type.  The values are ints,
floats, or strings.

You specify the sort order, "ascending" or "descending".

You have the option of sorting strings case "insensitive". Case
"sensitive" is the default.

#+BEGIN_SRC
sort(values: list, order: string, optional insensitive: string) list
#+END_SRC

Examples:

#+BEGIN_SRC
ints = list(4, 3, 5, 5, 2, 4)
sort(list, "ascending") => [2, 3, 4, 4, 5, 5]
sort(list, "descending") => [5, 5, 4, 4, 3, 2]

floats = list(4.4, 3.1, 5.9)
sort(floats, "ascending") => [3.1, 4.4, 5.9]
sort(floats, "descending") => [5.9, 4.4, 3.1]

strs = list("T", "e", "a")
sort(strs, "ascending") => ["T", "a", "e"]
sort(strs, "ascending", "sensitive") => ["T", "a", "e"]
sort(strs, "ascending", "insensitive") => ["a", "e", "T"]
#+END_SRC

[[#contents][茶]]

** sort
:PROPERTIES:
:CUSTOM_ID: sort
:END:

Sort a list of lists.

You specify the sort order, "ascending" or "descending".

You specify how to sort strings either case "sensitive" or
"insensitive".

You specify which index to compare by.  The compare index value
must exist in each list, be the same type and be an int, float,
or string.

#+BEGIN_SRC
sort(lists: list, order: string, case: string, index: int) list
#+END_SRC

Examples:

#+BEGIN_SRC
l1 = list(4, 3, 1)
l2 = list(2, 3, 4)
listOfLists = list(l1, l2)
sort(listOfLists, "ascending", "sensitive", 0) => [l2, l1]
sort(listOfLists, "ascending", "sensitive", 2) => [l1, l2]
#+END_SRC

[[#contents][茶]]

** sort
:PROPERTIES:
:CUSTOM_ID: sort
:END:

Sort a list of dictionaries.

You specify the sort order, "ascending" or "descending".

You specify how to sort strings either case "sensitive" or
"insensitive".

You specify the compare key.  The key value must exist in
each dictionary, be the same type and be an int, float or
string.

#+BEGIN_SRC
sort(dicts: list, order: string, case: string, key: string) list
#+END_SRC

Examples:

#+BEGIN_SRC
d1 = dict("name", "Earl Gray", "weight", 1.2)
d2 = dict("name", "Tea Pot", "weight", 3.5)
dicts = list(d1, d2)
sort(dicts, "ascending", "sensitive", "weight") => [d1, d2]
sort(dicts, "descending", "sensitive", "name") => [d2, d1]
#+END_SRC

[[#contents][茶]]

** startsWith
:PROPERTIES:
:CUSTOM_ID: startsWith
:END:

Check whether a strings starts with the given prefix. Return true when it does, else false.

#+BEGIN_SRC
startsWith(str: string, str: prefix) bool
#+END_SRC

Examples:

#+BEGIN_SRC
a = startsWith("abcdef", "abc")
b = startsWith("abcdef", "abf")

a => true
b => false
#+END_SRC

[[#contents][茶]]

** string
:PROPERTIES:
:CUSTOM_ID: string
:END:

Convert the variable to a string.

#+BEGIN_SRC
string(var: any, optional stype: string) string
#+END_SRC

The default stype is "rb" which is used for replacement blocks.

stype:

- json -- returns JSON
- rb -- returns JSON except strings are not quoted and @ characters are not excaped. Rb stands for replacement block.
- dn -- returns JSON except dictionary elements are @ printed one per line as "key = value". Dn stands for dot name.

Examples variables:

#+BEGIN_SRC
str = "Earl Grey"
pi = 3.14159
one = 1
a = [1, 2, 3]
d = dict(["x", 1, "y", 2])
fn = cmp[[0]
found = true
#+END_SRC

json:

#+BEGIN_SRC
str => "Earl Grey"
pi => 3.14159
one => 1
a => [1,2,3]
d => {"x":1,"y":2}
fn => "cmp"
found => true
#+END_SRC

rb:

Same as JSON except the following.

#+BEGIN_SRC
str => Earl Grey
fn => "cmp"
#+END_SRC

dn:

Same as JSON except the following.

#+BEGIN_SRC
d =>
x = 1
y = 2
#+END_SRC

[[#contents][茶]]

** string
:PROPERTIES:
:CUSTOM_ID: string
:END:

Convert the dictionary variable to dot names were you specify the name of the dictionary.

#+BEGIN_SRC
string(dictName: string: d: dict) string
#+END_SRC

Example:

#+BEGIN_SRC
d = {"x",1, "y":"tea", "z":{"a":8}}
string("teas", d) =>

teas.x = 1
teas.y = "tea"
teas.z.a = 8
#+END_SRC

[[#contents][茶]]

** type
:PROPERTIES:
:CUSTOM_ID: type
:END:

Return the parameter type, one of: int, float, string, list, dict, bool or func.

#+BEGIN_SRC
type(variable: any) string
#+END_SRC

Examples:

#+BEGIN_SRC
type(2) => "int"
type(3.14159) => "float"
type("Tea") => "string"
type(list(1,2)) => "list"
type(dict("a", 1)) => "dict"
type(true) => "bool"
type(f.cmp) => "func"
#+END_SRC

[[#contents][茶]]

** values
:PROPERTIES:
:CUSTOM_ID: values
:END:

Create a list out of the values in the specified dictionary.

#+BEGIN_SRC
values(dictionary: dict) list
#+END_SRC

Examples:

#+BEGIN_SRC
d = dict("a", "apple", "b", 2, "c", 3)
keys(d) => ["a", "b", "c"]
values(d) => ["apple", 2, 3]
#+END_SRC

[[#contents][茶]]

** warn
:PROPERTIES:
:CUSTOM_ID: warn
:END:

Return a warning message and skip the current statement.

#+BEGIN_SRC
warn(message: string) string
#+END_SRC

Examples:

#+BEGIN_SRC
if0(c, warn("message is 0"))
b = if0(c, warn("c is not 0"), "")
#+END_SRC


# Dynamic Content Ends
* Contents :notoc:
:PROPERTIES:
:CUSTOM_ID: contents
:END:

# You run the command below to make the table of contents. Copy
# to scratch to remove the leading pound signs.
# grep '^\* ' readme.org | grep -v ":notoc" | cut -c 3- | \
# awk '{a = $0; gsub(" ", "-", a); printf "- [[#%s][%s]]\n", tolower(a), $0 }'

- [[#advantages][Advantages]]
- [[#how-it-works][How it Works]]
- [[#commands][Commands]]
- [[#replacement-block][Replacement Block]]
- [[#statements][Statements]]
- [[#syntax][Syntax]]
- [[#variables][Variables]]
- [[#single-letter-dictionaries][Single Letter Dictionaries]]
- [[#types][Types]]
- [[#boolean-expression][Boolean Expression]]
- [[#code-files][Code Files]]
- [[#multiline-strings][Multiline Strings]]
- [[#run-statictea][Run StaticTea]]
- [[#miscellaneous][Miscellaneous]]
- [[#functions][Functions]]

* Tea Info                                                            :notoc:

Tea plant: Camellia sinensis

Tea is the most popular manufactured drink consumed in the world,
equaling all others – including coffee, soft drinks, and alcohol
– combined. -- Wikipedia -- Macfarlane, Alan; Macfarlane, Iris
(2004). The Empire of Tea. The Overlook Press. p. 32. ISBN
978-1-58567-493-0.
