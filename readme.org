#+TITLE: StaticTea
A template processor and language.

StaticTea produces a file from a template and json data.

Example hello world html template:

#+BEGIN_SRC
<!--$ nextline -->
hello {s.name}
#+END_SRC

The associated json data:

#+BEGIN_SRC
{"name": "world"}
#+END_SRC

The result:

#+BEGIN_SRC
hello world
#+END_SRC

:PROPERTIES:
:testfile: testfiles/hello.stf
:END:

[[#contents][èŒ¶]] (table of contents at the bottom)

* Advantages
:PROPERTIES:
:CUSTOM_ID: advantages
:END:

You can view, edit and validate your templates with its normal
tools as if they were static pages.

The template designer has full control over the presentation.
You can change the look without changing the server.

You can share common template fragments between templates.

In a general sense StaticTea is a program and language for
formatting json.

[[#contents][èŒ¶]]

* How it Works
:PROPERTIES:
:CUSTOM_ID: how-it-works
:END:

You create a template and add commands to wrap the variable
content called the replacement block.

In the replacement block you add variables in brackets for
substitutions.

In the commands you format your json variables or you create new
variables for the replacement block.

You specify the commands so they look like comments for your
template type.

[[#contents][èŒ¶]]

* Commands

A StaticTea command marks replacement content in the template and
it provides a place for your code statements.

- [[#nextline-command][nextline]] -- make substitutions in the next line
- [[#block-command][block]] â€”- make substitutions in the next block of lines
- [[#replace-command][replace]] -â€” replace the block with a variable
- [[#endblock-command][endblock]] -- end the block and replace commands
- # ([[#comment-command][comment]]) -- code comment
- : ([[#continue-command][continue]]) -- continue a command

[[#contents][èŒ¶]]

** Nextline Command
:PROPERTIES:
:CUSTOM_ID: nextline-command
:testfile: testfiles/nextline.stf
:END:

The nextline command targets the line following it for
replacement. The targeted line is called the replacement block.

The following example's replacement block contains two variables,
drink and drinkType.

template:

#+BEGIN_SRC
<!--$ nextline -->
Drink {s.drink} -- {s.drinkType} is my favorite.
#+END_SRC

server json:

#+BEGIN_SRC
{
  "drink": "tea",
  "drinkType": "Earl Grey"
}
#+END_SRC

result:

#+BEGIN_SRC
Drink tea -- Earl Grey is my favorite.
#+END_SRC

[[#contents][èŒ¶]]

** Block Command
:PROPERTIES:
:CUSTOM_ID: block-command
:testfile: testfiles/block.stf
:END:

The block command targets multiple lines for replacement. The
replacement block starts after the command and continues until
the endblock line is found. It behaves like the nextline command
except with multiple lines.

In the following example the block has three lines. The block
contains three replacement variables, weekday, name and time.

template:

#+BEGIN_SRC
<!--$ block -->
Join our tea party on
{s.weekday} at {s.name}'s
house at {s.time}.
<!--$ endblock -->
#+END_SRC

server json:

#+BEGIN_SRC
{
  "weekday": "Friday",
  "name": "John",
  "time": "5:00 pm"
}
#+END_SRC

result:

#+BEGIN_SRC
Join our tea party on
Friday at John's
house at 5:00 pm.
#+END_SRC

[[#contents][èŒ¶]]

** Replace Command
:PROPERTIES:
:CUSTOM_ID: replace-command
:testfile: testfiles/replace.stf
:testfile2: testfiles/replace2.stf
:testfile3: testfiles/replace3.stf
:END:

The replace command's replacement block gets replaced with the
t.content variable.

The lines in the block mirror the variable so you can
test the template as if it was a static file.

The command is useful for sharing common template lines between
templates and it has the special property that you can keep the
replacement block in sync with the variable, see [[#update-option][Update Option]]
for more information.

If you don't assign the t.content variable, a warning is
generated, and the command behaves like a block command.  This is
good for testing changes you want to make to the shared value.

The following example uses a common header from the shared json.

template:

#+BEGIN_SRC
<!--$ replace t.content=h.header -->
<!--$ endblock -->
#+END_SRC

shared json:

#+BEGIN_SRC
{
  "header": "<!doctype html>\n<html lang=\"en\">\n"
}
#+END_SRC

result:

#+BEGIN_SRC
<!doctype html>
<html lang="en">
#+END_SRC

The above example generates the correct result but it doesnâ€™t
work as a static template because the template is missing the
header lines.

You can fix this by adding the header lines inside the replace
command's replacement block. The lines do not appear in the
result, just the data from the json header variable.

template:

#+BEGIN_SRC
<!--$ replace t.content=h.header -->
<!doctype html>
<html lang="en">
<!--$ endblock -â€”>
#+END_SRC

The shared variable may contain replacement content too.  Here is
an example of that:

template:

#+BEGIN_SRC
<!--$ replace t.content=h.header -->
<!DOCTYPE html>
<html lang="{s.languageCode}" dir="{s.languageDirection}">
<head>
<meta charset="UTF-8"/>
<title>{s.title}</title>
<--$ endblock -->
#+END_SRC

server json:

#+BEGIN_SRC
{
"languageCode": "en",
"languageDirection": "ltr",
"title": "Teas in England"
}
#+END_SRC

shared json:

#+BEGIN_SRC
{
  "header": "<!DOCTYPE html>
<html lang=\"{s.languageCode}\" dir=\"{s.languageDirection}\">
<head>
<meta charset=\"UTF-8\"/>
<title>{s.title}</title>\n"
}
#+END_SRC

result:

#+BEGIN_SRC
<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8"/>
<title>Teas in England</title>
#+END_SRC

[[#contents][èŒ¶]]

** Comment Command
:PROPERTIES:
:CUSTOM_ID: comment-command
:testfile: testfiles/comment.stf
:END:

You can comment templates with the comment command.  Comments
are line based and use the # character. They do not appear in the
result.

template:

#+BEGIN_SRC
<!--$ # The main tea groups. -->
There are five main groups of teas:
white, green, oolong, black, and pu'erh.
You make Oolong Tea in five time
intensive steps.
#+END_SRC

result:

#+BEGIN_SRC
There are five main groups of teas:
white, green, oolong, black, and pu'erh.
You make Oolong Tea in five time
intensive steps.
#+END_SRC

[[#contents][èŒ¶]]

** Continue Command
:PROPERTIES:
:CUSTOM_ID: continue-command
:testfile: testfiles/continue.stf
:END:

The continue command allows you to continue adding statements to
the nextline, block and replace commands.

In the following example the nextline command continues on a
second line and third line.

template:

#+BEGIN_SRC
$$ nextline
$$ : tea = "Earl Grey"
$$ : tea2 = "Masala chai"
{tea}, {tea2}
#+END_SRC

result:

#+BEGIN_SRC
Earl Grey, Masala chai
#+END_SRC

[[#contents][èŒ¶]]

** Endblock Command
:PROPERTIES:
:CUSTOM_ID: endblock-command
:testfile: testfiles/endblock.stf
:END:

The endblock command ends the replacement block for the block and
replace commands. Only the endblock command ends them. All text
until the endblock is part of the replacement block. This
includes lines that look like commands. For example:

template:

#+BEGIN_SRC
<!--$ block -->
<!--$ # this is not a comment, just text -->
fake nextline
<!--$ nextline -->
<!--$ endblock -->
#+END_SRC

result:

#+BEGIN_SRC
<!--$ # this is not a comment, just text -->
fake nextline
<!--$ nextline -->
#+END_SRC

[[#contents][èŒ¶]]

* Replacement Block
:PROPERTIES:
:CUSTOM_ID: replacement-block
:END:

A replacement block is a group of contiguous lines in a template
between a command and its endblock. For the nextline case the
block is one line.

The block contains any number of bracketed variables for
substitution.

Each string variable gets replaced with it value. The other
variable types get replace with their json equivalent.

You can repeat the block to make lists and other repeating
content. You control how many times the block repeats with the
t.repeat variable.  The t.row counts the number of times the
block has repeated and you use its value to customize each
repeated block.

[[#contents][èŒ¶]]

* Statements
:PROPERTIES:
:CUSTOM_ID: statements
:testfile: testfiles/statements.stf
:END:

You format server variables by creating new variables with
statements.

A statement is an expression consisting of a variable, an equal
sign, and a right hand side. The right hand side is either
another variable, a string, a number or a function.

All operations are done with functions except the two equal
operators. Looping is done at the replacement block level with
t.repeat and t.row. Output control is done with t.output.

Statements are allowed on the nextline, block and replace
commands. If you need more space for a statement, you can
continue the line with the "+" character at the end. Statements
are executed from top to bottom.

Here are some simple statements:

#+BEGIN_SRC
tea = "Earl Grey"
num = 5
t.repeat = 2
nameLen = len(s.name)
name = concat(substr(s.name, 0, 7), "...")
#+END_SRC

[[#contents][èŒ¶]]

* Syntax
:PROPERTIES:
:CUSTOM_ID: syntax
:testfile: testfiles/syntax.stf
:END:

A template consists of command lines and non-command lines.  The
command lines are line oriented and they have the same form and
they are limited to 1024 bytes. There are no restrictions on the
non-command lines in a template.

Each command line is a comment to match the template type. The
beginning comment characters are called the prefix and the
optional ending comment characters are called the postfix. For
example, in an html template the prefix is "<!--$" and the
postfix is "-->". See [[#prefix-postfix][Prefix Postfix]] for more information.

- The prefix starts at column 1.
- Next comes the command name.
- An optional statement follows the command name.
- At the end of the line is an optional plus continuation
  character
- then the optional postfix
- then the end of line, either \r\n or \n.

The chart below shows a nextline command with three continuation
commands and three statements: a = 5, b = "tea" and c = "The Earl
of Grey".

#+BEGIN_SRC
prefix
|     command
|     |        statement
|     |        |         continuation
|     |        |         |
|     |        |         |postfix
|     | +------+         ||  newline
|     | |      |         ||  |
<!--$ nextline a = 5      -->
<!--$ : b = "tea"         -->
<!--$ : c = "The Earl of +-->
<!--$ : Grey"             -->

#+END_SRC

A space or tab is required between a command and a statement,
otherwise you can use zero or more tabs and spaces where they are
allowed. Space isn't allowed before the prefix, after the
continuation or after the postfix or between the function name
and its opening parentheses. Here are a few single line examples:

#+BEGIN_SRC
$$nextline
$$ nextline
$$ nextline a=5
$$ nextline a = 5
$$ nextline num = len(s.tea_list)
$$ nextline num = len( s.tea_list )
#+END_SRC

The statements may flow between lines by using the continuation
plus character. The following two nextline commands are
equivalent:

#+BEGIN_SRC
<!--$ nextline com = "Bigelow Tea Company" -->

<!--$ nextline com = "Big+-->
<!--$ : elow Tea Company" -->
#+END_SRC

You can have blank statements that do nothing.

#+BEGIN_SRC
$$ nextline
$$ :
$$ : a = 5
#+END_SRC

[[#contents][èŒ¶]]

* Variables
:PROPERTIES:
:CUSTOM_ID: variables
:END:

You use variables to add variable content to your template in its
replacement blocks.

You use tea variables to control where the output goes, how many
times it repeats and other aspects controlling a command.

A variable name starts with a letter followed by letters, digits
and underscores limited to a total of 64 ascii characters.

Local variables and most tea variables, except row, args and
version, are cleared after processing each replacement block.

You can append a new variable to a list or dictionary but you
cannot change an existing variable.

[[#contents][èŒ¶]]

* Single Letter Dictionaries
:PROPERTIES:
:CUSTOM_ID: single-letter-dictionaries
:END:

Statictea reserves single letters variable names f - u to refer
to important dictionaries. Five are currently used: g, h, l, s,
t.  You can use single letters a, b, c, d, e and v, w, x, y, z
for your variable names.

- f -- Reserved
- g -- [[#global-variables][Global Variables]]
- h -- [[#json-variables][Shared Json Variables]]
- i, j, k -- Reserved
- l -- [[#local-variables][Local Variables]]
- m, n, o, p, q, r -- Reserved
- s -- [[#json-variables][Server Json Variables]]
- t -- [[#tea-variables][Tea Variables]]
- u -- Reserved

[[#contents][èŒ¶]]

** Json Variables
:PROPERTIES:
:CUSTOM_ID: json-variables
:testfile: testfiles/truefalsenull.stf
:END:

You pass variables to the template in json files.

The variables are defined by the top level dictionary items. Each
item's key is the name of a variable and the item's value is
the variables' value.

There are two types of json files, the server json and the shared
json. The server file populates the s dictionary and the
shared file populates the h dictionary.

You can use multiple server and shared json files by specifying
multiple files on the command line. The files are processed
left to right.

The json null values get converted to the 0. Json True and False
get converted to 1 and 0.

To give full control of the presentation to the template
designers, the server json shouldn't contain any presentation
data.

The shared json is created and maintained by the template
designer for sharing common template fragments and other
presentation needs.

[[#contents][èŒ¶]]

** Local Variables
:PROPERTIES:
:CUSTOM_ID: local-variables
:testfile: testfiles/localvars.stf
:END:

You create local variables with template statements.  They are
local to the command where they are defined. You do not have to
specify a prefix for local variables but you can use l. They are
stored in the l dictionary. The local variables are cleared and
recalculated for each repeated block.

[[#contents][èŒ¶]]

** Global Variables
:PROPERTIES:
:CUSTOM_ID: global-variables
:testfile: testfiles/globalvars.stf
:END:

Like local variables, you create global variables with template
statements.  All commands have access to them and they are stored
in the g dictionary.

[[#contents][èŒ¶]]

** Tea Variables
:PROPERTIES:
    :CUSTOM_ID: tea-variables
    :END:

The tea variables control how the replacement block works and
they provide information about the system.  They are stored in
the t dictionary.

Tea variables:

- [[#targs][t.args]] -- arguments passed on the command line
- [[#tcontent][t.content]] -- content of the replace block
- [[#tmaxrepeat][t.maxRepeat]] -- maximum number of times to repeat the block
- [[#tmaxlines][t.maxLines]] -- maximum number of replacement block lines allowed
  before the endblock
- [[#toutput][t.output]] -- where the block output goes
- [[#trepeat][t.repeat]] -- how many times the block repeats
- [[#trow][t.row]] -- the current index number of a repeating block
- [[#tversion][t.version]] -- the StaticTea version number

[[#contents][èŒ¶]]

*** t.args
:PROPERTIES:
:CUSTOM_ID: targs
:testfile: testfiles/targs.stf
:END:

The t.args variable contains the arguments passed to
statictea on the command line.

For example using the command line below results in a t.args
value shown:

#+BEGIN_SRC
statictea -l -s=server.json -j=shared.json \
  -s=server2.json -j=shared2.json \
  -p='abc$,def' -p='$$' \
  -t=template.html -r=result.html

t.args => {
  "help":0,
  "version":0,
  "update":0,
  "log":1,
  "serverList":["server.json","server2.json"],
  "sharedList":["shared.json","shared2.json"],
  "resultFilename":"result.html",
  "templateList":["template.html"],
  "logFilename":"",
  "prepostList":[["abc$","def"],["$$",""]]
}
#+END_SRC

[[#contents][èŒ¶]]

*** t.content
:PROPERTIES:
:CUSTOM_ID: tcontent
:END:

The t.content variable determines the content used for the
whole replace block.

#+BEGIN_SRC
t.content = h.header
#+END_SRC

You use [[#update-option][Update Option]] to keep the template's blocks in sync with
their variables.

When t.content is not set, the command behaves like a block
command except a warning message is output. This is good for
testing changes you want to make to the shared value and the
warning reminds you to set the variable when you're done testing.

The variable only applies to the replace command. See the
[[#replace-command][replace command]] section for an example.

[[#contents][èŒ¶]]

*** t.maxRepeat
:PROPERTIES:
:CUSTOM_ID: tmaxrepeat
:testfile: testfiles/maxrepeat.stf
:END:

The t.maxRepeat variable determines the maximum times a block can
repeat.  The default is 100. You can increase it to repeat more
times. You cannot assign a number to t.repeat bigger than
maxRepeat.

It prevents the case where you mistakenly assign a giant number,
and it allows you to design your template to work well for the
expected range of blocks.

[[#contents][èŒ¶]]

*** t.maxLines
:PROPERTIES:
:CUSTOM_ID: tmaxlines
:END:

The t.maxLines variable determines the maximum lines in a
replacement block.

StaticTea reads lines looking for the endblock.  By default, if
it is not found in 50 lines, the 50 lines are used for the block
and a warning is output. This catches the case where you forget
the endblock command. You can increase or decrease the value.

#+BEGIN_SRC
<!--$ block t.maxLines=200 -->
#+END_SRC

[[#contents][èŒ¶]]

*** t.output
:PROPERTIES:
    :CUSTOM_ID: toutput
    :END:

The t.output variable determines where the block output goes.  By
default it goes to the result file.

- "result" -- to the result file (default)
- "stdout" -- to standard out
- "stderr" -- to standard error
- "log" -- to the log file
- "skip" -- to the bit bucket

[[#contents][èŒ¶]]

*** t.repeat
    :PROPERTIES:
    :CUSTOM_ID: trepeat
    :END:

The t.repeat variable is an integer that tells how many times to
repeat the block. A value of 0 means don't show the block at
all. If you don't set it, the block repeats one time.

Each time the block repeats the local variables get cleared then
recalculated.

The t.row variable counts the number of times the block repeats
and is used with t.repeat to customize each block.

You cannot assign a number bigger than t.maxRepeat to
t.repeat. You can set t.maxRepeat to anything you want, the
default is 100.

For the following example, the number of items in teaList is
assigned to the t.repeat variable which outputs the block five
times.

template:

#+BEGIN_SRC
<!--$ nextline t.repeat = len(s.teaList) -->
<!--$ : tea = get(s.teaList, t.row) -->
 * {tea}
#+END_SRC

server json:

#+BEGIN_SRC
{
"teaList": [
  "Black",
  "Green",
  "Oolong",
  "Sencha",
  "Herbal"
]
}
#+END_SRC

result:

#+BEGIN_SRC
 * Black
 * Green
 * Oolong
 * Sencha
 * Herbal
#+END_SRC

The following example builds an html select list of tea companies
with the Twinings company selected and it shows how to access
values from dictionaries.

template:

#+BEGIN_SRC
<h3>Tea Companies</h3>
<select>
<!--$ block t.repeat=len(s.companyList) -->
<!--$ : d = get(s.companyList, t.row) -->
<!--$ : selected = get(d, "selected", 0) -->
<!--$ : current = if0(selected, "", +-->
<!--$ :   " selected=\"selected\"") -->
  <option{current}>{d.company}</option>
$$ endblock
</select>
#+END_SRC

server json:

#+BEGIN_SRC
{
"companyList": [
  {"company": "Lipton"},
  {"company": "Tetley"},
  {"company": "Twinings", "selected": 1},
  {"company": "American Tea Room"},
  {"company": "Argo Tea"},
  {"company": "Bigelow Tea Company"}
]
}
#+END_SRC

result:

#+BEGIN_SRC
<h3>Tea Companies</h3>
<select>
  <option>Lipton</option>
  <option>Tetley</option>
  <option selected="selected">Twinings</option>
  <option>American Tea Room</option>
  <option>Argo Tea</option>
  <option>Bigelow Tea Company</option>
</select>
#+END_SRC

Setting t.repeat to 0 is good for building test lists.

When you view the following template fragment in a browser it
shows one item in the list.

template:

#+BEGIN_SRC
<h3>Tea</h3>
<ul>
<!--$ nextline t.repeat = len(s.teaList)-->
<!--$ : tea = get(s.teaList, t.row) -->
  <li>{tea}</li>
</ul>
#+END_SRC

server json:

#+BEGIN_SRC
{
"teaList": [
  "Black",
  "Green",
  "Oolong",
  "Sencha",
  "Herbal"
]
}
#+END_SRC

To create a static page that has more products for better testing
you could create a test list of teas using t.repeat of 0, that appear
when testing but not when generating the final result. In the
following example the test list will show: {tea}, Chamomile,
Chrysanthemum, White, and Puer.

template:

#+BEGIN_SRC
<h3>Tea</h3>
<ul>
<!--$ nextline t.repeat = len(s.teaList) -->
<!--$ : tea = get(s.teaList, t.row) -->
  <li>{tea}</li>
<!--$ block t.repeat = 0 -->
  <li>Chamomile</li>
  <li>Chrysanthemum</li>
  <li>White</li>
  <li>Puer</li>
<!--$ endblock -->
</ul>
#+END_SRC

result:

#+BEGIN_SRC
<h3>Tea</h3>
<ul>
  <li>Black</li>
  <li>Green</li>
  <li>Oolong</li>
  <li>Sencha</li>
  <li>Herbal</li>
</ul>
#+END_SRC

[[#contents][èŒ¶]]

*** t.row
    :PROPERTIES:
    :CUSTOM_ID: trow
    :END:

The t.row variable contains the current row number for blocks
that repeat. The row numbers start at 0 and increase.  You use it
to format lists and other repeating content in the template.

Here is an example using the row variable.  In the example the
row is used in three places.

template:

#+BEGIN_SRC
<ul>
<!--$ nextline t.repeat=len(s.companies)-->
<!--$ : company = get(s.companies, t.row) -->
<!--$ : num = add(t.row, 1) -->
  <li id="r{t.row}">{num}. {company}</li>
</ul>
#+END_SRC

server json:

#+BEGIN_SRC
{
  "companies": [
    "Mighty Leaf Tea",
    "Numi Organic Tea",
    "Peet's Coffee & Tea",
    "Red Diamond"
  ]
}
#+END_SRC

result:

#+BEGIN_SRC
<ul>
  <li id="r0">1. Mighty Leaf Tea</li>
  <li id="r1">2. Numi Organic Tea</li>
  <li id="r2">3. Peet's Coffee & Tea</li>
  <li id="r3">4. Red Diamond</li>
</ul>
#+END_SRC

[[#contents][èŒ¶]]

*** t.version
:PROPERTIES:
:CUSTOM_ID: tversion
:END:

The t.version variable contains the current version number of
StaticTea. See the [[#cmpversion][cmpVersion]] function for more information.

[[#contents][èŒ¶]]

* Types
:PROPERTIES:
:CUSTOM_ID: types
:END:

StaticTea variable types:

- [[#string][string]]
- [[#int][int]]
- [[#float][float]]
- [[#dict][dict]]
- [[#list][list]]

[[#contents][èŒ¶]]

** String
:PROPERTIES:
:CUSTOM_ID: string
:END:

A string is an immutable sequence of unicode characters. You
define a literal string with double quotes.

The example below defines a literal string and assigns it to the
variable str:

#+BEGIN_SRC
str = "You can store black teas longer than green teas."
#+END_SRC

Strings are encoded as UTF-8 and invalid byte sequences generate
a warning.

Strings follow the same escaping rules as json strings.  You can
escape 8 special control characters using a slash followed by a
letter. Special escape letters:

- " -> quotation mark (U+0022)
- \ -> reverse solidus (U+005C)
- / -> solidus (U+002F)
- b -> backspace (U+0008)
- f -> form feed (U+000C)
- n -> line feed (U+000A)
- r -> carriage return (U+000D)
- t -> tab (U+0009)

Examples with escaping:

- "ending newline\n"
- "tab \t in the middle"
- "Mad Hatter: \\\"... you must have a cup of tea!\\\" - 'Alice In Wonderland'."
- "Unicode tea character 'èŒ¶' is '\u8336'"
- "smiley face ðŸ˜€ by escaping: \uD83D\uDE00."

You can enter any unicode value with \u and four hex digits or, for
values greater the U-FFFF, two pairs.  The two pairs are
called surrogate pairs.

#+BEGIN_SRC
The unicode code point U-8336 is èŒ¶ and escaped is \u8336.
The unicode code point U-1F600 is ðŸ˜€ and escaped is \uD83D\uDE00.
#+END_SRC

You can generate the surrogate pair for a unicode code point
using Russell Cottrell's surrogate pair calculator:
[[http://russellcottrell.com/greek/utilities/SurrogatePairCalculator.htm][
Surrogate Pair Calculator]].

[[#contents][èŒ¶]]

** Int
:PROPERTIES:
:CUSTOM_ID: int-type
:END:

An int is a 64 bit signed integer.  Plus signs are not used
with numbers.

Example numbers:

#+BEGIN_SRC
12345
0
-8823
42
#+END_SRC

[[#contents][èŒ¶]]

** Float
:PROPERTIES:
:CUSTOM_ID: float-type
:END:

A float is a 64 bit real number, it has a decimal point and
starts with a digit or minus sign.

Example floats:

#+BEGIN_SRC
3.14159
24.95
0.123
-34.0
#+END_SRC

[[#contents][èŒ¶]]

** Dict
:PROPERTIES:
:CUSTOM_ID: dict-type
:END:

The dict type is an ordered key value store with fast lookup. It
maps a string key to a value which can be any type. The dict is
ordered by insertion order.

- You create a dict in a json file or with the dict function.
- You append to a dict when you create new variables.
- You access dict items with variable names or with the get
  function.

In the following json data, the container element is a dictionary and
the d element is a dictionary.  The d dictionary has two key/value
pairs, ("x", 100) and ("y", 200).

server json:

#+BEGIN_SRC
{
  "a": 1,
  "b": 2,
  "d": {
    "x": 100,
    "y": 200
  }
}
#+END_SRC

If the key is a valid variable name, you can access it using dot
notation. For the json example above, you can access the data as:

#+BEGIN_SRC
s.a => 1
s.b => 2
s.d.x => 100
s.d.y => 200
#+END_SRC

Or you access the elements with the get function. The get
function has an optional default parameter and it works with keys
that don't look like variables.  Examples:

#+BEGIN_SRC
get(s, "a") => 1
get(s, "b") => 2
get(s, "d") => dict("x", 100, "y", 200)

d = get(s, "d")
get(d, "x") => 100
get(d, "y") => 200
#+END_SRC

[[#contents][èŒ¶]]

** List
:PROPERTIES:
:CUSTOM_ID: list-type
:END:

A list contains a sequence of values of any type.

You can create a list with the list function:

#+BEGIN_SRC
list() => []
list(1) => [1]
list(1, 2, 3) => [1, 2, 3]
list("a", 5, "b") => ["a", 5, "b"]
#+END_SRC

You can append to a list by assigning a value to a variable with
the &= operator.  It will create the list if it doesn't exist. In
the example below, the first line creates the list variable then
assign "black" to it.  The second line appends "green":

#+BEGIN_SRC
teas &= "black"
teas &= "green"
teas => ["black", "green"]
#+END_SRC

The next example creates a g.names list from names contained in a
list of dictionaries:

#+BEGIN_SRC
$$ block
$$ : t.repeat = len(s.entries)
$$ : entry = get(s.entries, t.row)
$$ : g.names &= entry.name
$$ endblock
#+END_SRC

You can access list elements with the get function:

#+BEGIN_SRC
list = list(1, 3.3, "a")
get(list, 0) => 1
get(list, 1) => 3.3
get(list, 2) => "a"
get(list, 3, 99) => 99
#+END_SRC

[[#contents][èŒ¶]]

* Run StaticTea
:PROPERTIES:
:CUSTOM_ID: run-statictea
:END:

You run StaticTea from the command line. You specify the template
file to process along with the json data files and a result file
is generated.

- Warning messages go to standard error.
- If you don't specify the result file, the result goes to standard out.
- If you specify "stdin" for the template, the template comes
  from stdin.
- StaticTea returns success, return code 0, when there are no
  warning messages, else it returns 1.

The example below shows a typical invocation which specifies four
file arguments, the server json, the shared json, the template
and the result.

#+BEGIN_SRC
statictea \
  --server server.json \
  --shared shared.json \
  --template template.html \
  --result result.html
#+END_SRC

The StaticTea command line options:

- help -- show options and usage documentation.
- version -- outputs the version number.
- server -- the server json file(s), you can specify multiple.
- shared -- the shared json file(s), you can specify multiple.
- template -- the template file, or "stdin" for input from
  standard input.
- result -- the result file, or standard out when not specified.
- update -- update the template replace blocks. See the
  [[#replace-command][Replace Command]].
- prepost -- add a command prefix and postfix, you can specify
  multiple. When you specify values, the defaults are no longer
  used. See the [[#prefix-postfix][Prefix Postfix]] section.
- log - log to a file, see [[#log-file][Log File]] section.

[[#contents][èŒ¶]]

* Miscellaneous
:PROPERTIES:
:CUSTOM_ID: miscellaneous
:END:

Miscellaneous topics:

- [[#warning-messages][Warning Messages]]
- [[#prefix-postfix][Prefix Postfix]]
- [[#encoding-and-line-endings][Encoding and Line Endings]]
- [[#update-option][Update Option]]
- [[#logging][Logging]]
- [[#module-docs][Module Docs]]
- [[#html-formatted-json][HTML Formatted Json]]
- [[#nimble-tasks][Nimble Tasks]]
- [[#stf-runner][Stf Runner]]
- [[#example-templates][Example Templates]]

** Warning Messages
:PROPERTIES:
   :CUSTOM_ID: warning-messages
   :END:

When StaticTea detects a problem, a warning message is written to
standard error, the problem is skipped, and processing
continues.

For example, if a variable in a replacement block is used but it
doesn't exist, the bracketed variable remains as is in the
result, and a message is output to standard error. There are many
other potential warnings.

Itâ€™s good style to change your template to be free of messages.

Each warning message shows the file and line number where the
problem happened.

example messages:

- tea.html(0): w15: "Unable to parse the json file. Skipping file: test.json.
- tea.html(45): w61: No space after the command.
- tea.html(121): w52: The get function takes 2 or 3 parameters.
- tea.html(243): w36: The variable 'teaMaster' does not exist.
- tea.html(3044): w47: Concat parameter 45 is not a string."

Statement errors generate multi-line messages showing the
statement and problem location, for example:

#+BEGIN_SRC
template.html(16): w33: Expected a string, number, variable or function.
statement: tea = len("abc",)
                           ^
#+END_SRC

Statictea returns success, return code 0, when there are no
warning messages, else it returns 1.

Example of running statictea when a variable is missing:

template:

#+BEGIN_SRC
<!--$ block -->
You're a {s.webmaster},
I'm a {s.teaMaster}!
<!--$ endblock -->
#+END_SRC

server json:

#+BEGIN_SRC
{
 "webmaster": "html wizard"
}
#+END_SRC

stderr:

#+BEGIN_SRC
template.html(3): w58: The replacement variable doesn't exist: s.teaMaster.
#+END_SRC

result:

#+BEGIN_SRC
You're a html wizard,
I'm a {s.teaMaster}!
#+END_SRC

[[#contents][èŒ¶]]

** Prefix Postfix
:PROPERTIES:
   :CUSTOM_ID: prefix-postfix
   :END:

You make the template commands look like comments tailored for
your template file type. This allows you to edit the template
using its native editors and run other native tools.  For example,
you can edit a StaticTea html template with an html editor and
validate it online with w3.org's validator.

Comment syntax varies depending on the type of template file and
sometimes depending on the location within the file. StaticTea
supports several varieties and you can specify others.

You want to distinguish StaticTea commands from normal comments
when you create your own. The convention is to add a $ as the
last character of the prefix and only use $ with StaticTea
commands and space for normal comments.

Some file types, like markdown, don't support comments, for
them use $$.

Built in Prefixes:

- html: <!--$ and -->
- html: &lt;!--$ and --&gt; for textarea elements
- bash: #$
- org mode: # $
- config files: ;$
- C++: //$
- C language: â€‹/\star$ and \starâ€‹/
- markdown: $$

You can define other comment types on the command line using the
prepost option one or more times. When you specify your own
prepost values, the defaults no longer exist so you have control
of which prefixes get used.

You specify the prepost option with the prefix separated from the
postfix with a comma and the postfix is optional,
"prefix[,postfix]". A prefix and postfix contain 1 to 20 ascii
characters including spaces but without control characters or
commas.

examples:

#+BEGIN_SRC
--prepost="pre$,post"
--prepost="a$,b"
--prepost="@$,|"
--prepost="#[$,]#"
--prepost="# $"
#+END_SRC

[[#contents][èŒ¶]]

** Encoding and Line Endings
:PROPERTIES:
:CUSTOM_ID: encoding-and-line-endings
:END:

Templates are utf-8 encoded.  Two line endings are supported on
all platforms: LF, and CR/LF.  Line endings are preserved.  The
template syntax only uses ascii except unicode characters in
strings. The maximum command line length is 1024 bytes. There is
no limit on non-command lines.

Since line endings are preserved and there are no encoding or
line length restrictions on non-command lines, you can make
templates out of binary or mixed binary and text files like EPS
or PDF files.

[[#contents][èŒ¶]]

** Update Option
:PROPERTIES:
:CUSTOM_ID: update-option
:END:

The update option updates the template's replace blocks to
match their t.content text.  The text normally comes from the
shared template files but it doesn't have to.

You use this to keep the template blocks in sync with the shared
content so you can work with them as static pages.

If the t.content does not end with a newline, one is added so the
endcommand starts on a new line.

The following example shows a typical invocation:

#+BEGIN_SRC
statictea \
  --server server.json \
  --shared shared.json \
  --template template.html \
  --update
#+END_SRC

[[#contents][èŒ¶]]

** Logging
:PROPERTIES:
   :CUSTOM_ID: logging
   :END:

Statictea writes statistics to the log file.  Template commands
can also write to the log file.

Log information is appended to the file.  When the file size
exceeds 1 GB, a warning message is generated each time a template
is processed.

Logging is off by default. You turn it on with the log option.
If you don't specify a filename, the log lines are written to the
platform default location:

- Mac: ~/Library/log/statictea.log
- Other: ~/statictea.log

You can specify a full path. If you don't include path
information, the log is written to the current directory.

#+BEGIN_SRC
statictea --log=mylog.txt
#+END_SRC

When you write a replacement block to the log file, the template
file and line of the block appear there.

#+BEGIN_SRC
2021-12-07 22:03:59.908; statictea.nim(42); Starting: argv: @["-l=log.txt", "-t=tmpl.txt", "-r=result.txt"]
2021-12-07 22:03:59.908; statictea.nim(43); Version: 0.1.0
2021-12-07 22:03:59.909; tmpl.txt(2); â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
2021-12-07 22:03:59.909; tmpl.txt(3); â”‚log blockâ”‚
2021-12-07 22:03:59.909; tmpl.txt(4); â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
2021-12-07 22:03:59.910; statictea.nim(66); Warnings: 0
2021-12-07 22:03:59.910; statictea.nim(69); Return code: 0
2021-12-07 22:03:59.910; statictea.nim(70); Done
#+END_SRC

[[#contents][èŒ¶]]

** Module Docs
:PROPERTIES:
   :CUSTOM_ID: module-docs
   :END:

You can read the StaticTea source code documentation in Github
because it is formatted as github markdown. Statictea created the
markdown files from the source code's embedded doc comments.

- [[docs/index.md][StaticTea Source Docs]] --- Index to the
  source code documents.

The nimble *docsix* task builds the module index by running the
following process:

1. create a json file from the doc comments at the top of all the source files
2. format the json as markdown using the
   [[templates/nimModuleIndex.md][nimModuleIndex.md]] statictea
   template. Click the link then "View Raw".

The nimble *docs* task builds the module markdown files by running
the following process for each module:

1. create a json file of a module's docs using nim's jsondoc command
2. format the json as markdown using the [[templates/nimModule.md][nimModule.md]] statictea template

[[#contents][èŒ¶]]

** HTML Formatted Json
:PROPERTIES:
   :CUSTOM_ID: html-formatted-json
   :END:

The nim jsondoc command produces html formatted json data.  Our
desired final format is Github markdown so having html
presentation data in the json is a problem.

It was discovered that single paragraph comments are unformatted.
This is the basis for a workaround. You make all the
documentation look like one paragraph by inserting some symbols
in strategic places, then the json data does not contain html
formatting.

Workaround Rules:

- use @: at the beginning of lines, except the first line.
- use ~~~ to begin a code block
- use ~~~~ to end a code block
- use @{ for [ in an http link
- use }@ for ] in an http link
- use @@: for a : in an http link

#+BEGIN_SRC
[Semantic Versioning](https://semver.org/)
@{Semantic Versioning}@(https@@://semver.org/)
#+END_SRC

[[#contents][èŒ¶]]

** Nimble Tasks
:PROPERTIES:
   :CUSTOM_ID: nimble-tasks
   :END:

You can run commands to build, test, make docs etc. using nimble
task commands. Run them from the statictea root folder. The n
task lists the available tasks. Create an alias for nimble.

#+BEGIN_SRC
alias n='nimble --silent'
cd ~/code/statictea
n n
#+END_SRC

Here is the output:

#+BEGIN_SRC
n           Show available tasks.
t           Run all tests at once.
test        Run one or more tests; specify part of test filename.
b           Build the statictea exe.
docsall     Create all the docs, docsix, docs, readmefun, dot.
docs        Create one or more markdown docs; specify part of source filename.
docsix      Create markdown docs index.
json        Display one or more source file's json doc comments; specify part of name.
jsonix      Display markdown docs index json.
readmefun   Create the readme function section.
dot         Create a dependency graph of the StaticTea source.
dot2        Create a dependency graph of the system modules used by StaticTea.
tt          Compile and run t.nim.
tree        Show the project directory tree.
args        Show command line arguments.
br          Build the test runner.
runt        Run a stf test in testfiles. Specify the filename.
runall      Run all stf tests in the testfiles folder.
stf         List stf tests descriptions.
newstf      Create new stf as a starting point for a new test.
runhelp     Show the runner help text with glow.
helpme      Show the statictea help text.
#+END_SRC

[[#contents][èŒ¶]]

** Stf Runner
:PROPERTIES:
   :CUSTOM_ID: stf-runner
   :END:

The stf runner runs command line tests of statictea.

The runner is a standalone program that can test any command line
application.  You define a test in a stf file.  The stf file
contains instructions for creating test files, running them and
for comparing them to determine whether the test passed.

The statictea testfiles folder contains Single Test File (stf)
files used to test statictea features. The runner command runs
all the stf files.  There are nimble tasks to run all the tests,
to run one test, to make new tests and to list them.  See the
nimble section above.

See the runner help message for help creating stf files.

[[#contents][èŒ¶]]

** Example Templates
:PROPERTIES:
   :CUSTOM_ID: example-templates
   :END:

You can examine simple self contained statictea templates
in the testfiles folder.

The [[#module-docs][Module Docs]] section has more complex examples.

[[#contents][èŒ¶]]

* Functions
:PROPERTIES:
:CUSTOM_ID: functions
:ORDERED:  t
:END:

Functions allow you to format variables for presentation.  They
return a value that you assign to a variable or pass to another
function.

This section was created from the nim source code by running the
readmefun nimble task which uses the StaticTea template
[[templates/readmeFuncSection.org][readmeFuncSection.org]].

List of functions:

# Dynamic Content Begins
- [[#add][add()]] -- Add floats.
- [[#add][add()]] -- Add integers.
- [[#case][case()]] -- Compare integer cases and return the matching value.
- [[#case][case()]] -- Compare string cases and return the matching value.
- [[#cmpVersion][cmpVersion()]] -- Compare two StaticTea version numbers.
- [[#cmp][cmp()]] -- Compare two floats.
- [[#cmp][cmp()]] -- Compare two ints.
- [[#cmp][cmp()]] -- Compare two strings.
- [[#concat][concat()]] -- Concatentate strings.
- [[#dict][dict()]] -- Create a dictionary from a list of key, value pairs.
- [[#dup][dup()]] -- Duplicate a string x times.
- [[#exists][exists()]] -- Determine whether a key exists in a dictionary.
- [[#find][find()]] -- Find the position of a substring in a string.
- [[#float][float()]] -- Create a float from an int.
- [[#float][float()]] -- Create a float from a number string.
- [[#get][get()]] -- Get a dictionary value by its key.
- [[#get][get()]] -- Get a list value by its index.
- [[#githubAnchor][githubAnchor()]] -- Create Github anchor names from heading names.
- [[#githubAnchor][githubAnchor()]] -- Create a Github anchor name from a heading name.
- [[#if0][if0()]] -- If the condition is 0, return the second parameter, else return the third.
- [[#int][int()]] -- Create an int from a float.
- [[#int][int()]] -- Create an int from a number string.
- [[#joinPath][joinPath()]] -- Join the path components with a path separator.
- [[#joinPath][joinPath()]] -- Join the path components with the platform path separator.
- [[#join][join()]] -- Join a list of strings with a separator.
- [[#keys][keys()]] -- Create a list from the keys in a dictionary.
- [[#len][len()]] -- Number of elements in a dictionary.
- [[#len][len()]] -- Number of elements in a list.
- [[#len][len()]] -- Number of characters in a string.
- [[#list][list()]] -- Create a list of values.
- [[#lower][lower()]] -- Lowercase a string.
- [[#path][path()]] -- Split a file path into its component pieces.
- [[#replace][replace()]] -- Replace a substring specified by its position and length with another string.
- [[#replaceRe][replaceRe()]] -- Replace multiple parts of a string using regular expressions.
- [[#replaceRe][replaceRe()]] -- Replace multiple parts of a string using regular expressions.
- [[#sort][sort()]] -- Sort a list of values of the same type.
- [[#sort][sort()]] -- Sort a list of lists.
- [[#sort][sort()]] -- Sort a list of dictionaries.
- [[#substr][substr()]] -- Extract a substring from a string by its position.
- [[#type][type()]] -- Return the parameter type, one of: int, float, string, list, dict.
- [[#values][values()]] -- Create a list out of the values in the specified dictionary.

[[#contents][èŒ¶]]

** add()
:PROPERTIES:
:CUSTOM_ID: add
:END:

Add floats. A warning is generated on overflow.

#+BEGIN_SRC
add(numbers: varargs(float)) float
#+END_SRC

Examples:

#+BEGIN_SRC
add(1.5) => 1.5
add(1.5, 2.3) => 3.8
add(1.1, 2.2, 3.3) => 6.6
#+END_SRC

[[#contents][èŒ¶]]

** add()
:PROPERTIES:
:CUSTOM_ID: add
:END:

Add integers. A warning is generated on overflow.

#+BEGIN_SRC
add(numbers: varargs(int)) int
#+END_SRC

Examples:

#+BEGIN_SRC
add(1) => 1
add(1, 2) => 3
add(1, 2, 3) => 6
#+END_SRC

[[#contents][èŒ¶]]

** case()
:PROPERTIES:
:CUSTOM_ID: case
:END:

Compare integer cases and return the matching value.  It takes a
main integer condition, a list of case pairs and an optional
value when none of the cases match.

The first element of a case pair is the condition and the
second is the return value when that condition matches the main
condition. The function compares the conditions left to right and
returns the first match.

When none of the cases match the main condition, the default
value is returned if it is specified, otherwise a warning is
generated.  The conditions must be integers. The return values
can be any type.

#+BEGIN_SRC
case(condition: int, pairs: list, optional default: any) any
#+END_SRC

Examples:

#+BEGIN_SRC
cases = list(0, "tea", 1, "water", 2, "beer")
case(0, cases) => "tea"
case(1, cases) => "water"
case(2, cases) => "beer"
case(2, cases, "wine") => "beer"
case(3, cases, "wine") => "wine"
#+END_SRC

[[#contents][èŒ¶]]

** case()
:PROPERTIES:
:CUSTOM_ID: case
:END:

Compare string cases and return the matching value.  It takes a
main string condition, a list of case pairs and an optional
value when none of the cases match.

The first element of a case pair is the condition and the
second is the return value when that condition matches the main
condition. The function compares the conditions left to right and
returns the first match.

When none of the cases match the main condition, the default
value is returned if it is specified, otherwise a warning is
generated.  The conditions must be strings. The return values
can be any type.

#+BEGIN_SRC
case(condition: string, pairs: list, optional default: any) any
#+END_SRC

Examples:

#+BEGIN_SRC
cases = list("tea", 15, "water", 2.3, "beer", "cold")
case("tea", cases) => 15
case("water", cases) => 2.3
case("beer", cases) => "cold"
case("bunch", cases, "other") => "other"
#+END_SRC

[[#contents][èŒ¶]]

** cmpVersion()
:PROPERTIES:
:CUSTOM_ID: cmpVersion
:END:

Compare two StaticTea version numbers. Returns -1 for less, 0 for
equal and 1 for greater than.

#+BEGIN_SRC
cmpVersion(versionA: string, versionB: string) int
#+END_SRC

StaticTea uses [[https://semver.org/][Semantic Versioning]]
with the added restriction that each version component has one
to three digits (no letters).

Examples:

#+BEGIN_SRC
cmpVersion("1.2.5", "1.1.8") => 1
cmpVersion("1.2.5", "1.3.0") => -1
cmpVersion("1.2.5", "1.2.5") => 0
#+END_SRC

[[#contents][èŒ¶]]

** cmp()
:PROPERTIES:
:CUSTOM_ID: cmp
:END:

Compare two floats. Returns -1 for less, 0 for
equal and 1 for greater than.

#+BEGIN_SRC
cmp(a: float, b: float) int
#+END_SRC

Examples:

#+BEGIN_SRC
cmp(7.8, 9.1) => -1
cmp(8.4, 8.4) => 0
cmp(9.3, 2.2) => 1
#+END_SRC

[[#contents][èŒ¶]]

** cmp()
:PROPERTIES:
:CUSTOM_ID: cmp
:END:

Compare two ints. Returns -1 for less, 0 for equal and 1 for
 greater than.

#+BEGIN_SRC
cmp(a: int, b: int) int
#+END_SRC

Examples:

#+BEGIN_SRC
cmp(7, 9) => -1
cmp(8, 8) => 0
cmp(9, 2) => 1
#+END_SRC

[[#contents][èŒ¶]]

** cmp()
:PROPERTIES:
:CUSTOM_ID: cmp
:END:

Compare two strings. Returns -1 for less, 0 for equal and 1 for
greater than.

You have the option to compare case insensitive. Case sensitive
is the default.

#+BEGIN_SRC
cmp(a: string, b: string, optional insensitive: int) int
#+END_SRC

Examples:

#+BEGIN_SRC
cmp("coffee", "tea") => -1
cmp("tea", "tea") => 0
cmp("Tea", "tea") => 1
cmp("Tea", "tea", 0) => 1
cmp("Tea", "tea", 1) => 0
#+END_SRC

[[#contents][èŒ¶]]

** concat()
:PROPERTIES:
:CUSTOM_ID: concat
:END:

Concatentate strings.

#+BEGIN_SRC
concat(strs: varargs(string)) string
#+END_SRC

Examples:

#+BEGIN_SRC
concat("tea", " time") => "tea time"
concat("a", "b", "c", "d") => "abcd"
concat("a") => "a"
#+END_SRC

[[#contents][èŒ¶]]

** dict()
:PROPERTIES:
:CUSTOM_ID: dict
:END:

Create a dictionary from a list of key, value pairs.  The keys
must be strings and the values can be any type.

#+BEGIN_SRC
dict(pairs: optional varargs(string, any)) dict
#+END_SRC

Examples:

#+BEGIN_SRC
dict() => {}
dict("a", 5) => {"a": 5}
dict("a", 5, "b", 33, "c", 0) =>
  {"a": 5, "b": 33, "c": 0}
#+END_SRC

[[#contents][èŒ¶]]

** dup()
:PROPERTIES:
:CUSTOM_ID: dup
:END:

Duplicate a string x times.  The result is a new string built by
concatenating the string to itself the specified number of times.

#+BEGIN_SRC
dup(pattern: string, count: int) string
#+END_SRC

Examples:

#+BEGIN_SRC
dup("=", 3) => "==="
dup("abc", 0) => ""
dup("abc", 1) => "abc"
dup("abc", 2) => "abcabc"
dup("", 3) => ""
#+END_SRC

[[#contents][èŒ¶]]

** exists()
:PROPERTIES:
:CUSTOM_ID: exists
:END:

Determine whether a key exists in a dictionary. Return 1 when it exists, else 0.

#+BEGIN_SRC
exists(dictionary: dict, key: string) int
#+END_SRC

Examples:

#+BEGIN_SRC
d = dict("tea", "Earl")
exists(d, "tea") => 1
exists(d, "coffee") => 0
#+END_SRC

[[#contents][èŒ¶]]

** find()
:PROPERTIES:
:CUSTOM_ID: find
:END:

Find the position of a substring in a string.  When the substring
is not found you can return a default value.  A warning is
generated when the substring is missing and you don't specify a
default value.

#+BEGIN_SRC
find(str: string, substring: string, optional default: any) any
#+END_SRC

Examples:

#+BEGIN_SRC
       0123456789 1234567
msg = "Tea time at 3:30."
find(msg, "Tea") = 0
find(msg, "time") = 4
find(msg, "me") = 6
find(msg, "party", -1) = -1
find(msg, "party", len(msg)) = 17
find(msg, "party", 0) = 0
#+END_SRC

[[#contents][èŒ¶]]

** float()
:PROPERTIES:
:CUSTOM_ID: float
:END:

Create a float from an int.

#+BEGIN_SRC
float(num: int) float
#+END_SRC

Examples:

#+BEGIN_SRC
float(2) => 2.0
float(-33) => -33.0
#+END_SRC

[[#contents][èŒ¶]]

** float()
:PROPERTIES:
:CUSTOM_ID: float
:END:

Create a float from a number string.

#+BEGIN_SRC
float(numString: string) float
#+END_SRC

Examples:

#+BEGIN_SRC
float("2") => 2.0
float("2.4") => 2.4
float("33") => 33.0
#+END_SRC

[[#contents][èŒ¶]]

** get()
:PROPERTIES:
:CUSTOM_ID: get
:END:

Get a dictionary value by its key.  If the key doesn't exist, the
default value is returned if specified, else a warning is
generated.

#+BEGIN_SRC
get(dictionary: dict, key: string, optional default: any) any
#+END_SRC

Note: For dictionary lookup you can use dot notation. It's the
same as get without the default.

Examples:

#+BEGIN_SRC
d = dict("tea", "Earl Grey")
get(d, "tea") => "Earl Grey"
get(d, "coffee", "Tea") => "Tea"
#+END_SRC

Using dot notation:
#+BEGIN_SRC
d = dict("tea", "Earl Grey")
d.tea => "Earl Grey"
#+END_SRC

[[#contents][èŒ¶]]

** get()
:PROPERTIES:
:CUSTOM_ID: get
:END:

Get a list value by its index.  If the index is invalid, the
default value is returned when specified, else a warning is
generated.

#+BEGIN_SRC
get(list: list, index: int, optional default: any) any
#+END_SRC

Examples:

#+BEGIN_SRC
list = list(4, "a", 10)
get(list, 2) => 10
get(list, 3, 99) => 99
#+END_SRC

[[#contents][èŒ¶]]

** githubAnchor()
:PROPERTIES:
:CUSTOM_ID: githubAnchor
:END:

Create Github anchor names from heading names. Use it for Github
markdown internal links. It handles duplicate heading names.

#+BEGIN_SRC
githubAnchor(names: list) list
#+END_SRC

Examples:

#+BEGIN_SRC
list = list("Tea", "Water", "Tea")
githubAnchor(list) =>
  ["tea", "water", "tea-1"]
#+END_SRC

[[#contents][èŒ¶]]

** githubAnchor()
:PROPERTIES:
:CUSTOM_ID: githubAnchor
:END:

Create a Github anchor name from a heading name. Use it for
Github markdown internal links. If you have duplicate heading
names, the anchor name returned only works for the
first. Punctuation characters are removed so you can get
duplicates in some cases.

#+BEGIN_SRC
githubAnchor(name: string) string
#+END_SRC

Examples:

#+BEGIN_SRC
githubAnchor("MyHeading") => "myheading"
githubAnchor("Eary Gray") => "eary-gray"
githubAnchor("$Eary-Gray#") => "eary-gray"
#+END_SRC

Example in a markdown template:

#+BEGIN_SRC
$$ : anchor = githubAnchor(entry.name)
- {type]{{entry.name}](#{anchor}) &mdash; {short}
...
# {entry.name}
#+END_SRC

[[#contents][èŒ¶]]

** if0()
:PROPERTIES:
:CUSTOM_ID: if0
:END:

If the condition is 0, return the second parameter, else return the third.

#+BEGIN_SRC
if0(condition: int, then: any, else: any) any
#+END_SRC

Examples:

#+BEGIN_SRC
if0(0, "tea", "beer") => "tea"
if0(1, "tea", "beer") => "beer"
if0(4, "tea", "beer") => "beer"
#+END_SRC

[[#contents][èŒ¶]]

** int()
:PROPERTIES:
:CUSTOM_ID: int
:END:

Create an int from a float.

#+BEGIN_SRC
int(num: float, optional roundOption: string) int
#+END_SRC

Round options:

- "round" - nearest integer, the default.
- "floor" - integer below (to the left on number line)
- "ceiling" - integer above (to the right on number line)
- "truncate" - remove decimals

Examples:

#+BEGIN_SRC
int(2.34) => 2
int(2.34, "round") => 2
int(-2.34, "round") => -2
int(6.5, "round") => 7
int(-6.5, "round") => -7
int(4.57, "floor") => 4
int(-4.57, "floor") => -5
int(6.3, "ceiling") => 7
int(-6.3, "ceiling") => -6
int(6.3456, "truncate") => 6
int(-6.3456, "truncate") => -6
#+END_SRC

[[#contents][èŒ¶]]

** int()
:PROPERTIES:
:CUSTOM_ID: int
:END:

Create an int from a number string.

#+BEGIN_SRC
int(numString: string, optional roundOption: string) int
#+END_SRC

Round options:

- "round" - nearest integer, the default
- "floor" - integer below (to the left on number line)
- "ceiling" - integer above (to the right on number line)
- "truncate" - remove decimals

Examples:

#+BEGIN_SRC
int("2") => 2
int("2.34") => 2
int("-2.34", "round") => -2
int("6.5", "round") => 7
int("-6.5", "round") => -7
int("4.57", "floor") => 4
int("-4.57", "floor") => -5
int("6.3", "ceiling") => 7
int("-6.3", "ceiling") => -6
int("6.3456", "truncate") => 6
int("-6.3456", "truncate") => -6
#+END_SRC

[[#contents][èŒ¶]]

** joinPath()
:PROPERTIES:
:CUSTOM_ID: joinPath
:END:

Join the path components with a path separator.

You pass a list of components to join. For the second optional
parameter you specify the separator to use, either "/", "" or
"". If you specify "" or leave off the parameter, the current
platform separator is used.

If the separator already exists between components, a new one
is not added. If a component is "", the platform separator is
used for it.

#+BEGIN_SRC
joinPath(components: list, optional separator: string) string
#+END_SRC

Examples:

#+BEGIN_SRC
joinPath(list("images", "tea")) =>
  "images/tea"

joinPath(list("images", "tea"), "/") =>
  "images/tea"

joinPath(list("images", "tea"), "\") =>
  "images\tea"

joinPath(list("images/", "tea") =>
  "images/tea"

joinPath(list("", "tea")) =>
  "/tea"

joinPath(list("/", "tea")) =>
  "/tea"
#+END_SRC

[[#contents][èŒ¶]]

** joinPath()
:PROPERTIES:
:CUSTOM_ID: joinPath
:END:

Join the path components with the platform path separator.

If the separator already exists between components, a new one
is not added. If a component is "", the platform separator is
used for it.

#+BEGIN_SRC
joinPath(components: optional vararg(string)) string
#+END_SRC

Examples:

#+BEGIN_SRC
joinPath("images", "tea")) =>
  "images/tea"

joinPath("images/", "tea") =>
  "images/tea"
#+END_SRC

[[#contents][èŒ¶]]

** join()
:PROPERTIES:
:CUSTOM_ID: join
:END:

Join a list of strings with a separator.
An optional parameter determines whether you skip empty
strings or not.

#+BEGIN_SRC
join(strs: list, sep: string, optional skipEmpty: int) string
#+END_SRC

Examples:

#+BEGIN_SRC
join(list("a", "b"), ", ") => "a, b"
join(list("a"), ", ") => "a"
join(list(""), ", ") => ""
join(list("a", "b"), "") => "ab"
join(list("a", "", "c"), "|") => "a||c"
join(list("a", "", "c"), "|", 1) => "a|c"
#+END_SRC

[[#contents][èŒ¶]]

** keys()
:PROPERTIES:
:CUSTOM_ID: keys
:END:

Create a list from the keys in a dictionary.

#+BEGIN_SRC
keys(dictionary: dict) list
#+END_SRC

Examples:

#+BEGIN_SRC
d = dict("a", 1, "b", 2, "c", 3)
keys(d) => ["a", "b", "c"]
values(d) => ["apple", 2, 3]
#+END_SRC

[[#contents][èŒ¶]]

** len()
:PROPERTIES:
:CUSTOM_ID: len
:END:

Number of elements in a dictionary.

#+BEGIN_SRC
len(dictionary: dict) int
#+END_SRC

Examples:

#+BEGIN_SRC
len(dict()) => 0
len(dict("a", 4)) => 1
len(dict("a", 4, "b", 3)) => 2
#+END_SRC

[[#contents][èŒ¶]]

** len()
:PROPERTIES:
:CUSTOM_ID: len
:END:

Number of elements in a list.

#+BEGIN_SRC
len(list: list) int
#+END_SRC

Examples:

#+BEGIN_SRC
len(list()) => 0
len(list(1)) => 1
len(list(4, 5)) => 2
#+END_SRC

[[#contents][èŒ¶]]

** len()
:PROPERTIES:
:CUSTOM_ID: len
:END:

Number of characters in a string.

#+BEGIN_SRC
len(str: string) int
#+END_SRC

Examples:

#+BEGIN_SRC
len("tea") => 3
len("aÃ±yÃ³ng") => 6
#+END_SRC

[[#contents][èŒ¶]]

** list()
:PROPERTIES:
:CUSTOM_ID: list
:END:

Create a list of values.

#+BEGIN_SRC
list(items: optional varargs(any)) list
#+END_SRC

Examples:

#+BEGIN_SRC
list() => []
list(1) => [1]
list(1, 2, 3) => [1, 2, 3]
list("a", 5, "b") => ["a", 5, "b"]
#+END_SRC

[[#contents][èŒ¶]]

** lower()
:PROPERTIES:
:CUSTOM_ID: lower
:END:

Lowercase a string.

#+BEGIN_SRC
lower(str: string) string
#+END_SRC

Examples:

#+BEGIN_SRC
lower("Tea") => "tea"
lower("TEA") => "tea"
lower("TEÄ€") => "teÄ"
#+END_SRC

[[#contents][èŒ¶]]

** path()
:PROPERTIES:
:CUSTOM_ID: path
:END:

Split a file path into its component pieces. Return a dictionary
with the filename, basename, extension and directory.

You pass a path string and the optional path separator, forward
slash or or backwards slash. When no separator, the current
system separator is used.

#+BEGIN_SRC
path(filename: string, optional separator: string) dict
#+END_SRC

Examples:

#+BEGIN_SRC
path("src/runFunction.nim") => {
  "filename": "runFunction.nim",
  "basename": "runFunction",
  "ext": ".nim",
  "dir": "src/",
}

path("src\runFunction.nim", "\") => {
  "filename": "runFunction.nim",
  "basename": "runFunction",
  "ext": ".nim",
  "dir": "src\",
}
#+END_SRC

[[#contents][èŒ¶]]

** replace()
:PROPERTIES:
:CUSTOM_ID: replace
:END:

Replace a substring specified by its position and length with another string.  You can use the function to insert and append to
a string as well.

#+BEGIN_SRC
replace(str: string, start: int, length: int, replacement: string) string
#+END_SRC

- str: string
- start: substring start index
- length: substring length
- replacement: substring replacement

Examples:

#+BEGIN_SRC
replace("Earl Grey", 5, 4, "of Sandwich")
  => "Earl of Sandwich"
replace("123", 0, 0, "abcd") => abcd123
replace("123", 0, 1, "abcd") => abcd23
replace("123", 0, 2, "abcd") => abcd3
replace("123", 0, 3, "abcd") => abcd
replace("123", 3, 0, "abcd") => 123abcd
replace("123", 2, 1, "abcd") => 12abcd
replace("123", 1, 2, "abcd") => 1abcd
replace("123", 0, 3, "abcd") => abcd
replace("123", 1, 0, "abcd") => 1abcd23
replace("123", 1, 1, "abcd") => 1abcd3
replace("123", 1, 2, "abcd") => 1abcd
replace("", 0, 0, "abcd") => abcd
replace("", 0, 0, "abc") => abc
replace("", 0, 0, "ab") => ab
replace("", 0, 0, "a") => a
replace("", 0, 0, "") =>
replace("123", 0, 0, "") => 123
replace("123", 0, 1, "") => 23
replace("123", 0, 2, "") => 3
replace("123", 0, 3, "") =>
#+END_SRC

[[#contents][èŒ¶]]

** replaceRe()
:PROPERTIES:
:CUSTOM_ID: replaceRe
:END:

Replace multiple parts of a string using regular expressions.

You specify one or more pairs of a regex patterns and their string
replacements.

#+BEGIN_SRC
replaceRe(str: string, pairs: varargs(string, string) string
#+END_SRC

Examples:

#+BEGIN_SRC
replaceRe("abcdefabc", "abc", "456")
  => "456def456"
replaceRe("abcdefabc", "abc", "456", "def", "")
  => "456456"
#+END_SRC

For developing and debugging regular expressions see the
website: https://regex101.com/

[[#contents][èŒ¶]]

** replaceRe()
:PROPERTIES:
:CUSTOM_ID: replaceRe
:END:

Replace multiple parts of a string using regular expressions.

You specify one or more pairs of a regex patterns and its string
replacement.

#+BEGIN_SRC
replaceRe(str: string, pairs: list) string
#+END_SRC

Examples:

#+BEGIN_SRC
list = list("abc", "456", "def", "")
replaceRe("abcdefabc", list))
  => "456456"
#+END_SRC

For developing and debugging regular expressions see the
website: https://regex101.com/

[[#contents][èŒ¶]]

** sort()
:PROPERTIES:
:CUSTOM_ID: sort
:END:

Sort a list of values of the same type.  The values are ints,
floats or strings.

You specify the sort order, "ascending" or "descending".

You have the option of sorting strings case "insensitive". Case
"sensitive" is the default.

#+BEGIN_SRC
sort(values: list, order: string, optional insensitive: string) list
#+END_SRC

Examples:

#+BEGIN_SRC
ints = list(4, 3, 5, 5, 2, 4)
sort(list, "ascending") => [2, 3, 4, 4, 5, 5]
sort(list, "descending") => [5, 5, 4, 4, 3, 2]

floats = list(4.4, 3.1, 5.9)
sort(floats, "ascending") => [3.1, 4.4, 5.9]
sort(floats, "descending") => [5.9, 4.4, 3.1]

strs = list("T", "e", "a")
sort(strs, "ascending") => ["T", "a", "e"]
sort(strs, "ascending", "sensitive") => ["T", "a", "e"]
sort(strs, "ascending", "insensitive") => ["a", "e", "T"]
#+END_SRC

[[#contents][èŒ¶]]

** sort()
:PROPERTIES:
:CUSTOM_ID: sort
:END:

Sort a list of lists.

You specify the sort order, "ascending" or "descending".

You specify how to sort strings either case "sensitive" or
"insensitive".

You specify which index to compare by.  The compare index value
must exist in each list, be the same type and be an int, float or
string.

#+BEGIN_SRC
sort(lists: list, order: string, case: string, index: int) list
#+END_SRC

Examples:

#+BEGIN_SRC
l1 = list(4, 3, 1)
l2 = list(2, 3, 4)
listOfLists = list(l1, l2)
sort(listOfLists, "ascending", "sensitive", 0) => [l2, l1]
sort(listOfLists, "ascending", "sensitive", 2) => [l1, l2]
#+END_SRC

[[#contents][èŒ¶]]

** sort()
:PROPERTIES:
:CUSTOM_ID: sort
:END:

Sort a list of dictionaries.

You specify the sort order, "ascending" or "descending".

You specify how to sort strings either case "sensitive" or
"insensitive".

You specify the compare key.  The key value must exist
in each dictionary, be the same type and be an int, float or
string.

#+BEGIN_SRC
sort(dicts: list, order: string, case: string, key: string) list
#+END_SRC

Examples:

#+BEGIN_SRC
d1 = dict("name", "Earl Gray", "weight", 1.2)
d2 = dict("name", "Tea Pot", "weight", 3.5)
dicts = list(d1, d2)
sort(dicts, "ascending", "sensitive", "weight") => [d1, d2]
sort(dicts, "descending", "sensitive", "name") => [d2, d1]
#+END_SRC

[[#contents][èŒ¶]]

** substr()
:PROPERTIES:
:CUSTOM_ID: substr
:END:

Extract a substring from a string by its position. You pass the
string, the substring's start index then its end index+1.
The end index is optional and defaults to the end of the
string+1.

The range is half-open which includes the start position but not
the end position. For example, [3, 7) includes 3, 4, 5, 6. The
end minus the start is equal to the length of the substring.

#+BEGIN_SRC
substr(str: string, start: int, optional end: int) string
#+END_SRC

Examples:

#+BEGIN_SRC
substr("Earl Grey", 1, 4) => "arl"
substr("Earl Grey", 6) => "rey"
#+END_SRC

[[#contents][èŒ¶]]

** type()
:PROPERTIES:
:CUSTOM_ID: type
:END:

Return the parameter type, one of: int, float, string, list, dict.

#+BEGIN_SRC
type(variable: any) string
#+END_SRC

Examples:

#+BEGIN_SRC
type(2) => "int"
type(3.14159) => "float"
type("Tea") => "string"
type(list(1,2)) => "list"
type(dict("a", 1, "b", 2)) => "dict"
#+END_SRC

[[#contents][èŒ¶]]

** values()
:PROPERTIES:
:CUSTOM_ID: values
:END:

Create a list out of the values in the specified dictionary.

#+BEGIN_SRC
values(dictionary: dict) list
#+END_SRC

Examples:

#+BEGIN_SRC
d = dict("a", "apple", "b", 2, "c", 3)
keys(d) => ["a", "b", "c"]
values(d) => ["apple", 2, 3]
#+END_SRC


# Dynamic Content Ends
* Contents :notoc:
:PROPERTIES:
:CUSTOM_ID: contents
:END:

# You run the command below to make the table of contents. Copy
# to scratch to remove the leading pound signs.
# grep '^\* ' readme.org | grep -v ":notoc" | cut -c 3- | \
# awk '{a = $0; gsub(" ", "-", a); printf "- [[#%s][%s]]\n", tolower(a), $0 }'

- [[#advantages][Advantages]]
- [[#how-it-works][How it Works]]
- [[#commands][Commands]]
- [[#replacement-block][Replacement Block]]
- [[#statements][Statements]]
- [[#syntax][Syntax]]
- [[#variables][Variables]]
- [[#single-letter-dictionaries][Single Letter Dictionaries]]
- [[#types][Types]]
- [[#run-statictea][Run StaticTea]]
- [[#miscellaneous][Miscellaneous]]
- [[#functions][Functions]]

* Tea Info                                                            :notoc:

Tea is the most popular manufactured drink consumed in the world,
equaling all others â€“ including coffee, soft drinks, and alcohol
â€“ combined. -- Wikipedia -- Macfarlane, Alan; Macfarlane, Iris
(2004). The Empire of Tea. The Overlook Press. p. 32. ISBN
978-1-58567-493-0.
