#+TITLE: StaticTea
A template processor and language.

StaticTea combines a template with data to produce a result.

Example hello world template:

#+BEGIN_SRC
<!--$ nextline -->
hello {s.name}
#+END_SRC

The associated json data:

#+BEGIN_SRC
{"name": "world"}
#+END_SRC

The result:

#+BEGIN_SRC
hello world
#+END_SRC

[[#contents][茶]] (contents at the bottom)

* Advantages
:PROPERTIES:
:CUSTOM_ID: advantages
:END:

You can view, edit and validate your templates with its normal
tools.  You develop templates as if they were static pages.

The template designer has full control over the presentation.
You can change the look without changing the server.

You can share common template fragments between templates.

[[#contents][茶]]

* How it Works
  :PROPERTIES:
:CUSTOM_ID: how-it-works
:END:

You pass unformatted variable content from the server as json.
You format the content with template commands to create new
variables that substitue text in the template.

You define replacement blocks by surrounding them with commands
and you target replacement variables inside the block by wrapping
them with brackets.

You encode the commands as comments to match the particular
template type.

[[#contents][茶]]

* Commands
:PROPERTIES:
:CUSTOM_ID: commands
:END:

StaticTea commands:

- [[#nextline-command][nextline]] -- make substitutions in the next line
- [[#block-command][block]] —- make substitutions in the next block of lines
- [[#replace-command][replace]] -— replace the block with a variable
- [[#endblock-command][endblock]] -- end the replacement block for block and replace
  commands.
- # —- [[#comment-command][comment command]]
- : -- [[#continue-command][continue command]], used to continue a command line

[[#contents][茶]]

** Nextline Command
:PROPERTIES:
:CUSTOM_ID: nextline-command
:END:

The nextline command targets the line following it for
replacement. The targeted line is called the replacement block.

The following example's replacement block contains two variables,
drink and drinkType.

template:

#+BEGIN_SRC
<!--$ nextline -->
Drink {s.drink} -- {s.drinkType} is my favorite.
#+END_SRC

server json:

#+BEGIN_SRC
{
  "drink": "tea",
  "drinkType": "Earl Grey"
}
#+END_SRC

result:

#+BEGIN_SRC
Drink tea -- Earl Grey is my favorite.
#+END_SRC

[[#contents][茶]]

** Block Command
:PROPERTIES:
:CUSTOM_ID: block-command
:END:

The block command targets multiple lines for replacement. The
replacement block starts after the command and continues until
the endblock line is found. It behaves like the nextline command
except with multiple lines.

In the following example the block has three lines. The block
contains three replacement variables, weekday, name and time.

template:

#+BEGIN_SRC
<!--$ block -->
Join our tea party on
{s.weekday} at {s.name}'s
house at {s.time}.
<!--$ endblock -->
#+END_SRC

server json:

#+BEGIN_SRC
{
  "weekday": "Friday",
  "name": "John",
  "time": "5:00 pm"
}
#+END_SRC

result:

#+BEGIN_SRC
Join our tea party on
Friday at John's
house at 5:00 pm.
#+END_SRC

[[#contents][茶]]

** Replace Command
:PROPERTIES:
:CUSTOM_ID: replace-command
:END:

The replace command's replacement block gets replaced with the
t.content variable.

The lines in the block mirror the variable so you can
test the template as if it was a static file.

The command is useful for sharing common template lines between
templates and it has the special property that you can keep the
replacement block in sync with the variable, see [[#update-option][Update Option]]
for more information.

If you don't assign the t.content variable, a warning is
generated, and the command behaves like a block command.  This is
good for testing changes you want to make to the shared value.

The following example uses a common header from the shared json.

template:

#+BEGIN_SRC
<!--$ replace t.content="h.header" -->
<!--$ endblock -->
#+END_SRC

shared json:

#+BEGIN_SRC
{
  "header": "<!doctype html>\n<html lang=\"en\">\n"
}
#+END_SRC

result:

#+BEGIN_SRC
<!doctype html>
<html lang="en">
#+END_SRC

The above example generates the correct result but it doesn’t
work as a static template because the template is missing the
header lines.

You can fix this by adding the header lines inside the replace
command's replacement block. The lines do not appear in the
result, just the data from the json header variable.

template:

#+BEGIN_SRC
<!--$ replace t.content="h.header" -->
<!doctype html>
<html lang="en">
<!--$ endblock -—>
#+END_SRC

The template replacement block may get out of sync with the
variable.  You can update the replacement block to match the
variable with the update option.

The following example updates the mytea.html template's
replacement blocks to match their variables in the shared.json
file:

#+BEGIN_SRC
statictea --update shared.json \
   --template mytea.html
#+END_SRC

The shared variable may contain replacement content too.  Here is
another html header example:

template:

#+BEGIN_SRC
<!--$ replace t.content="h.header" -->
<!DOCTYPE html>
<html lang="{s.languageCode}" dir="{s.languageDirection}">
<head>
<meta charset="UTF-8"/>
<title>{s.title}</title>
<--$ endblock -->
#+END_SRC

server json:

#+BEGIN_SRC
{
"languageCode": "en",
"languageDirection": "ltr",
"title": "Teas in England"
}
#+END_SRC

shared json:

#+BEGIN_SRC
{
  "header": "<!DOCTYPE html>
<html lang=\"{s.languageCode}\" dir=\"{s.languageDirection}\">
<head>
<meta charset=\"UTF-8\"/>
<title>{s.title}</title>\n"
}
#+END_SRC

result:

#+BEGIN_SRC
<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8"/>
<title>Teas in England</title>
#+END_SRC

[[#contents][茶]]

** Comment Command
:PROPERTIES:
:CUSTOM_ID: comment-command
:END:

You can comment templates with the comment command.  Comments
are line based and use the # character. They do not appear in the
result.

template:

#+BEGIN_SRC
<!--$ # How you make tea. -->
There are five main groups of teas:
white, green, oolong, black, and pu'erh.
You make Oolong Tea in five time
intensive steps.
#+END_SRC

result:

#+BEGIN_SRC
There are five main groups of teas:
white, green, oolong, black, and pu'erh.
You make Oolong Tea in five time
intensive steps.
#+END_SRC

[[#contents][茶]]

** Continue Command
:PROPERTIES:
:CUSTOM_ID: continue-command
:END:

You can continue a long command line with the "\\" character at
the end before the postfix. The following line must be a continue
command.

The continue command allows you to continue adding statements
when you need more space. You can continue the continue command
too.

In the following example the nextline command continues on a
second line and third line.

template:

#+BEGIN_SRC
<!--$ nextline \-->
<!--$ : tea = 'Earl Grey'; \-->
<!--$ : tea2 = 'Masala chai' -->
{tea}, {tea2}
#+END_SRC

result:

#+BEGIN_SRC
Earl Grey, Masala chai
#+END_SRC

[[#contents][茶]]

** Endblock Command
:PROPERTIES:
:CUSTOM_ID: endblock-command
:END:

The endblock command ends the replacement block for the block and
replace commands. Only the endblock command ends them. All text
until the endblock is part of the replacement block. This
includes lines that look like commands. For example:

template:

#+BEGIN_SRC
<!--$ block -->
<!--$ # this is not a comment, just text -->
fake nextline
<!--$ nextline -->
<!--$ endblock -->
#+END_SRC

result:

#+BEGIN_SRC
<!--$ # this is not a comment, just text -->
fake nextline
<!--$ nextline -->
#+END_SRC

[[#contents][茶]]

* Replacement Block
:PROPERTIES:
:CUSTOM_ID: replacement-block
:END:

A replacement block is a group of contiguous lines in a
template. The block contains the variable content for
substitutions and you can repeat the block.

You mark the replacment block with a nextline, block or replace
command before it and an endblock command after it. The nextline
block is one line and it does not have an endblock.

You mark the variable content with brackets around the variables
inside the block. You can use any number of variables.

You use repeating blocks to make lists and other repeating
content.

The next example shows a simple replacement block and it is a
good opportunity to show a famous tea quote from "Alice in
Wonderland", by Lewis Carroll:

#+BEGIN_SRC
<!--$ block -->
"Take some more tea," the March Hare
said to Alice, very earnestly.

"I've had nothing yet," Alice replied in an
offended tone: "so I can't take more."

"You mean you cannot take less," said
the Hatter: "it's very easy to take
more than nothing."
<!--$ endblock -->
#+END_SRC

[[#contents][茶]]

* Statements
:PROPERTIES:
:CUSTOM_ID: statements
:END:

You format server content in variables you create in statements.

A statement is an expression consisting of a variable, an equal
sign, and a right hand side. The right hand side is either
another variable, a string, a number or a function.

All operations are done with functions except the equal
operator. Looping is done at the command level with t.repeat.

Here are some
examples:

#+BEGIN_SRC
tea = "Earl Grey"
num = 5
t.repeat = 8
nameLen = len(s.name)
name = concat(substr(s.name, 0, 7), "...")
#+END_SRC

Statements are allowed on the nextline, block and replace
commands. You can use multiple statements separated with
semicolons. If you need more space, you can continue the line
with the "\\" character at the end. Statements are executed from
left to right.

[[#contents][茶]]

* Syntax
:PROPERTIES:
:CUSTOM_ID: syntax
:END:

A template consists of command lines and non-command lines.  The
command lines are line oriented and they have the same form and
they are limited to 1024 bytes. There are no restrictions on the
non-command lines in a template.

Each command line is a comment to match the template type. The
beginning comment characters are called the prefix and the
optional ending comment characters are called the postfix. For
example, in an html template the prefix is "<!--$" and the
postfix is "-->". See [[#prefix-postfix][Prefix Postfix]] for more information.

The prefix starts at column 1. Next comes the command name. Statements
follow the command name, they are separated by semicolons and they may
flow through the following lines. At the end of the line is an
optional slash continuation character then the optional postfix
then the end of line, either \r\n or \n.

The following chart shows a nextline command made up of two
lines. It has three statements: a=5, b=6 and c=5.

#+BEGIN_SRC
prefix
|     command
|     |        statements
|     |        |         continuation
|     |        |         |
|     |        |         |postfix
|     |        |         ||  newline
|     |        |         ||  |
<!--$ nextline a=5; b=6; \-->
<!--$ :        c=5        -->
#+END_SRC

A space or tab is required between a command and a statement,
otherwise you can use zero or more tabs and spaces where they are
allowed. Space isn't allowed before the prefix, after the
continuation or after the postfix or between the function name
and its opening parentheses. Here are a few single line examples:

#+BEGIN_SRC
<!--$nextline-->
<!--$ nextline -->
<!--$ nextline a=5   -->
<!--$ nextline a = 5 -->
<!--$ nextline num = len(tea_list); b=3 -->
<!--$ nextline num = len( tea_list ) ;b=3 -->
#+END_SRC

The statements may flow between lines. The following two nextline
commands are equivalent:

#+BEGIN_SRC
<!--$ nextline com = "Bigelow Tea Company" -->

<!--$ nextline com = "Big\-->
<!--$ : elow Tea Company" -->
#+END_SRC

You separate statements with semicolons. You can have blank
statements that do nothing.

#+BEGIN_SRC
<!--$ nextline a=1; b=2; c=3 -->
#+END_SRC

[[#contents][茶]]

* Variables
:PROPERTIES:
:CUSTOM_ID: variables
:END:

You use variables to create formatted content for a block and to
control how a command works. You create them in json files or in
template statements. Internally one dictionary exists for each of
the five types of variables, you access them with different
prefixes. Here are the prefixes and sections for each one.

- s. -- [[#json-variables][Server Json Variables]]
- h. -- [[#json-variables][Shared Json Variables]]
-    -- [[#local-variables][Local Variables]]
- g. -- [[#global-variables][Global Variables]]
- t. -- [[#tea-variables][Tea Variables]]

[[#contents][茶]]

** Json Variables
:PROPERTIES:
:CUSTOM_ID: json-variables
:END:

You pass variables to the template in json files.

The variables are defined by the top level dictionary items. Each
item's key is the name of a variable and the item's value is
the variables' value.

There are two types of json files, the server json and the shared
json. The server file populates the t.server dictionary and the
shared file populates the t.shared dictionary.

You can use multiple server and shared json files by specifying
multiple files on the command line. The files are processed
left to right which is important when there are duplicate
variables since the last one processed overwrites the previous
one.

The json null values get converted to the 0. Json True and False
get converted to 1 and 0.

You cannot change the json variables.

To give full control of the presentation to the template
designers, the server json shouldn't contain any presentation
data.

The shared json is created by the template designer for sharing
common template fragments and other presentation needs.

[[#contents][茶]]

** Local Variables
   :PROPERTIES:
   :CUSTOM_ID: local-variables
   :END:

You create local variables with template statements.  They are
local to the block where they are defined.  They are processed
from left to right.  There is no prefix for local variables. They
are stored in the t.local dictionary. The local variables are
cleared and recalculated for each repeated block.

[[#contents][茶]]

** Global Variables
    :PROPERTIES:
    :CUSTOM_ID: global-variables
    :END:

Like local variables, you create global variables with template
statements.  All blocks have access to them.  You access them
with "g." prefix.  They are stored in the t.global dictionary.

[[#contents][茶]]

** Tea Variables
:PROPERTIES:
    :CUSTOM_ID: tea-variables
    :END:

The built in tea variables are prefixed with "t." and they
control how the replacement block works.

- [[#tcontent][t.content]] -- content of the replace block
- [[#tlocal][t.local]] -- dictionary containing the current block's local variables.
- [[#tglobal][t.global]] -- dictionary containing the global variables.
- [[#tmaxrepeat][t.maxRepeat]] -- maximum number of times to repeat the block
- [[#tmaxlines][t.maxLines]] -- maximum number of replacement block lines (lines before endblock)
- [[#toutput][t.output]] -- where the block output goes
- [[#trepeat][t.repeat]] -- controls how many times the block repeats
- [[#trow][t.row]] -- the current row number of a repeating block
- [[#tserver][t.server]] -- dictionary containing the server variables
- [[#tshared][t.shared]] -- dictionary containing the shared variables
- [[#tversion][t.version]] -- the StaticTea version number

[[#contents][茶]]

*** t.content
    :PROPERTIES:
    :CUSTOM_ID: tcontent
    :END:

The t.content variable determines the content used for the
whole replace block.

You assign it the name of the variable as a string, not the
variables value. For example:

#+BEGIN_SRC
t.content = "h.header"
#+END_SRC

It's done this way so the --update option knows the name of the
variable to update in the json file. See [[#update-option][Update Option]] for more
information.

When the t.content is not set, the command behaves like a block
command except a warning message is output. This is good for
testing changes you want to make to the shared value and the
warning reminds you to set the variable when you're done testing.

The variable only applies to the replace command. See the
[[#replace-command][replace command]] section for an example.

Added in version 0.1.0.

[[#contents][茶]]

*** t.local
:PROPERTIES:
:CUSTOM_ID: tlocal
:END:

The t.local variable is the dictionary of local variables for the
current command.

Added in version 0.1.0.

[[#contents][茶]]

*** t.global
    :PROPERTIES:
    :CUSTOM_ID: tglobal
    :END:

The t.global variable is the dictionary of the global variables.

Added in version 0.1.0.

[[#contents][茶]]

*** t.maxRepeat
  :PROPERTIES:
  :CUSTOM_ID: tmaxrepeat
  :END:

The t.maxRepeat variable determines the maxiumum times a block
can repeat.  The default is 100. You cannot assign a number to
t.repeat bigger than maxRepeat. A warning message is generated
when you try.

It prevents the case where you mistakenly assign a giant number,
and it allows you to design your template to work well for the
expected range of blocks.

You can increase this t.maxRepeat to repeat more times.

Added in version 0.1.0.
[[#contents][茶]]

*** t.maxLines
    :PROPERTIES:
    :CUSTOM_ID: tmaxlines
    :END:

The t.maxLines variable determines the maximum lines in a
replacement block.

StaticTea reads lines looking for the endblock.  By default, if
it is not found in 10 lines, the 10 lines are used for the block
and a warning is output. This catches the case where you forget
the endblock command.

You can increase this value to support blocks with more lines by
setting the t.maxLines system variable.

Added in version 0.1.0.

#+BEGIN_SRC
<!--$ block t.maxLines=20 -->
#+END_SRC

[[#contents][茶]]

*** t.output
:PROPERTIES:
    :CUSTOM_ID: toutput
    :END:

The t.output variable determines where the block output goes.  By
default it goes to the result file specified when you run
statictea.

- "result" -- the block output goes to the result file (default)
- "stderr" -- the block output goes to standard error
- "log" -- the block output goes to the log file
- "skip" -- the block is skipped

Added in version 0.1.0.

You can use the stderr option to write your own warning messages.

template:

#+BEGIN_SRC
<!--$ nextline \-->
<!--$ : t.output = if( \-->
<!--$ :   exists("s.admin"), "skip", \-->
<!--$ :   "stderr"); \-->
<!--$ : msg = concat( \-->
<!--$ :   template(), "(", \-->
<!--$ :   getLineNumber(), ")", \-->
<!--$ :   "missing admin var") -->
{msg}
#+END_SRC

result:

#+BEGIN_SRC
template.html(45): missing admin var
#+END_SRC

[[#contents][茶]]

*** t.repeat
    :PROPERTIES:
    :CUSTOM_ID: trepeat
    :END:

The t.repeat variable is a number that tells how many times to
repeat the block.

You use the t.row variable to customize each block.  Each time
the block repeats the local variables get recalculated.

By default the block is output once. A value of zero means don't
show the block at all.

You cannot assign a number bigger than t.maxRepeat to
t.repeat. You can set t.maxRepeat to anything you want, the
default is 100.

Added in version 0.1.0.

For the following example, the number of items in tea_list is
assigned to the t.repeat variable which outputs the block five
times.

template:

#+BEGIN_SRC
<!--$ nextline t.repeat = len(s.tea_list); \-->
<!--$ : tea = get(s.tea_list, t.row) -->
 * {tea}
#+END_SRC

server json:

#+BEGIN_SRC
{
"tea_list": [
  "Black",
  "Green",
  "Oolong",
  "Sencha",
  "Herbal"
]
}
#+END_SRC

result:

#+BEGIN_SRC
 * Black
 * Green
 * Oolong
 * Sencha
 * Herbal
#+END_SRC

The following example builds an html select list of tea companies
with the Twinings company selected and it shows how to access
values from dictionaries.

template:

#+BEGIN_SRC
<h3>Tea Companies</h3>
<select>
<!--$ nextline t.repeat=len(s.companyList); \-->
<!--$ : d = get(s.companyList, t.row); \-->
<!--$ : company = get(d, "company"); \-->
<!--$ : selected = get(d, "selected", 0); \-->
<!--$ : current=if(selected, ' selected="selected"', "") -->
<option{current}>{company}</option>
</select>
#+END_SRC

server json:

#+BEGIN_SRC
{
"companyList": [
  {"company": "Lipton"},
  {"company": "Tetley"},
  {"company": "Twinings", "selected": 1},
  {"company": "American Tea Room"},
  {"company": "Argo Tea"},
  {"company": "Bigelow Tea Company"}
]
}
#+END_SRC

result:

#+BEGIN_SRC
<h3>Tea Companies</h3>
<select>
<option>Lipton</option>
<option>Tetley</option>
<option>selected="selected">Twinings</option>
<option>Argo Tea</option>
<option>American Tea Room</option>
<option>Bigelow Tea Company</option>
</select>
#+END_SRC

Setting t.repeat to 0 is good for building test lists.

When you view the following template fragment in a browser it
shows one item in the list.

template:

#+BEGIN_SRC
<h3>Tea</h3>
<ul>
<!--$ nextline t.repeat = len(s.teaList); \-->
<!--$ : tea = get(s.teaList, t.row) -->
<li>{tea}</li>
</ul>
#+END_SRC

To create a static page that has more products for better testing
you could use the repeat variable like this:

template:

#+BEGIN_SRC
<h3>Tea</h3>
<ul>
<!--$ nextline t.repeat = len(s.teaList); \-->
<!--$ : tea = get(s.teaList, t.row) -->
<li>{tea}</li>
<!--$ block t.repeat = 0 -->
<li>Black</li>
<li>Green</li>
<li>Oolong</li>
<li>Sencha</li>
<li>Herbal</li>
<!--$ endblock -->
</ul>
#+END_SRC

server json:

#+BEGIN_SRC
{
"teaList": [
  "Chamomile",
  "Chrysanthemum",
  "White",
  "Puer"
]
}
#+END_SRC

result:

#+BEGIN_SRC
<h3>Tea</h3>
<ul>
<li>Chamomile</li>
<li>Chrysanthemum</li>
<li>White</li>
<li>Puer</li>
</ul>
#+END_SRC

[[#contents][茶]]

*** t.row
    :PROPERTIES:
    :CUSTOM_ID: trow
    :END:

The t.row variable contains the current row number for blocks
that repeat. The row numbers start at 0 and increase.  You use it
to format lists and other repeating content in the template.

Added in version 0.1.0.

Here is an example using the row variable.  In the example the
row number is used in three places.

template:

#+BEGIN_SRC
<!--$ nextline t.repeat=len(s.companies); \-->
<!--$ : company = get(s.companies, t.row); \-->
<!--$ : num = add(t.row, 1) -->
<li id="r{t.row}>{num}. {company}</li>
#+END_SRC

server json:

#+BEGIN_SRC
{
  "companies": [
    "Mighty Leaf Tea",
    "Numi Organic Tea",
    "Peet's Coffee & Tea",
    "Red Diamond"
  ]
}
#+END_SRC

result:

#+BEGIN_SRC
  <li id="r0">1. Mighty Leaf Tea</li>
  <li id="r1">2. Numi Organic Tea</li>
  <li id="r2">3. Peet's Coffee & Tea</li>
  <li id="r3">4. Red Diamond</li>
#+END_SRC

 [[#contents][茶]]

*** t.server
:PROPERTIES:
    :CUSTOM_ID: tserver
    :END:

The t.server variable is a dictionary containing the server json variables.

Added in version 0.1.0.

*** t.shared
:PROPERTIES:
    :CUSTOM_ID: tshared
    :END:

The t.shared variable is a dictionary containing the shared json variables

Added in version 0.1.0.

[[#contents][茶]]

*** t.version
:PROPERTIES:
:CUSTOM_ID: tversion
:END:

The t.version variable contains the current version number of
StaticTea. See the [[#cmpversion][cmpVersion]] function for more information.

Added in version 0.1.0.

[[#contents][茶]]

* Types
:PROPERTIES:
:CUSTOM_ID: types
:END:

StaticTea variable types:

- [[#string][string]]
- [[#integer][integer]]
- [[#float][float]]
- [[#dictionary][dictionary]]
- [[#list][list]]

[[#contents][茶]]

** String
:PROPERTIES:
:CUSTOM_ID: string
:END:

A string is an immutable sequence of characters. You define a
string with single or double quotes and use them in
statements. You encode strings as unicode utf-8.  Invalid utf-8
sequences generate a warning and the statement is skipped.

example strings:

- "this is a string"
- 'using single quotes'
- "You can store black teas longer than green teas."
- "100"

example usage:

#+BEGIN_SRC
<!--$ nextline tea = "Earl Grey" -->
<h2>{tea}</h2>
#+END_SRC

result:

#+BEGIN_SRC
<h2>Earl Grey</h2>
#+END_SRC

[[#contents][茶]]

** Integer
:PROPERTIES:
:CUSTOM_ID: integer
:END:

An integer is a 64 bit signed number.  Plus signs are not used
with numbers.

Example numbers:

#+BEGIN_SRC
12345
0
-8823
42
#+END_SRC

[[#contents][茶]]

** Float
:PROPERTIES:
:CUSTOM_ID: float
:END:

A float is a 64 bit real number, it has a decimal point and
starts with a digit or minus sign.

Example floats:

#+BEGIN_SRC
3.14159
24.95
0.123
-34.0
#+END_SRC

[[#contents][茶]]

** Dictionary
:PROPERTIES:
:CUSTOM_ID: dictionary
:END:

A dictionary is a key value store with fast lookup. It maps a
string key to a value which can be any type.  You access
dictionary items with the get function and you define them in the
json files.

[[#contents][茶]]

** List
:PROPERTIES:
:CUSTOM_ID: list
:END:

A list contains a sequence of values of any type.  You lookup
list elements with the get function and you define them in the
json files.

[[#contents][茶]]

* Run StaticTea
:PROPERTIES:
:CUSTOM_ID: run-statictea
:END:

You run StaticTea from the command line. You specify the template
file to process along with the json data files and a result file
is generated.

- Warning messages go to standard error.
- If you don't specify the result argument, the result goes to standard out.
- If you specify "stdin" for the template, the template comes
  from stdin.
- Return code is 0 when no warning messages are output.

The example below shows a typical invocation which specifies four
file arguments, the server json, the shared json, the template
and the result.

#+BEGIN_SRC
statictea \
  --server server.json \
  --shared shared.json \
  --template template.html \
  --result result.html
#+END_SRC

The StaticTea command line options:

- help -- show options and usage documentation.
- version -- outputs the version number.
- server -- the server json file(s), you can specify multiple.
- shared -- the shared json file(s), you can specify multiple.
- template -- the template file, or "stdin".
- result -- the result file, or standard out when not specified.
- update -- update the template replace blocks. See the
  [[#replace-command][Replace Command]].
- prepost -- add a command prefix and postfix, you can specify
  multiple. When you specify values, the defaults are no longer
  used. See the [[#prefix-postfix][Prefix Postfix]] section.

[[#contents][茶]]

* Miscellaneous
:PROPERTIES:
:CUSTOM_ID: miscellaneous
:END:

Miscellaneous topics:

- [[#warning-messages][Warning Messages]]
- [[#prefix-postfix][Prefix Postfix]]
- [[#encoding-and-line-endings][Encoding and Line Endings]]
- [[#update-option][Update Option]]
- [[#log-file][Log File]]

** Warning Messages
:PROPERTIES:
   :CUSTOM_ID: warning-messages
   :END:

When StaticTea detects a problem, a warning message is written to
standard error, the problem is skipped, and processing
continues.

For example, if a variable in a replacement block is used but it
doesn't exist, the bracketed variable remains as is in the
result, and a message is output to standard error. There are many
other potential warnings.

It’s good style to change your template or json to be free of
messages.

Each warning message shows the file and line number where the
problem happened.

example messages:

- tea.html(0): w15: "Unable to parse the json file. Skipping file: test.json.
- tea.html(45): w61: No space after the command.
- tea.html(121): w52: The get function takes 2 or 3 parameters.
- tea.html(243): w36: The variable 'teaMaster' does not exist.
- tea.html(3044): w47: Concat parameter 45 is not a string."

Statement errors generate multi-line messages, for example:

#+BEGIN_SRC
template.html(16): w33: Expected a string, number, variable or function.
statement: tea = len("abc",)
                           ^
#+END_SRC


Statictea returns success (return code 0) when no message gets
output to standard error, else it returns 1.

Example of running statictea when a variable is missing:

template:

#+BEGIN_SRC
<!--$ block -->
You're a {s.webmaster},
I'm a {s.teaMaster}!
<!--$ endblock -->
#+END_SRC

server json:

#+BEGIN_SRC
{
 "webmaster": "html wizard"
}
#+END_SRC

stderr:

#+BEGIN_SRC
template.html(3): w58: The replacement variable doesn't exist: s.teaMaster.
#+END_SRC

result:

#+BEGIN_SRC
You're a html wizard,
I'm a {s.teaMaster}!
#+END_SRC

You can write your own warning messages using the system t.output
set to stderr. In the following example a warning message is
written to standard error when the server admin variable is
missing. When it is not missing nothing gets output.

template:

#+BEGIN_SRC
<--$ nextline t.output = if( \-->
<--$ : exists("admin"), "skip", "stderr") -->
warning: the admin variable is missing
#+END_SRC

[[#contents][茶]]

** Prefix Postfix
:PROPERTIES:
   :CUSTOM_ID: prefix-postfix
   :END:

You make the template commands look like comments tailored for
your template file type. This allows you to edit the template
using its native editor and run other native tools.  For example,
you can edit a StaticTea html template with an html editor and
validate it online with w3.org's validator.

Comment syntax varies depending on the type of template file and
sometimes depending on the location within the file. StaticTea
supports several varieties and you can specify others.

You want to distinguish StaticTea commands from normal comments
when you create your own. The convention is to add a $ as the
last character of the prefix and only use $ with StaticTea
commands and space for normal comments.

Built in Prefixes:

- html: <!--$ and -->
- html: &lt;!--$ and --&gt; for textarea elements
- bash: #$
- config files: ;$
- C++: //$
- C language: ​/\star$ and \star​/

You can define other comment types on the command line using the
prepost option one or more times. When you specify your own
prepost values, the defaults no longer exist so you have control
of which prefixes get used.

You specify the prepost option with the prefix separated from
the postfix with one space and the postfix is optional.

examples:

#+BEGIN_SRC
--prepost="@$ |"
--prepost="[comment$ ]"
--prepost="#[$ ]#"
#+END_SRC

[[#contents][茶]]

** Encoding and Line Endings
:PROPERTIES:
:CUSTOM_ID: encoding-and-line-endings
:END:

Templates are utf-8 encoded.  Two line endings are supported on
all platforms: LF, and CR/LF.  Line endings are preserved.  The
template syntax only uses ascii except unicode characters are
allowed in quoted strings. The maximum command line length is
1024 bytes, there is no limit on non-command lines.

[[#contents][茶]]

** Update Option
:PROPERTIES:
:CUSTOM_ID: update-option
:END:

The --update option updates the json file with the current
content of the replacement blocks. It scans the template for each
replacement block and writes it to the associated variable in the
json file.

The t.content values tells which variables to update.

The content is merged into the json file, other existing json
data is untouched. You can update one json file and it is
specified on the command line.

#+BEGIN_SRC
statictea --update shared.json \
   --template mytea.html
#+END_SRC

[[#contents][茶]]

** Log File
:PROPERTIES:
   :CUSTOM_ID: log-file
   :END:

The log file contains information about processing your
template. Template commands can also write to the log file.

Log information is appended to the file and it grows without
bounds.  When the file size exceeds 1 GB, a warning message is
generated each time a template is processed.

[[#contents][茶]]

* Functions
:PROPERTIES:
:CUSTOM_ID: functions
:ORDERED:  t
:END:

Functions allow you to format variables for presentation.  They
return a value that you either assign to a variable or pass to
another function.

New functions get added over time. the function documentation
tells which version it appears so you know which version of
statictea to require.

List of functions:

- [[#add][add()]] -- add numbers
- [[#case][case()]] -- multiple condition handling
- [[#cmp][cmp()]] -- spaceship compare function <=>
- [[#cmpversion][cmpVersion()]] -- compare StaticTea version numbers
- [[#concat][concat()]] -- concatenate strings
- [[#int][int()]] -- convert a float or number string to an int
- [[#exists][exists()]] -- whether a variables exists
- [[#find][find()]] -- find a substring in a string
- [[#floatfun][float()]] -- convert an int or number string to a float
- [[#format][format()]] -- format a string or a number
- [[#get][get()]] -- get an element from a list or dictionary
- [[#if][if()]] -- handles two conditions
- [[#len][len()]] -- length of string, list or dictionary
- [[#lineNumber][lineNumber()]] -- the current line number
- [[#quotehtml][quoteHtml]] -- replace html special characters
- [[#sizes][sizes()]] -- format bytes counts, KB, MB, GB, etc.
- [[#substr][substr()]] -- extract a substring from a string by indexes
- [[#time][time()]] -- format the date and time.
- [[#template][template()]] -- the filename of the current template

[[#contents][茶]]

** add()
:PROPERTIES:
:CUSTOM_ID: add
:END:

The add function returns the sum of its two or more
parameters. The parameters must be all integers or all floats.  A
warning is generated on overflow and the statement is skipped.

Added in version 0.1.0.

#+BEGIN_SRC
num = add(t.row(), 1)
#+END_SRC

[[#contents][茶]]

** case()
:PROPERTIES:
:CUSTOM_ID: case
:END:

The case function returns a value from multiple choices.

It requires at least four parameters, the main condition, the
"else" value and a case pair. You can have any number of case
pairs.

The first parameter of a case pair is the case condition and the
second is the return value when that condition matches the main
condition.

When none of the cases match the main condition, the "else" value
is returned.  The conditions must be all strings or all ints and
the return values can be any type.

The function compares the conditions left to right and returns
when it finds the first match.

- p1: The main condition value.
- p2: The "else" value.
- -
- p3: The first case condition.
- p4: Return value when p3 equals p1.
- ...
- pnc: The last case condition.
- pnv: Return value when pnc equals p1.

Added in version 0.1.0.

For the example below the abbr variable is set to an abbreviation
depending on the type of tea.

template:

#+BEGIN_SRC
<--$ nextline \-->
<--$ : abbr = case( \-->
<--$ : s.tea, "unknown",  \-->
<--$ : 'Darjeeling', "Darj",  \-->
<--$ : "Earl Gray", "EG") -->
The abbreviation for {s.tea} is {s.abbr}.
#+END_SRC

server json:

#+BEGIN_SRC
{
  "tea": "Darjeeling"
}
#+END_SRC

result:

#+BEGIN_SRC
The abbreviation for Darjeeling is Darj.
#+END_SRC

The if statement is shorthand for a simple case:

#+BEGIN_SRC
if(cond, v1, v2)
#+END_SRC
is equivalent to:
#+BEGIN_SRC
case(cond, v2, 1, v1)
#+END_SRC

[[#contents][茶]]

** cmp()
:PROPERTIES:
:CUSTOM_ID: cmp
:END:

The cmp function compares two variables, either numbers or
strings (both the same type), and returns whether the first
parameter is less than, equal to or greater than the second
parameter. It returns -1 for less, 0 for equal and 1 for greater
than. The optional third parameter compares strings case
insensitive when it is 1. Added in version 0.1.0.

template:

#+BEGIN_SRC
#$ block \
#$ : cond1 = cmp(4, 5); \
#$ : cond2 = cmp(2, 2); \
#$ : cond3 = cmp(5, 4); \
#$ : cond4 = cmp("abc", "abd"); \
#$ : cond5 = cmp("abc", "ABC", 1)
cmp(4, 5) returns {cond1}
cmp(2, 2) returns {cond2}
cmp(5, 4) returns {cond3}
cmp("abc", "abd") returns {cond4}
cmp("abc", "ABC") returns {cond5}
#$ endblock
#+END_SRC

result:

#+BEGIN_SRC
cmp(4, 5) returns -1
cmp(2, 2) returns 0
cmp(5, 4) returns 1
cmp("abc", "abd") returns -1
cmp("abc", "ABC") returns 0
#+END_SRC

Here is another example using cmp to "ellipsize" a string when it
gets long. The following example ellipsizes when a name is longer
than 10 characters.

#+BEGIN_SRC
<!--$ # If the name is longer than 10 characters, -->
<!--$ # clip it to 7 and add "...".               -->
<!--$ nextline                                   \-->
<!--$ : cmp = cmp(len(s.name), 10);              \-->
<!--$ : name = case(cmd, s.name                  \-->
<!--$ : 1, concat(substr(s.name, 0, 7), "..."))   -->
#+END_SRC

[[#contents][茶]]

** cmpVersion()
:PROPERTIES:
:CUSTOM_ID: cmpversion
:END:

The cmpVersion function compares two StaticTea type version
numbers and returns whether the first parameter is less than,
equal to or greater than the second parameter. It returns -1 for
less, 0 for equal and 1 for greater than.

StaticTea uses [[https://semver.org/][Semantic Versioning]] with the added restrictions
that each version component has one to three digits and no
letters.

Added in version 0.1.0.

Example valid StaticTea version numbers:

#+BEGIN_SRC
1.0.2
12.1.333
3.10.5
3.9.65
#+END_SRC

Example invalid StaticTea version numbers:

#+BEGIN_SRC
2
1.4
1.4.3a
2.33.4567
1.0.0beta
#+END_SRC

The example below generates a warning when the running version of
StaticTea is less than 1.0.2.

template:

#+BEGIN_SRC
#$ nexline req = "1.0.2"; \
#$ : t.output = case(cmpVersion(t.version, req), \
#$ : 'skip', -1, 'stderr')
Version {req} or above is required.
#+END_SRC

[[#contents][茶]]

** concat()
:PROPERTIES:
:CUSTOM_ID: concat
:END:

The concat function concatenates strings. You can specify two or
more string parameters. The following example also shows using
the "#$" prefix. Added in version 0.1.0.

#+BEGIN_SRC
#$ block \
#$ : x3 = concat("Tea", "Time"); \
#$ : x4 = concat("Tea", " ",  "Time")
concat("Tea", "Time") => '{x3}'
concat("Tea", " ",  "Time") => '{x4}'
#$ endblock
#+END_SRC

Result:

#+BEGIN_SRC
concat("Tea", "Time") => 'TeaTime'
concat("Tea", " ",  "Time") => 'Tea Time'
#+END_SRC

[[#contents][茶]]

** exists()
:PROPERTIES:
:CUSTOM_ID: exists
:END:

Return 1 when a variable exists in the given dictionary, else
return 0. The first parameter is the dictionary to check and the
second parameter is the name of the variable to find.

-p1: dictionary: The dictionary to use.
-p2: string: The name (key) to find.

Added in version 0.1.0.

template:

#+BEGIN_SRC
<--$ block a = "apple"; \-->
<--$ : ax = exists(t.local, "a"); \-->
<--$ : bx = exists(t.local, "b") -->
exists("a") => {ax}
exists("b") => {bx}
<--$ endblock -->
#+END_SRC

result:

#+BEGIN_SRC
exists("a") => 1
exists("b") => 0
#+END_SRC

[[#contents][茶]]

** find()
:PROPERTIES:
:CUSTOM_ID: find
:END:

The find function searches a string for a substring and returns
its position when found. When not found it returns -1. Positions
start at 0. Added in version 0.1.0.

template:

#+BEGIN_SRC
<--$ nextline \-->
<--$ pos = find("Tea time at 4:00.", "time") -->
{pos}
#+END_SRC

result:

#+BEGIN_SRC
4
#+END_SRC

[[#contents][茶]]

** float()
:PROPERTIES:
:CUSTOM_ID: floatfun
:END:

The float function converts an int or a number string to a
float.

Added in version 0.1.0.

Note: if you want to convert a number to a string, use the format
function.

[[#contents][茶]]

** format()
:PROPERTIES:
:CUSTOM_ID: format
:END:

The format function is a powerful way to format your
variables. You can left, right or center the variable.  You can
specify the number of digits after the decimal point and other
things. For all the details see: https://nim-lang.org/docs/strformat.html.
Added in version 0.1.0.

template:

#+BEGIN_SRC
<--$ nextline cost=format(".2f", s.cost)-->
Kathleen spent ${cost} on tea for Steve's birthday.
#+END_SRC

server json:

#+BEGIN_SRC
{
  "cost": 52.436789
}
#+END_SRC

result:

#+BEGIN_SRC
Kathleen spent $52.44 on tea for Steve's birthday.
#+END_SRC

[[#contents][茶]]

** get()
:PROPERTIES:
:CUSTOM_ID: get
:END:

You use the get function to return a list or dictionary element.
You pass two or three parameters, the first is the dictionary or
list to use, the second is the dictionary key name or the list
index, and the third optional parameter is the default value when
the element doesn't exist.

If you don't specify the default, a warning is generated when the
element doesn't exist and the statement is skipped.

- p1: Dictionary to use.
- p2: Key of the element to return.
- p3: Optional value returned when the key is missing.

or

- p1: List to use.
- p2: Index to the element to return.
- p3: Optional value returned when the index is too big.

Added in version 0.1.0.

#+BEGIN_SRC
var = get(t.server, "tea")
var = get(t.server, "tea", "Earl Grey")
var = get(s.companyList, 3, "Unknown")
#+END_SRC

[[#contents][茶]]

** if()
:PROPERTIES:
:CUSTOM_ID: if
:END:

You use the if function to return a value based on a condition.
It has three parameters, the condition, the true case and the
false case.

1. Condition is an integer.
2. True case is the value returned when condition is 1.
3. Else case is the value returned when condition is not 1.

Added in version 0.1.0.

The following example uses the template system to show how it
works.

template:

#+BEGIN_SRC
<--$ block \-->
<--$ : var1=if(1, 'dog', 'cat'), \-->
<--$ : var2=if(0, 'dog', 'cat'), \-->
<--$ : var3=if(8, 'dog', 'cat'), -->

if(1, 'dog', 'cat') => {var1}
if(0, 'dog', 'cat') => {var2}
if(8, 'dog', 'cat') => {var3}
<--$ endblock -->
#+END_SRC

result:

#+BEGIN_SRC

if(1, 'dog', 'cat') -> dog
if(0, 'dog', 'cat') -> cat
if(8, 'dog', 'cat') -> cat
#+END_SRC

[[#contents][茶]]

** int()
:PROPERTIES:
:CUSTOM_ID: int
:END:

The int function converts a float or a number string to an
int.

- p1: value to convert, float or number string
- p2: optional round option, "round" is the default.

Round options:

- "round" - nearest integer
- "floor" - integer below (to the left on number line)
- "ceiling" - integer above (to the right on number line)
- "truncate" - remove decimals

Added in version 0.1.0.

Examples:

#+BEGIN_SRC
int("2") => 2
int("2.34") => 2
int(2.34, "round") => 2
int(-2.34, "round") => -2
int(6.5, "round") => 7
int(-6.5, "round") => -7
int(4.57, "floor") => 4
int(-4.57, "floor") => -5
int(6.3, "ceiling") => 7
int(-6.3, "ceiling") => -6
int(6.3456, "truncate") => 6
int(-6.3456, "truncate") => -6
#+END_SRC

[[#contents][茶]]

** len()
:PROPERTIES:
:CUSTOM_ID: len
:END:

The len function takes one parameter and returns the number of
characters in a string (not bytes), the number of elements in a
list or the number of elements in a dictionary.  Added in version
0.1.0.

#+BEGIN_SRC
<!--$ block \-->
<!--$ : length = len("Tetley"); \-->
<!--$ : listLen = len(tea_list); \-->
<!--$ : serverLen = len(t.server) -->
The Tetley name has {length} characters.
The tea list has {listlen} elements.
The server json dictionary has {serverLen} elements.
<!--$ endblock -->
#+END_SRC

json:

#+BEGIN_SRC
{
"tea_list": [
    {"tea": "Black"},
    {"tea": "Green"},
    {"tea": "Oolong"},
    {"tea": "Sencha"},
    {"tea": "Herbal"}
  ]
}
#+END_SRC

result:

#+BEGIN_SRC
The Tetley name has 6 characters.
The tea list has 5 elements.
The server json dictionary has 1 elements.
#+END_SRC

[[#contents][茶]]

** lineNumber()
:PROPERTIES:
:CUSTOM_ID: lineNumber
:END:

Return the line in the template where the function is called. Added in version 0.1.0.

[[#contents][茶]]

** quoteHtml()
:PROPERTIES:
:CUSTOM_ID: quoteHtml
:END:

The quoteHtml replaces special html characters with equivalents. Added in version 0.1.0.

[[#contents][茶]]

** sizes()
:PROPERTIES:
:CUSTOM_ID: sizes
:END:

The sizes function formats a number as a number of bytes, KB, MB,
GB, etc. Added in version 0.1.0.

[[#contents][茶]]

** substr()
:PROPERTIES:
:CUSTOM_ID: substr
:END:

The substr function extracts a substring from a string.
The first parameter is the string to operate on, the
second is the starting index of the substring to extract and the
third is the ending index (one past it). The third parameter is
optional and defaults to one past the end of the string. The end
minus the start is equal to the length of the substring. Added in version 0.1.0.

Showing the indexes under Earl Grey helps to understand how the
function works.

#+BEGIN_SRC
Earl Grey
0123456789
#+END_SRC

template:

#+BEGIN_SRC
<--$ nextline \-->
<--$ : sub1 = substr("Earl Grey", 5) \-->
<--$ : sub2 = substr("Earl Grey", 0, 4) -->
sub1 = {sub1}, sub2 = {sub2}
#+END_SRC

result:

#+BEGIN_SRC
sub1 = Grey, sub2 = Earl
#+END_SRC

[[#contents][茶]]

** time()
:PROPERTIES:
:CUSTOM_ID: time
:END:

The time function formats date and time values. Added in version 0.1.0.

#+BEGIN_SRC
time("2021-02-15T20:47:33Z", "%Y") => 2021
#+END_SRC

[[#contents][茶]]

** template()
:PROPERTIES:
:CUSTOM_ID: template
:END:

Return the template filename. It takes one optional string
parameter:

- "basename" -- returns the name without any path information,
  which is the default.
- "passed" -- returns the template name as passed to statictea on
  the command line.

Added in version 0.1.0.

[[#contents][茶]]

* Contents :notoc:
:PROPERTIES:
:CUSTOM_ID: contents
:END:

# You run the command below to make the table of contents. Copy
# to scratch to remove the leading pound signs.
# grep '^\* ' readme.org | grep -v ":notoc" | cut -c 3- | \
# awk '{a = $0; gsub(" ", "-", a); printf "- [[#%s][%s]]\n", tolower(a), $0 }'

- [[#advantages][Advantages]]
- [[#how-it-works][How it Works]]
- [[#commands][Commands]]
- [[#replacement-block][Replacement Block]]
- [[#statements][Statements]]
- [[#syntax][Syntax]]
- [[#variables][Variables]]
- [[#types][Types]]
- [[#run-statictea][Run StaticTea]]
- [[#miscellaneous][Miscellaneous]]
- [[#functions][Functions]]

* Tea Info                                                            :notoc:

Tea is the most popular manufactured drink consumed in the world,
equaling all others – including coffee, soft drinks, and alcohol
– combined. -- Wikipedia -- Macfarlane, Alan; Macfarlane, Iris
(2004). The Empire of Tea. The Overlook Press. p. 32. ISBN
978-1-58567-493-0.
