* StaticTea

** A template processor and language.

StaticTea combines a template with data to produce a result.

Example template:

#+BEGIN_SRC
<!--$ nextline -->
hello {name}
#+END_SRC

The associated json data:

#+BEGIN_SRC
{"name": "world"}
#+END_SRC

The result:

#+BEGIN_SRC
hello world
#+END_SRC

** Basics

You specify each template command on one line. The command
applies to the current line, next line or next block of lines
(the replacement block) depending on the command.

You use variables in brackets to mark locations in the
replacement block for replacement. These variables typically get
replaced by their associated json value.

You can use two types of json files, a server json file and
shared json file.  The server json comes from the server and does
not contain any presentation markup. The shared json, maintained
by the template builder, contains shared presentation markup.

Since the template commands are encoded as comments, the template
file looks like a native file and you can view, edit, validate,
etc. the file with its normal tools. You develop templates as if
they were static pages.

** Commands

StaticTea has four commands:

- nextline — make substitutions in the next line
- block — make substitutions in the next block of lines
- replace — replace a block of lines
- # — comment

You add statements to commands to control how it behaves and to
define variables. You use commas to separate statements. You can
continue the line with the "\" character at the end.

example commands:

#+BEGIN_SRC
<!--$ nextline -->

<!--$ nextline t.list = locations, tea="Darjeeling" -->
#+END_SRC

*** Nextline Command

The nextline command tells the template system that the next line
in the file has variable content.

The content comes from text in the line and variables wrapped
with brackets.

In the following example there is some text and two variables, the
drink and drinkType variables.

template:

#+BEGIN_SRC
<!--$ nextline -->
Drink {drink} -- {drinkType} is my favorite.
#+END_SRC

json:

#+BEGIN_SRC
{
  "drink": "tea",
  "drinkType": "Earl Grey""
}
#+END_SRC

result:

#+BEGIN_SRC
Drink tea -- Earl Grey is my favorite.
#+END_SRC

*** Block Command

The block command targets multiple lines for replacement. The
block starts after the command and continues until another block
line is found. It behaves like the nextline command except with
multiple lines.

The content comes from text in the block and variables wrapped
with brackets.

In the following example the block has two lines. The block
contains three replacement variables, weekday, name and time.

template:

#+BEGIN_SRC
<!--$ block -->
Join our tea party on {weekday} at
{name}'s house at {time}.
<!-- block -->
#+END_SRC

json:

#+BEGIN_SRC
{
  "weekday": "Friday",
  "name": "John",
  "time": "5:00 pm"
}
#+END_SRC

result:

#+BEGIN_SRC
Join our tea party on Friday at
John's house at 5:00 pm.
#+END_SRC

*** Replace Command

The replace command replaces the replacement block with a
variable's value. You set the block content by assigning the
t.content variable.

The lines in the block mirror the variable so you can
test the template as if it was a static file.

The command is useful for sharing common template lines between
templates and it has the special property that you can update the
replacement block to keep it in sync with the variable.

The following example shares a common header between templates.

template:

#+BEGIN_SRC
<!--$ replace t.content=s.header -->
<!--$ replace -->
#+END_SRC

json:

#+BEGIN_SRC
{
  "header": "<!doctype html>\n<html lang="en">\n"
}
#+END_SRC

result:

#+BEGIN_SRC
<!doctype html>
<html lang="en">
#+END_SRC

The above example doesn’t work as a static template because the
template is missing the header lines.

You can fix this by adding the header lines inside the replace
block. The inside lines do not appear in the result, just the
data from the json variable.

template:

#+BEGIN_SRC
<!--$ replace t.content=s.header -->
<!doctype html>
<html lang="en">
<!--$ replace -—>
#+END_SRC

The template replacement block may get out of sync with the
variable.  You can update the replacement block to match the
variable with the update option.

The following example updates the mytea.html template's
replacement blocks to match their variables in the shared.json
file:

#+BEGIN_SRC
statictea --update --shared shared.json --template mytea.html
#+END_SRC

*** Comment Command

You can comment templates.  Comments are line based and use the #
character. They do not appear in the result.

template:

#+BEGIN_SRC
<!--$# This is a comment. -->
<!--$ # This is a comment. -->
hello again
#+END_SRC

result:

#+BEGIN_SRC
hello again
#+END_SRC

** Long Lines

You can continue a command line with the "\" character at the end
before the postfix. The the continuation line contains the prefix and postfix
but not the command keyword. You can continue the line multiple times.

template:

#+BEGIN_SRC
<!--$ nextline \-->
<!--$ tea = 'Earl Grey' -->
{tea}
#+END_SRC

result:

#+BEGIN_SRC
Earl Grey
#+END_SRC

** Types

*** Strings

You define a string using single or double quotes. You use
strings in command statements.

example strings:

#+BEGIN_SRC
"this is a string"
"what's up?"
'using single quote'
#+END_SRC

example usage:

#+BEGIN_SRC
<!--$ nextline message=t.if(admin, 'Earl Grey', 'Jasmine') -->
<h2>{message}</h2>
#+END_SRC

json:

#+BEGIN_SRC
{
  "admin": 1
}
#+END_SRC

result:

#+BEGIN_SRC
<h2>Earl Grey</h2>
#+END_SRC

*** Numbers

You can use ordinal numbers in statements. You use them with the
row function and 0, 1 for false and true. Numbers are limited to
5 digits.

#+BEGIN_SRC
0, 1, 2, 3,...,99999
#+END_SRC

Example numbers:

#+BEGIN_SRC
12345
0
8823
42
#+END_SRC

*** Variables

You use variables for dynamic replacement block content and to
control how a command works.

You specify variables in json files or you create them in
template statements.

A json dictionary keys are the variable names and their value
becomes part of the template when they are used.

Internally two json namespace exists, one for the shared json and
one for the server json.  You access the shared json with "s."
prefix the system variables with "t." and you access the server
variables with no prefix.

You can define new variables on the command's line. These
variables are local to the block and take precedence over the
json variables.

You can define any number of variables that will fit on the
line. You can put them on the end block if needed.

The variables are processed from left to right, so the last one
takes precedence when there are duplicates.

example variables:

#+BEGIN_SRC
t.row
serverVar
s.name
#+END_SRC

# Warning Messages

When StaticTea detects a problem, a warning message is written to
standard error and processing continues. All issues are handled,
usually by skipping the problem.

It’s good style to change your template or json so no messages
get output.

StaticTea returns success, 0, when no message get output, else it
returns 1.

The warning message show the line number of the problem
happened. Every message has a unique number which doesn't
change. The message may change to a different language, to fix
grammer etc. and should not be counted on to remain
unchanged. All new messages get added to the bottom.

example messages:

- template.html(45): w0001: email variable is missing from server.json.
- template.html(45): w0002: The command line's postfix is missing.
- template.html(45): w0003: The command line doesn't have a valid
  command.
- template.html(45): w0004: unknown system variable t.asdf.
- template.html(45): w0005: server json file not found: asdf
- template.html(45): w0006: unable to parse server.json

*** System Variables

You primarily use the system variables on a command line to
control what the command does.

System variables:

- t.list - repeats the block for each item in a list.
- t.maxLines - the max number of lines in the block.
- t.result - defines whether the block goes to the result file,
  standard out or nowhere.
- t.content - defines what goes in the replace block.

**** List Variable

The list variable controls how many times the command's block
repeats. You assign it with your list variable and the block
repeats for each item in the list. The default is "" which means
no repeat.

For the following example, email_list is assigned to the list
variable. The email_list has two items.

template:

#+BEGIN_SRC
<!--$ nextline t.list = email_list -->
Mail support at {email}.
#+END_SRC

json:

#+BEGIN_SRC
{
"email_list": [
    {"email": "steve@flenniken.net"},
    {"email": "webmaster@google.com"}
  ]
}
#+END_SRC

result:

#+BEGIN_SRC
Mail support at steve@flenniken.net.
Mail support at webmaster@google.com.
#+END_SRC

The following example builds a select list of cars where one car
is selected.

template:

#+BEGIN_SRC
<h4>Car List</h3>
<select>
<!--$ nextline t.list=car_list, current=t.if( selected 'selected="selected"') -->
  <option{current}>{car}</option>
</select>
#+END_SRC

json:

#+BEGIN_SRC
{
"car_list": [
    {"car": "vwbug"},
    {"car": "corvete"},
    {"car": "mazda"},
    {"car": "ford pickup"},
    {"car": "BMW", "selected": 1},
    {"car": "Honda"}
  ]
}
#+END_SRC

result:

#+BEGIN_SRC
<h3>Car List</h3>
<select>
  <option>vwbug</option>
  <option>corvete</option>
  <option>mazda</option>
  <option>ford pickup</option>
  <option selected="selected">BMW</option>
  <option>Honda</option>
</select>
#+END_SRC

**** Max Lines Variable

StaticTea reads lines looking for the terminating command.  By
default if the terminator is not found in 10 lines, the 10 lines
are used for the block and a warning is output.

You can increase this value to support blocks with more lines.

#+BEGIN_SRC
<!--$ block _max_lines=20 -->
#+END_SRC

**** Result Variable

You assign the system result variable to control where
replacement block's result goes, either the result file, standard
out or nowhere. By default it goes to the result file.

Result variable options:

- "resultFile" - send the replacement block to the file (default)
- "skip" - skip the block
- "stderr" - send the block to standard error

The skip case is good for building test lists.  The stderr case
is good for communicating that the json data is unexpected.

When you view the following template fragment in a browser it
shows one item in the list.

template:

#+BEGIN_SRC
<h3>Tea</h3>
<ul>
<!--$ nextline t.list = teaList -->
  <li>{tea}</li>
</ul>
#+END_SRC

To create a static page that has more products for better testing
you could use the skip option like this:

template:

#+BEGIN_SRC
<h3>Tea</h3>
<ul>
<!--$ nextline t.list = teaList -->
  <li>{tea}</li>
<!--$ block t.result = 'skip' -->
  <li>Black</li>
  <li>Green</li>
  <li>Oolong</li>
  <li>Sencha</li>
  <li>Herbal</li>
<!--$ block -->
</ul>
#+END_SRC

json:

#+BEGIN_SRC
{
  "teaList": [
    {"tea": "Chamomile"},
    {"tea": "Chrysanthemum"},
    {"tea": "White"},
    {"tea": "Puer"}
  ]
}
#+END_SRC

result:

#+BEGIN_SRC
<h3>Tea</h3>
<ul>
  <li>Chamomile</li>
  <li>Chrysanthemum</li>
  <li>White</li>
  <li>Puer</li>
</ul>
#+END_SRC

**** Content Variable

The content variable defines what goes in the replace block.

You assign your variable to the content variable and your
variable's value replaces the whole replace block.  The default
is "". The content variable only applies to the replace command.

*** System Functions

There are three built in system functions:

- t.row
- t.if
- t.version

Functions take different numbers of parameters. If you call with
one parameters, you can drop the parentheses.

These are equivalent:

#+BEGIN_SRC
email = t.row(0)
email = t.row 0
#+END_SRC

**** Row Function

The special row function contains the row of the current list. You control the start number.

- row — starts at 0
- _row 0 — starts at 0
- _row 1 — starts at 1
- _row N — starts at N where N is some ordinal number.

Here is an example using the row variable.

template:

#+BEGIN_SRC
<!--$ nextline t.list=car_list -->
<li id="r{t.row}>{t.row 1}. {car}</li>
#+END_SRC

json:

#+BEGIN_SRC
{
  "car_list": [
    {"car": "Tesla"},
    {"car": "Ford"}
  ]
}
#+END_SRC

result:

#+BEGIN_SRC
<li id="r0">1. Tesla</li>
<li id="r1">2. Ford </li>
#+END_SRC

**** If Function

You can use an if statement in a template statement.

The general form of the if statement has three parameters.  If
the first variable is true, the second parameter is returned, else
the third parameter is returned.

You can drop the third and second parameters. Defaults are used
for the missing parameters.

When you drop both, 0 or 1 is returned. The following example
uses the template system to show what happens when you drop the
t.if parameters.

The condition is true when it is 1 or true, else it is false.

**** Version Function

You use the version function to get the current version of
StaticTea or to verify that the version you are running works
with your template.

The version function takes 0, 1 or 2 parameters. The first parameter
is the minimum version supported and the second parameter is the
maximum version supported.

The default minimum is 0.0.0 and the default maximum is anything.

If the current version is below the minimum or above the maximum,
the function outputs a message to standard out.

You can use the function multiple times for fine grain checking.

Below is typical useage:

template:

#+BEGIN_SRC
<--$ nextline version=t.version("1.2.3", "3.4.5") -->
<-- StaticTea current version is: {version}. -->
#+END_SRC

result:

#+BEGIN_SRC
<-- StaticTea current version is: 1.9.0. -->
#+END_SRC

If the current version is not between the min and max, a message
is output to standard error.  Example messages:

stdout:

#+BEGIN_SRC
template(line): the current version 4.0.2 is greater than the maximum
allowed verion of 3.4.5.

template(line): the current version 1.0.0 is less than the minumum
allowed verion of 1.2.3.
#+END_SRC

**** TODO exists, len functions?

template:

#+BEGIN_SRC
<--$ block \-->
<--$ var1=t.if(cond0 dog cat), var2=t.if(cond0 dog), var3=t.if(cond0) \-->
<--$ var4=t.if(cond0 dog cat), var5=t.if(cond0 dog), var6=t.if(cond0) -->

t.if({cond0} dog cat) -> {var1}
t.if({cond0} dog)     -> {var2}
t.if({cond0})         -> {var3}

t.if({cond1} dog cat) -> {var4}
t.if({cond1} dog)     -> {var5}
t.if({cond1})         -> {var6}

<--$ block -->
#+END_SRC

json:

#+BEGIN_SRC
{
  "cond0": 0,
  "cond1": 1,
  "dog": "dog",
  "cat": "cat",
}
#+END_SRC

result:

#+BEGIN_SRC

t.if(0 dog cat) -> cat
t.if(0 dog)      -> 0
t.if(0)          -> 0

t.if(1 dog cat) -> dog
t.if(1 dog)      -> dog
t.if(1)          -> 1

#+END_SRC


# StaticTea as a Filter

You can use the statictea command as a filter and pipe template
lines to it and see the result output on the screen.

Below is an example you can copy and paste into your terminal. It
creates a template.txt file containing two lines, then it creates
the server.json file containing one line, then it runs statictea
using those files and the result goes to the screen.

#+BEGIN_SRC
# create template file
cat <<EOF >template.txt
<!--$ nextline -->
hello {name}
EOF

# create server json file
cat <<EOF >server.json
{"name": "world"}
EOF

statictea --template template.txt --server server.json
#+END_SRC

If you copy and paste those lines to your terminal, it will look
like:

#+BEGIN_SRC
$ cat <<EOF >template.txt
> <!--$ nextline -->
> hello {name}
> EOF
$
$ cat <<EOF >server.json
> {"name": "world"}
> EOF
$
$ statictea --template template.txt --server server.json
hello world
#+END_SRC

The following example pipes template.txt to statictea. The result
goes to the screen.

#+BEGIN_SRC
cat template.txt | statictea --template stdin --server server.json

hello world
#+END_SRC

** Prefix Postfix

You specify the template commands as comments for the type of
result file. This allows you to edit the template using its
native editor.  For example, you can edit an html template with
an html editor.

Comment syntax varies depending on the type of template file and
sometimes depending on the location within the file. StaticTea
supports several varieties and you can specify others.

You want to distinguish StaticTea commands from normal
comments. The convention is to add a $ as the last character of
the prefix and only use $ with StaticTea commands and space for
normal comments.

- `<!--$ ... -->` for html
- `/*--$... --*/` for javascript in html
- `&lt;!--$... --&gt;` for textarea elements

You can define other comment types on the command line using the
prepost option one or more times.

You separate the prefix from the postfix with a space and the
postfix is optional.

examples:

#+BEGIN_SRC
statictea--prepost "@$" "|"
statictea--prepost "[comment$" "]"
statictea--prepost "#$"
#+END_SRC

** Json Files

There are two types of json files the server json and the shared
json.

The server json comes from the server and doesn’t contain any
presentation data.

The share json is used by the template builder to share common
template lines and it contains presentation data.

The server json file is included with the "-server" option.  Its
variables are referenced with the json key names.

The shared json file is specified with the "—shared" option. Its
variables are referenced with the "s." namespace.

You can specify multiple files of both types. Internally there is
one dictionary for the server and one for the shared. The files
get added from left to right so the last duplicate variable wins.

** Warnings and Defaults

When StaticTea encounters an error, it outputs a message to
standard error and continues.  It skips the element with the
problem using some default.

For example, if a variable in a replacement block is used but it
doesn't exist, the variable remains as is and a message is output
telling the line and variable missing.

When the postfix is missing, the line command is still used, but
a warning message is output.

** Run StaticTea

You run StaticTea from the command line. The example below shows
a typical invocation. You specify four file parameters, the
server json, the shared json the template and the result.

#+BEGIN_SRC
statictea --server server.json --shared shared.json --template template.html --result result.html
#+END_SRC

- Warning messages go to standard error.
- If you don't specify the result parameter, the result goes to
standard out.
- It you specify "stdin" for the template, the template comes
  from stdin.

*** Options

The StaticTea command line options:

- help - show the usage and options.
- version - outputs the version number to standard out and exits.
- server - the server json file. You can specify multiple files.
- shared - the shared json file. You can specify multiple files.
- update - update the template replace blocks.

** General Limits

- max command line length
- max continuation lines per command
- max number of shared variables
- max number of server variables
- max replacement block size in bytes
- max literal string length
- max literal number length
- max literal name length
- max json key name length
- max json string value length
- max json size in bytes

Templates are utf-8 encoded or it's subset ascii.  Three line
endings are supported, LF, CR LF, or CR on all platforms.

StaticTea checkes the json file size and if within the limit it
reads it and adds its elements to the shared or server
dictionaries. Duplicate elements overwrite existing elements.  If
a json key length or string value exceeds a limit, it is skipped
and a warning is output.

StaticTea processes template lines. The is not limit on the size
of the template.  It reads lines


** Template Regular Expressions

Literal numbers are small ordinal numbers, 0,1,2,...,99999.

number = ^[0-9]{1,5}$

Literal strings are 0 to 60 characters long. You wrap them with
single or double quotes.

string = ^["][^"]*["]{0,60}|['][^']{0,60}[']$

Literal name starts with a letter followed by letters, digits or
underscores and they are limited to 1 to 32 characters.

Literal name = ^[a-zA-Z][a-zA-Z0-9_]{0,31}$

A namespace is "t." or "s.".

namespace = ^t\.$|^s\.$

A literal variable starts with an optional namespace followed by a name.

variable = [namespace] name

A command is "nextline", "block", "replace" or "#".

command = ^nextline$|^block$|^replace$|^#$

A row function is row(number) where the number is optional and
you can drop the parentheses.

row function = ^row$|^row[\s]+[number]$|^row[\s]*\([\s]*[number]{0,1}[\s]*\)$

A vstring (version string) is 1 to 3 digits three times with a
period between them. "ddd.ddd.ddd"

vstring = ^'\d{1,3}\.\d{1,3}\.\d{1,3}'$|^"\d{1,3}\.\d{1,3}\.\d{1,3}"$

A version function is "version" or "version(vstring, vstring)" where
the vstrings are optional and you can drop the parentheses when
there is only one parameter.

version function = ^version$|^version[\s]+[vstring]+$|^row[\s]*\([\s]*[number]*[\s]*\)$

if function =

#+BEGIN_SRC
template = [line]*
line = text | replacementLine | commandLine
text = .*
replacementLine = [text [bracketedVar]]*
replacementLine = text | [text] bracketedVar [text]
bracketedVar = "{" os rightSide os "}"
commandLine = prefix s command [os "," os statement]* s postfix
space = " " | tab
s = [space]+
os = [space]*
statement = variable os "=" os rightSide
variable = [namespace][a-zA-Z]+[a-zA-Z0-9_]*
namespace = "t." | "s."
rightSide = number | string | variable | function
function = row | version | if
row =  "t.row" [s number] | "t.row" os "(" os [number] os ")"
if = "t.if" rightSide | "t.if" os "(" os rightSide [os "," os rightSide [os "," os rightSide]] os ")"
#+END_SRC
