<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
</head>
<style>
body {
    max-width: 40em;
    font-size: 2em;
    margin-left: 1em;
}

#staticteadep {
    width: 100%;
}

.signature {
    color: green;
}

.code {
    border-left: 6px solid green;
}
</style>
<body>
<h1>replacement.nim</h1>

<p>Handle the replacement block lines.

To support replacement blocks that consists of many lines and blocks
that repeat many times, we read the replacement block and compile
and store it in a temp file in a format that is easy to write out
multiple times.

The temporary file consists of parts of lines called segments. There
are segments for the variables in the line and segments for the rest
of the text.

Segments are a text format containing a number (type), a comma and a
string.

All segments end with a newline. If a template line uses cr/lf, the
segment will end with cr/lf.  The segment type tells you whether to
write out the ending newline or not to the result file.

Segment text are bytes. The bracketed variables are ascii.

A bracketed variable does not contain space around the variable.
{var} not { var }.

To use a left bracket in a replacement block you use two left brackets, {{,
{{ results in {.</p>

Nim source code: <a href="../../src/replacement.nim">replacement.nim</a>

<h1>Index</h1>

<ul>
<li>type:  <a href="#ReplaceLineKind">ReplaceLineKind</a> &mdash; Line type returned by yieldReplacementLine.</li>
<li>type:  <a href="#ReplaceLine">ReplaceLine</a> &mdash; Line information returned by yieldReplacementLine.</li>
<li> <a href="#newReplaceLine">newReplaceLine</a> &mdash; Return a new ReplaceLine object.</li>
<li> <a href="#`$`">`$`</a> &mdash; Return a string representation of a ReplaceLine object.</li>
<li> <a href="#stringSegment">stringSegment</a> &mdash; Return a string segment made from the fragment.</li>
<li> <a href="#varSegment">varSegment</a> &mdash; Return a variable segment made from the dot name.</li>
<li> <a href="#lineToSegments">lineToSegments</a> &mdash; Convert a line to a list of segments.</li>
<li> <a href="#varSegmentDotName">varSegmentDotName</a> &mdash; Given a variable segment, return its dot name.</li>
<li> <a href="#writeTempSegments">writeTempSegments</a> &mdash; Write the replacement block's stored segments to the result stream with the variables filled in.</li>
<li> <a href="#allocTempSegments">allocTempSegments</a> &mdash; Create a TempSegments object.</li>
<li> <a href="#closeDeleteTempSegments">closeDeleteTempSegments</a> &mdash; Close the TempSegments and delete its backing temporary file.</li>
<li> <a href="#storeLineSegments">storeLineSegments</a> &mdash; Divide the line into segments and write them to the TempSegments' temp file.</li>
<li> <a href="#yieldReplacementLine">yieldReplacementLine</a> &mdash; Yield all the replacement block lines and one line after.</li>
</ul>

<h3 id=ReplaceLineKind>ReplaceLineKind</h3>

<p>Line type returned by yieldReplacementLine.

* rlNoLine -- Value when not initialized.
* rlReplaceLine -- A replacement block line.
* rlEndblockLine -- The endblock command line.
* rlNormalLine -- The last line when maxLines was exceeded.</p>

<pre class="signature">
ReplaceLineKind = enum
  rlNoLine, rlReplaceLine, rlEndblockLine, rlNormalLine
</pre>

<h3 id=ReplaceLine>ReplaceLine</h3>

<p>Line information returned by yieldReplacementLine.</p>

<pre class="signature">
ReplaceLine = object
  kind*: ReplaceLineKind
  line*: string

</pre>

<h3 id=newReplaceLine>newReplaceLine</h3>

<p>Return a new ReplaceLine object.</p>

<pre class="signature">
func newReplaceLine(kind: ReplaceLineKind; line: string): ReplaceLine
</pre>

<h3 id=`$`>`$`</h3>

<p>Return a string representation of a ReplaceLine object.</p>

<pre class="signature">
func `$`(replaceLine: ReplaceLine): string
</pre>

<h3 id=stringSegment>stringSegment</h3>

<p>Return a string segment made from the fragment. AtEnd is true when the fragment ends the line.</p>

<pre class="signature">
proc stringSegment(fragment: string; atEnd: bool): string
</pre>

<h3 id=varSegment>varSegment</h3>

<p>Return a variable segment made from the dot name. AtEnd is true when the bracketed variable ends the line.</p>

<pre class="signature">
proc varSegment(dotName: string; atEnd: bool): string
</pre>

<h3 id=lineToSegments>lineToSegments</h3>

<p>Convert a line to a list of segments. No warnings.</p>

<pre class="signature">
proc lineToSegments(line: string): seq[string]
</pre>

<h3 id=varSegmentDotName>varSegmentDotName</h3>

<p>Given a variable segment, return its dot name.</p>

<pre class="signature">
func varSegmentDotName(segment: string): string
</pre>

<h3 id=writeTempSegments>writeTempSegments</h3>

<p>Write the replacement block's stored segments to the result stream with the variables filled in.  The lineNum is the beginning line of the replacement block.</p>

<pre class="signature">
proc writeTempSegments(env: var Env; tempSegments: var TempSegments;
                       lineNum: Natural; variables: Variables)
</pre>

<h3 id=allocTempSegments>allocTempSegments</h3>

<p>Create a TempSegments object. This reserves memory for a line buffer and creates a backing temp file. Call the closeDeleteTempSegments procedure when done to free the memory and to close and delete the file.</p>

<pre class="signature">
proc allocTempSegments(env: var Env; lineNum: Natural): Option[TempSegments]
</pre>

<h3 id=closeDeleteTempSegments>closeDeleteTempSegments</h3>

<p>Close the TempSegments and delete its backing temporary file.</p>

<pre class="signature">
proc closeDeleteTempSegments(tempSegments: TempSegments)
</pre>

<h3 id=storeLineSegments>storeLineSegments</h3>

<p>Divide the line into segments and write them to the TempSegments' temp file.</p>

<pre class="signature">
proc storeLineSegments(env: var Env; tempSegments: TempSegments; line: string)
</pre>

<h3 id=yieldReplacementLine>yieldReplacementLine</h3>

<p>Yield all the replacement block lines and one line after.</p>

<pre class="signature">
iterator yieldReplacementLine(env: var Env; firstReplaceLine: string;
                              lb: var LineBuffer; prepostTable: PrepostTable;
                              command: string; maxLines: Natural): ReplaceLine
</pre>


<p>⦿ This page was generated
by <a href="https://github.com/flenniken/statictea/">statictea</a>
from nim doc comments. ⦿</p>

</body>
</html>
