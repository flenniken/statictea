<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
</head>
<style>
body {
    max-width: 40em;
    font-size: 2em;
    margin-left: 1em;
}

#staticteadep {
    width: 100%;
}

.signature {
    color: green;
}

.code {
    border-left: 6px solid green;
}
</style>
<body>
<h1>vartypes.nim</h1>

<p>StaticTea variable types.</p>

Nim source code: <a href="../../src/vartypes.nim">vartypes.nim</a>

<h1>Index</h1>

<ul>
<li>const:  <a href="#variableStartChars">variableStartChars</a> &mdash; The characters that make up a variable dotname.</li>
<li>const:  <a href="#variableMiddleChars">variableMiddleChars</a> &mdash; A variable contains ascii letters, digits, underscores and hypens.</li>
<li>const:  <a href="#variableChars">variableChars</a> &mdash; A variable contains ascii letters, digits, underscores and hypens.</li>
<li>const:  <a href="#startTFVarNumber">startTFVarNumber</a> &mdash; A character that starts true, false, a variable or a number.</li>
<li>type:  <a href="#VarsDict">VarsDict</a> &mdash; This is a ref type.</li>
<li>type:  <a href="#Mutable">Mutable</a> &mdash; The mutable state of lists and dictionaries.</li>
<li>type:  <a href="#DictType">DictType</a> &mdash; The statictea dictionary type.</li>
<li>type:  <a href="#ListType">ListType</a> &mdash; The statictea list type.</li>
<li>type:  <a href="#Variables">Variables</a> &mdash; Dictionary holding all statictea variables in multiple distinct logical dictionaries.</li>
<li>type:  <a href="#VarsDictOr">VarsDictOr</a> &mdash; A VarsDict object or a warning.</li>
<li>type:  <a href="#ValueKind">ValueKind</a> &mdash; The statictea variable types.</li>
<li>type:  <a href="#Value">Value</a> &mdash; A variable's value reference.</li>
<li>type:  <a href="#ValueOr">ValueOr</a> &mdash; A Value object or a warning.</li>
<li>type:  <a href="#Statement">Statement</a> &mdash; Statement object stores the statement text, the line number and its line ending.</li>
<li>type:  <a href="#FunctionPtr">FunctionPtr</a> &mdash; Signature of a statictea built in function.</li>
<li>type:  <a href="#ParamCode">ParamCode</a> &mdash; Parameter type, one character of "ifsldpa" corresponding to int, float, string, list, dict, func, any.</li>
<li>type:  <a href="#ParamType">ParamType</a> &mdash; The statictea parameter types.</li>
<li>type:  <a href="#Param">Param</a> &mdash; Holds attributes for one parameter.</li>
<li>type:  <a href="#Signature">Signature</a> &mdash; Holds the function signature.</li>
<li>type:  <a href="#SignatureOr">SignatureOr</a> &mdash; A signature or message.</li>
<li>type:  <a href="#FunctionSpec">FunctionSpec</a> &mdash; Holds the function details.</li>
<li>type:  <a href="#FunResultKind">FunResultKind</a> &mdash; The kind of a FunResult object, either a value or warning.</li>
<li>type:  <a href="#FunResult">FunResult</a> &mdash; Contains the result of calling a function, either a value or a warning.</li>
<li>type:  <a href="#SideEffect">SideEffect</a> &mdash; The kind of side effect for a statement.</li>
<li>type:  <a href="#ValuePosSi">ValuePosSi</a> &mdash; A value and the position after the value in the statement along with the side effect, if any.</li>
<li>type:  <a href="#ValuePosSiOr">ValuePosSiOr</a> &mdash; A ValuePosSi object or a warning.</li>
<li> <a href="#newSignature">newSignature</a> &mdash; Create a Signature object.</li>
<li> <a href="#newSignatureOr">newSignatureOr</a> &mdash; Create a new SignatureOr with a message.</li>
<li> <a href="#newSignatureOr">newSignatureOr</a> &mdash; Create a new SignatureOr with a message.</li>
<li> <a href="#newSignatureOr">newSignatureOr</a> &mdash; Create a new SignatureOr with a value.</li>
<li> <a href="#newSignatureOr">newSignatureOr</a> &mdash; Create a SignatureOr object.</li>
<li> <a href="#newParam">newParam</a> &mdash; Create a new Param object.</li>
<li> <a href="#newVarsDict">newVarsDict</a> &mdash; Create a new empty variables dictionary.</li>
<li> <a href="#newVarsDictOr">newVarsDictOr</a> &mdash; Return a new varsDictOr object containing a warning.</li>
<li> <a href="#newVarsDictOr">newVarsDictOr</a> &mdash; Return a new VarsDict object containing a dictionary.</li>
<li> <a href="#newDictType">newDictType</a> &mdash; </li>
<li> <a href="#newListType">newListType</a> &mdash; </li>
<li> <a href="#newValue">newValue</a> &mdash; Create a string value.</li>
<li> <a href="#newValue">newValue</a> &mdash; Create an integer value.</li>
<li> <a href="#newValue">newValue</a> &mdash; Create a bool value.</li>
<li> <a href="#newValue">newValue</a> &mdash; Create a float value.</li>
<li> <a href="#newValue">newValue</a> &mdash; Create a list value.</li>
<li> <a href="#newValue">newValue</a> &mdash; Create a dictionary value from a VarsDict.</li>
<li> <a href="#newValue">newValue</a> &mdash; New value from an existing value.</li>
<li> <a href="#newValue">newValue</a> &mdash; New list value from an array of items of the same kind.</li>
<li> <a href="#newValue">newValue</a> &mdash; New dict value from an array of pairs where the pairs are the
same type which may be Value type.</li>
<li> <a href="#newFunc">newFunc</a> &mdash; Create a new func which is a FunctionSpec.</li>
<li> <a href="#newValue">newValue</a> &mdash; Create a new func value.</li>
<li> <a href="#newEmptyListValue">newEmptyListValue</a> &mdash; Return an empty list value.</li>
<li> <a href="#newEmptyDictValue">newEmptyDictValue</a> &mdash; Create a dictionary value from a VarsDict.</li>
<li> <a href="#`==`">`==`</a> &mdash; Return true when two variables are equal.</li>
<li> <a href="#newStatement">newStatement</a> &mdash; Create a new statement.</li>
<li> <a href="#`$`">`$`</a> &mdash; Return a string representation of a signature.</li>
<li> <a href="#`$`">`$`</a> &mdash; Return a string representation of a function.</li>
<li> <a href="#jsonStringRepr">jsonStringRepr</a> &mdash; Return the JSON string representation.</li>
<li> <a href="#dictToString">dictToString</a> &mdash; Return a string representation of a dict Value in JSON format.</li>
<li> <a href="#listToString">listToString</a> &mdash; Return a string representation of a list variable in JSON format.</li>
<li> <a href="#valueToString">valueToString</a> &mdash; Return a string representation of a variable in JSON format.</li>
<li> <a href="#valueToStringRB">valueToStringRB</a> &mdash; Return the string representation of the variable for use in the replacement blocks.</li>
<li> <a href="#`$`">`$`</a> &mdash; Return a string representation of a Value.</li>
<li> <a href="#`$`">`$`</a> &mdash; Return a string representation of a VarsDict.</li>
<li> <a href="#dotNameRep">dotNameRep</a> &mdash; Return a dot name string representation of a dictionary.</li>
<li> <a href="#newValueOr">newValueOr</a> &mdash; Create a new ValueOr containing a warning.</li>
<li> <a href="#newValueOr">newValueOr</a> &mdash; Create a new ValueOr containing a warning.</li>
<li> <a href="#newValueOr">newValueOr</a> &mdash; Create a new ValueOr containing a value.</li>
<li> <a href="#newFunResultWarn">newFunResultWarn</a> &mdash; Return a new FunResult object containing a warning.</li>
<li> <a href="#newFunResultWarn">newFunResultWarn</a> &mdash; Return a new FunResult object containing a warning created from a WarningData object.</li>
<li> <a href="#newFunResult">newFunResult</a> &mdash; Return a new FunResult object containing a value.</li>
<li> <a href="#`==`">`==`</a> &mdash; Compare two FunResult objects and return true when equal.</li>
<li> <a href="#`!=`">`!=`</a> &mdash; Compare two FunResult objects and return false when equal.</li>
<li> <a href="#`$`">`$`</a> &mdash; Return a string representation of a FunResult object.</li>
<li> <a href="#newValuePosSi">newValuePosSi</a> &mdash; Create a newValuePosSi object.</li>
<li> <a href="#newValuePosSiOr">newValuePosSiOr</a> &mdash; Create a ValuePosSiOr warning.</li>
<li> <a href="#newValuePosSiOr">newValuePosSiOr</a> &mdash; Create a ValuePosSiOr warning.</li>
<li> <a href="#`==`">`==`</a> &mdash; Return true when a equals b.</li>
<li> <a href="#`==`">`==`</a> &mdash; Return true when a equals b.</li>
<li> <a href="#`!=`">`!=`</a> &mdash; Compare two ValuePosSi objects and return false when equal.</li>
<li> <a href="#`!=`">`!=`</a> &mdash; Compare two ValuePosSiOr objects and return false when equal.</li>
<li> <a href="#newValuePosSiOr">newValuePosSiOr</a> &mdash; Create a ValuePosSiOr from a value, pos and exit.</li>
<li> <a href="#newValuePosSiOr">newValuePosSiOr</a> &mdash; Create a ValuePosSiOr value from a number or string.</li>
<li> <a href="#newValuePosSiOr">newValuePosSiOr</a> &mdash; Create a ValuePosSiOr from a ValuePosSi.</li>
<li> <a href="#codeToParamType">codeToParamType</a> &mdash; Convert a parameter code letter to a ParamType.</li>
<li> <a href="#strToParamType">strToParamType</a> &mdash; Return the parameter type for the given string, e.</li>
<li> <a href="#shortName">shortName</a> &mdash; Return a short name based on the given index value.</li>
<li> <a href="#newSignatureO">newSignatureO</a> &mdash; Return a new signature for the function name and signature code.</li>
</ul>

<h3 id=variableStartChars>variableStartChars</h3>

<p>The characters that make up a variable dotname.  A variable starts with an ascii letter.</p>

<pre class="signature">
variableStartChars: set[char] =
</pre>

<h3 id=variableMiddleChars>variableMiddleChars</h3>

<p>A variable contains ascii letters, digits, underscores and hypens.</p>

<pre class="signature">
variableMiddleChars: set[char] =
</pre>

<h3 id=variableChars>variableChars</h3>

<p>A variable contains ascii letters, digits, underscores and hypens. Variables are connected with dots to make a dot name.</p>

<pre class="signature">
variableChars: set[char] =
</pre>

<h3 id=startTFVarNumber>startTFVarNumber</h3>

<p>A character that starts true, false, a variable or a number.</p>

<pre class="signature">
startTFVarNumber: set[char] =
</pre>

<h3 id=VarsDict>VarsDict</h3>

<p>This is a ref type. Create a new VarsDict with newVarsDict procedure.</p>

<pre class="signature">
VarsDict = OrderedTableRef[string, Value]
</pre>

<h3 id=Mutable>Mutable</h3>

<p>The mutable state of lists and dictionaries.
* immutable -- you cannot change it
* append -- you can append to the end
* full -- you can change everything</p>

<pre class="signature">
Mutable
</pre>

<h3 id=DictType>DictType</h3>

<p>The statictea dictionary type.

* dict -- an ordered dictionary.
* mutable -- whether you can append to the dictionary or not.</p>

<pre class="signature">
DictType = object
  dict*: VarsDict
  mutable*: Mutable

</pre>

<h3 id=ListType>ListType</h3>

<p>The statictea list type.

* list -- a list of values.
* mutable -- whether you can append to the dictionary or not.</p>

<pre class="signature">
ListType = object
  list*: seq[Value]
  mutable*: Mutable

</pre>

<h3 id=Variables>Variables</h3>

<p>Dictionary holding all statictea variables in multiple distinct logical dictionaries.</p>

<pre class="signature">
Variables = VarsDict
</pre>

<h3 id=VarsDictOr>VarsDictOr</h3>

<p>A VarsDict object or a warning.</p>

<pre class="signature">
VarsDictOr = OpResultWarn[VarsDict]
</pre>

<h3 id=ValueKind>ValueKind</h3>

<p>The statictea variable types.
* vkString -- string of UTF-8 characters
* vkInt -- 64 bit signed integer
* vkFloat -- 64 bit floating point number
* vkDict -- hash table mapping strings to any value
* vkList -- a list of values of any type
* vkBool -- true or false
* vkFunc -- reference to a function</p>

<pre class="signature">
ValueKind = enum
  vkString = "string", vkInt = "int", vkFloat = "float", vkDict = "dict",
  vkList = "list", vkBool = "bool", vkFunc = "func"
</pre>

<h3 id=Value>Value</h3>

<p>A variable's value reference.</p>

<pre class="signature">
Value = ref ValueObj
</pre>

<h3 id=ValueOr>ValueOr</h3>

<p>A Value object or a warning.</p>

<pre class="signature">
ValueOr = OpResultWarn[Value]
</pre>

<h3 id=Statement>Statement</h3>

<p>Statement object stores the statement text, the line number and its line ending.

* text -- a line containing a statement without the line ending
* lineNum -- line number in the file where the statement starts (the first line is 1)
statement starts.
* ending -- the line ending, either linefeed (\n) or carriage return and linefeed (\r\n).</p>

<pre class="signature">
Statement = object
  text*: string
  lineNum*: Natural
  ending*: string

</pre>

<h3 id=FunctionPtr>FunctionPtr</h3>

<p>Signature of a statictea built in function. It takes any number of values and returns a value or a warning message.</p>

<pre class="signature">
FunctionPtr = proc (variables: Variables; parameters: seq[Value]): FunResult
</pre>

<h3 id=ParamCode>ParamCode</h3>

<p>Parameter type, one character of "ifsldpa" corresponding to int, float, string, list, dict, func, any.</p>

<pre class="signature">
ParamCode = char
</pre>

<h3 id=ParamType>ParamType</h3>

<p>The statictea parameter types. The same as the variable types ValueKind with an extra for "any".
* ptString -- string parameter type
* ptInt -- integer
* ptFloat -- floating point number
* ptDict -- dictionary
* ptList -- list
* ptBool -- boolean
* ptFunc -- function pointer
* ptAny -- any parameter type</p>

<pre class="signature">
ParamType = enum
  ptString = "string", ptInt = "int", ptFloat = "float", ptDict = "dict",
  ptList = "list", ptBool = "bool", ptFunc = "func", ptAny = "any"
</pre>

<h3 id=Param>Param</h3>

<p>Holds attributes for one parameter.
* name -- the parameter name
* paramType -- the parameter type</p>

<pre class="signature">
Param = object
  name*: string
  paramType*: ParamType

</pre>

<h3 id=Signature>Signature</h3>

<p>Holds the function signature.
* optional -- true when the last parameter is optional
* name -- the function name
* params -- a list of the function parameter names and types
* returnType -- the function return type</p>

<pre class="signature">
Signature = object
  optional*: bool
  name*: string
  params*: seq[Param]
  returnType*: ParamType

</pre>

<h3 id=SignatureOr>SignatureOr</h3>

<p>A signature or message.</p>

<pre class="signature">
SignatureOr = OpResultWarn[Signature]
</pre>

<h3 id=FunctionSpec>FunctionSpec</h3>

<p>Holds the function details.

* builtIn -- true for the built-in functions, false for user functions
* signature -- the function signature
* docComment -- the function document comment
* filename -- the filename where the function is defined either the code file or functions.nim
* lineNum -- the line number where the function definition starts
* numLines -- the number of lines to define the function
* statements -- a list of the function statements for user functions
* functionPtr -- pointer to the function for built-in functions</p>

<pre class="signature">
FunctionSpec = object
  builtIn*: bool
  signature*: Signature
  docComment*: string
  filename*: string
  lineNum*: Natural
  numLines*: Natural
  statements*: seq[Statement]
  functionPtr*: FunctionPtr

</pre>

<h3 id=FunResultKind>FunResultKind</h3>

<p>The kind of a FunResult object, either a value or warning.
* frValue -- a value
* frWarning -- a warning message</p>

<pre class="signature">
FunResultKind = enum
  frValue, frWarning
</pre>

<h3 id=FunResult>FunResult</h3>

<p>Contains the result of calling a function, either a value or a warning.

The parameter field is the index of the problem argument or
-1 to point at the function itself.</p>

<pre class="signature">
FunResult = object
  case kind*: FunResultKind
  of frValue:
      value*: Value

  of frWarning:
      parameter*: int
      warningData*: WarningData


</pre>

<h3 id=SideEffect>SideEffect</h3>

<p>The kind of side effect for a statement.

* seNone -- no side effect, the normal case
* seReturn -- the return function; stop the command and
either skip the replacement block or stop iterating
* seLogMessage -- the log function; write a message to the log file
* seIf2False -- the two parameter IF condition was false</p>

<pre class="signature">
SideEffect = enum
  seNone = "none", seReturn = "return", seLogMessage = "log",
  seIf2False = "if2False"
</pre>

<h3 id=ValuePosSi>ValuePosSi</h3>

<p>A value and the position after the value in the statement along with the side effect, if any. The position includes the trailing whitespace.  For the example statement below, the value 567 starts at index 6 and ends at position 10.

~~~
0123456789 123456789
var = 567 # test
      ^ start
          ^ end position
~~~</p>

<pre class="signature">
ValuePosSi = object
  value*: Value
  pos*: Natural
  sideEffect*: SideEffect

</pre>

<h3 id=ValuePosSiOr>ValuePosSiOr</h3>

<p>A ValuePosSi object or a warning.</p>

<pre class="signature">
ValuePosSiOr = OpResultWarn[ValuePosSi]
</pre>

<h3 id=newSignature>newSignature</h3>

<p>Create a Signature object.</p>

<pre class="signature">
proc newSignature(optional: bool; name: string; params: seq[Param];
                  returnType: ParamType): Signature
</pre>

<h3 id=newSignatureOr>newSignatureOr</h3>

<p>Create a new SignatureOr with a message.</p>

<pre class="signature">
func newSignatureOr(warning: MessageId; p1 = ""; pos = 0): SignatureOr
</pre>

<h3 id=newSignatureOr>newSignatureOr</h3>

<p>Create a new SignatureOr with a message.</p>

<pre class="signature">
func newSignatureOr(warningData: WarningData): SignatureOr
</pre>

<h3 id=newSignatureOr>newSignatureOr</h3>

<p>Create a new SignatureOr with a value.</p>

<pre class="signature">
func newSignatureOr(signature: Signature): SignatureOr
</pre>

<h3 id=newSignatureOr>newSignatureOr</h3>

<p>Create a SignatureOr object.</p>

<pre class="signature">
proc newSignatureOr(optional: bool; name: string; params: seq[Param];
                    returnType: ParamType): SignatureOr
</pre>

<h3 id=newParam>newParam</h3>

<p>Create a new Param object.</p>

<pre class="signature">
func newParam(name: string; paramType: ParamType): Param
</pre>

<h3 id=newVarsDict>newVarsDict</h3>

<p>Create a new empty variables dictionary. VarsDict is a ref type.</p>

<pre class="signature">
proc newVarsDict(): VarsDict
</pre>

<h3 id=newVarsDictOr>newVarsDictOr</h3>

<p>Return a new varsDictOr object containing a warning.</p>

<pre class="signature">
func newVarsDictOr(warning: MessageId; p1: string = ""; pos = 0): VarsDictOr
</pre>

<h3 id=newVarsDictOr>newVarsDictOr</h3>

<p>Return a new VarsDict object containing a dictionary.</p>

<pre class="signature">
func newVarsDictOr(varsDict: VarsDict): VarsDictOr
</pre>

<h3 id=newDictType>newDictType</h3>

<p></p>

<pre class="signature">
func newDictType(varsDict: VarsDict; mutable = Mutable.immutable): DictType
</pre>

<h3 id=newListType>newListType</h3>

<p></p>

<pre class="signature">
func newListType(valueList: seq[Value]; mutable = Mutable.immutable): ListType
</pre>

<h3 id=newValue>newValue</h3>

<p>Create a string value.</p>

<pre class="signature">
proc newValue(str: string): Value
</pre>

<h3 id=newValue>newValue</h3>

<p>Create an integer value.</p>

<pre class="signature">
proc newValue(num: int | int64): Value
</pre>

<h3 id=newValue>newValue</h3>

<p>Create a bool value.</p>

<pre class="signature">
proc newValue(a: bool): Value
</pre>

<h3 id=newValue>newValue</h3>

<p>Create a float value.</p>

<pre class="signature">
proc newValue(num: float): Value
</pre>

<h3 id=newValue>newValue</h3>

<p>Create a list value.</p>

<pre class="signature">
proc newValue(valueList: seq[Value]; mutable = Mutable.immutable): Value
</pre>

<h3 id=newValue>newValue</h3>

<p>Create a dictionary value from a VarsDict.</p>

<pre class="signature">
proc newValue(varsDict: VarsDict; mutable = Mutable.immutable): Value
</pre>

<h3 id=newValue>newValue</h3>

<p>New value from an existing value. Since values are ref types, the
new value is an alias to the same value.</p>

<pre class="signature">
proc newValue(value: Value): Value
</pre>

<h3 id=newValue>newValue</h3>

<p>New list value from an array of items of the same kind.

~~~
let listValue = newValue([1, 2, 3])
let listValue = newValue(["a", "b", "c"])
let listValue = newValue([newValue(1), newValue("b")])
~~~</p>

<pre class="signature">
proc newValue[T](list: openArray[T]; mutable = Mutable.immutable): Value
</pre>

<h3 id=newValue>newValue</h3>

<p>New dict value from an array of pairs where the pairs are the
same type which may be Value type.

~~~
 let dictValue = newValue([("a", 1), ("b", 2), ("c", 3)])
 let dictValue = newValue([("a", 1.1), ("b", 2.2), ("c", 3.3)])
 let dictValue = newValue([("a", newValue(1.1)), ("b", newValue("a"))])
~~~</p>

<pre class="signature">
proc newValue[T](dictPairs: openArray[(string, T)]; mutable = Mutable.immutable): Value
</pre>

<h3 id=newFunc>newFunc</h3>

<p>Create a new func which is a FunctionSpec.</p>

<pre class="signature">
func newFunc(builtIn: bool; signature: Signature; docComment: string;
             filename: string; lineNum: Natural; numLines: Natural;
             statements: seq[Statement]; functionPtr: FunctionPtr): FunctionSpec
</pre>

<h3 id=newValue>newValue</h3>

<p>Create a new func value.</p>

<pre class="signature">
func newValue(function: FunctionSpec): Value
</pre>

<h3 id=newEmptyListValue>newEmptyListValue</h3>

<p>Return an empty list value.</p>

<pre class="signature">
proc newEmptyListValue(mutable = Mutable.immutable): Value
</pre>

<h3 id=newEmptyDictValue>newEmptyDictValue</h3>

<p>Create a dictionary value from a VarsDict.</p>

<pre class="signature">
proc newEmptyDictValue(mutable = Mutable.immutable): Value
</pre>

<h3 id=`==`>`==`</h3>

<p>Return true when two variables are equal.</p>

<pre class="signature">
proc `==`(a: Value; b: Value): bool
</pre>

<h3 id=newStatement>newStatement</h3>

<p>Create a new statement.</p>

<pre class="signature">
func newStatement(text: string; lineNum: Natural = 1; ending = "\n"): Statement
</pre>

<h3 id=`$`>`$`</h3>

<p>Return a string representation of a signature.</p>

<pre class="signature">
func `$`(signature: Signature): string
</pre>

<h3 id=`$`>`$`</h3>

<p>Return a string representation of a function.</p>

<pre class="signature">
func `$`(function: FunctionSpec): string
</pre>

<h3 id=jsonStringRepr>jsonStringRepr</h3>

<p>Return the JSON string representation. It is assumed the string is a valid UTF-8 encoded string.</p>

<pre class="signature">
proc jsonStringRepr(str: string): string
</pre>

<h3 id=dictToString>dictToString</h3>

<p>Return a string representation of a dict Value in JSON format.</p>

<pre class="signature">
func dictToString(value: Value): string
</pre>

<h3 id=listToString>listToString</h3>

<p>Return a string representation of a list variable in JSON format.</p>

<pre class="signature">
func listToString(value: Value): string
</pre>

<h3 id=valueToString>valueToString</h3>

<p>Return a string representation of a variable in JSON format.</p>

<pre class="signature">
func valueToString(value: Value): string
</pre>

<h3 id=valueToStringRB>valueToStringRB</h3>

<p>Return the string representation of the variable for use in the replacement blocks.</p>

<pre class="signature">
func valueToStringRB(value: Value): string
</pre>

<h3 id=`$`>`$`</h3>

<p>Return a string representation of a Value.</p>

<pre class="signature">
func `$`(value: Value): string
</pre>

<h3 id=`$`>`$`</h3>

<p>Return a string representation of a VarsDict.</p>

<pre class="signature">
proc `$`(varsDict: VarsDict): string
</pre>

<h3 id=dotNameRep>dotNameRep</h3>

<p>Return a dot name string representation of a dictionary. The top variables tells whether the dict is the variables dictionary.</p>

<pre class="signature">
func dotNameRep(dict: VarsDict; leftSide: string = ""; top = false): string
</pre>

<h3 id=newValueOr>newValueOr</h3>

<p>Create a new ValueOr containing a warning.</p>

<pre class="signature">
func newValueOr(warning: MessageId; p1 = ""; pos = 0): ValueOr
</pre>

<h3 id=newValueOr>newValueOr</h3>

<p>Create a new ValueOr containing a warning.</p>

<pre class="signature">
func newValueOr(warningData: WarningData): ValueOr
</pre>

<h3 id=newValueOr>newValueOr</h3>

<p>Create a new ValueOr containing a value.</p>

<pre class="signature">
func newValueOr(value: Value): ValueOr
</pre>

<h3 id=newFunResultWarn>newFunResultWarn</h3>

<p>Return a new FunResult object containing a warning. It takes a message id, the index of the problem parameter, and the optional string that goes with the warning.</p>

<pre class="signature">
func newFunResultWarn(warning: MessageId; parameter: int = 0; p1: string = "";
                      pos = 0): FunResult
</pre>

<h3 id=newFunResultWarn>newFunResultWarn</h3>

<p>Return a new FunResult object containing a warning created from a WarningData object.</p>

<pre class="signature">
func newFunResultWarn(warningData: WarningData; parameter: int = 0): FunResult
</pre>

<h3 id=newFunResult>newFunResult</h3>

<p>Return a new FunResult object containing a value.</p>

<pre class="signature">
func newFunResult(value: Value): FunResult
</pre>

<h3 id=`==`>`==`</h3>

<p>Compare two FunResult objects and return true when equal.</p>

<pre class="signature">
func `==`(r1: FunResult; r2: FunResult): bool
</pre>

<h3 id=`!=`>`!=`</h3>

<p>Compare two FunResult objects and return false when equal.</p>

<pre class="signature">
proc `!=`(a: FunResult; b: FunResult): bool
</pre>

<h3 id=`$`>`$`</h3>

<p>Return a string representation of a FunResult object.</p>

<pre class="signature">
func `$`(funResult: FunResult): string
</pre>

<h3 id=newValuePosSi>newValuePosSi</h3>

<p>Create a newValuePosSi object.</p>

<pre class="signature">
proc newValuePosSi(value: Value; pos: Natural; sideEffect: SideEffect = seNone): ValuePosSi
</pre>

<h3 id=newValuePosSiOr>newValuePosSiOr</h3>

<p>Create a ValuePosSiOr warning.</p>

<pre class="signature">
func newValuePosSiOr(warning: MessageId; p1 = ""; pos = 0): ValuePosSiOr
</pre>

<h3 id=newValuePosSiOr>newValuePosSiOr</h3>

<p>Create a ValuePosSiOr warning.</p>

<pre class="signature">
func newValuePosSiOr(warningData: WarningData): ValuePosSiOr
</pre>

<h3 id=`==`>`==`</h3>

<p>Return true when a equals b.</p>

<pre class="signature">
proc `==`(a: ValuePosSi; b: ValuePosSi): bool
</pre>

<h3 id=`==`>`==`</h3>

<p>Return true when a equals b.</p>

<pre class="signature">
proc `==`(a: ValuePosSiOr; b: ValuePosSiOr): bool
</pre>

<h3 id=`!=`>`!=`</h3>

<p>Compare two ValuePosSi objects and return false when equal.</p>

<pre class="signature">
proc `!=`(a: ValuePosSi; b: ValuePosSi): bool
</pre>

<h3 id=`!=`>`!=`</h3>

<p>Compare two ValuePosSiOr objects and return false when equal.</p>

<pre class="signature">
proc `!=`(a: ValuePosSiOr; b: ValuePosSiOr): bool
</pre>

<h3 id=newValuePosSiOr>newValuePosSiOr</h3>

<p>Create a ValuePosSiOr from a value, pos and exit.</p>

<pre class="signature">
func newValuePosSiOr(value: Value; pos: Natural; sideEffect: SideEffect = seNone): ValuePosSiOr
</pre>

<h3 id=newValuePosSiOr>newValuePosSiOr</h3>

<p>Create a ValuePosSiOr value from a number or string.</p>

<pre class="signature">
proc newValuePosSiOr(number: int | int64 | float64 | string; pos: Natural): ValuePosSiOr
</pre>

<h3 id=newValuePosSiOr>newValuePosSiOr</h3>

<p>Create a ValuePosSiOr from a ValuePosSi.</p>

<pre class="signature">
func newValuePosSiOr(val: ValuePosSi): ValuePosSiOr
</pre>

<h3 id=codeToParamType>codeToParamType</h3>

<p>Convert a parameter code letter to a ParamType.</p>

<pre class="signature">
func codeToParamType(code: ParamCode): ParamType
</pre>

<h3 id=strToParamType>strToParamType</h3>

<p>Return the parameter type for the given string, e.g. "int" to ptInt.</p>

<pre class="signature">
func strToParamType(str: string): ParamType
</pre>

<h3 id=shortName>shortName</h3>

<p>Return a short name based on the given index value. Return a for 0, b for 1, etc.  It returns names a, b, c, ..., z then repeats a0, b0, c0,....</p>

<pre class="signature">
proc shortName(index: Natural): string
</pre>

<h3 id=newSignatureO>newSignatureO</h3>

<p>Return a new signature for the function name and signature code. The parameter names come from the shortName function for letters a through z in order. The last letter in the code is the function's return type.

Example:

~~~
var signatureO = newSignatureO("myname", "ifss")
echo $signatureO.get()
=>
myname(a: int, b: float, c: string) string
~~~</p>

<pre class="signature">
func newSignatureO(functionName: string; signatureCode: string): Option[
    Signature]
</pre>


<p>⦿ This page was generated
by <a href="https://github.com/flenniken/statictea/">statictea</a>
from nim doc comments. ⦿</p>

</body>
</html>
