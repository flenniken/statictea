<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>vartypes.nim</title>
<style>
body {
    max-width: 40em;
    font-size: 2em;
    margin-left: 1em;
}

#staticteadep {
    width: 100%;
}

.signature {
    color: green;
}

.description {
    white-space: pre-wrap;
}

.nim-code {
    border-left: 6px solid green;
    padding: 16px;
    background-color: #f6f8fa;
    border-radius: 6px;
}
</style>
</head>
<body>
<h1>vartypes.nim</h1>

StaticTea variable types.

Nim source code: <a href="../../src/vartypes.nim">vartypes.nim</a>

<h1>Index</h1>

<ul>
<li>const:  <a href="#variableStartChars">variableStartChars</a> &mdash; The characters that make up a variable dotname.</li>
<li>const:  <a href="#variableMiddleChars">variableMiddleChars</a> &mdash; A variable contains ascii letters, digits, underscores and hypens.</li>
<li>const:  <a href="#variableChars">variableChars</a> &mdash; A variable contains ascii letters, digits, underscores and hypens.</li>
<li>const:  <a href="#startTFVarNumber">startTFVarNumber</a> &mdash; A character that starts true, false, a variable or a number.</li>
<li>type:  <a href="#VarsDict">VarsDict</a> &mdash; This is a ref type.</li>
<li>type:  <a href="#Mutable">Mutable</a> &mdash; The mutable state of lists and dictionaries.</li>
<li>type:  <a href="#DictType">DictType</a> &mdash; The statictea dictionary type.</li>
<li>type:  <a href="#ListType">ListType</a> &mdash; The statictea list type.</li>
<li>type:  <a href="#Variables">Variables</a> &mdash; Dictionary holding all statictea variables in multiple distinct logical dictionaries.</li>
<li>type:  <a href="#VarsDictOr">VarsDictOr</a> &mdash; A VarsDict object or a warning.</li>
<li>type:  <a href="#ValueKind">ValueKind</a> &mdash; The statictea variable types.</li>
<li>type:  <a href="#Value">Value</a> &mdash; A variable's value reference.</li>
<li>type:  <a href="#ValueOr">ValueOr</a> &mdash; A Value object or a warning.</li>
<li>type:  <a href="#Statement">Statement</a> &mdash; Statement object stores the statement text, the line number and its line ending.</li>
<li>type:  <a href="#FunctionPtr">FunctionPtr</a> &mdash; Signature of a statictea built in function.</li>
<li>type:  <a href="#ParamCode">ParamCode</a> &mdash; Parameter type, one character of "ifsldpa" corresponding to int, float, string, list, dict, func, any.</li>
<li>type:  <a href="#ParamType">ParamType</a> &mdash; The statictea parameter types.</li>
<li>type:  <a href="#Param">Param</a> &mdash; Holds attributes for one parameter.</li>
<li>type:  <a href="#Signature">Signature</a> &mdash; Holds the function signature.</li>
<li>type:  <a href="#SignatureOr">SignatureOr</a> &mdash; A signature or message.</li>
<li>type:  <a href="#FunctionSpec">FunctionSpec</a> &mdash; Holds the function details.</li>
<li>type:  <a href="#FunResultKind">FunResultKind</a> &mdash; The kind of a FunResult object, either a value or warning.</li>
<li>type:  <a href="#FunResult">FunResult</a> &mdash; Contains the result of calling a function, either a value or a warning.</li>
<li>type:  <a href="#SideEffect">SideEffect</a> &mdash; The kind of side effect for a statement.</li>
<li>type:  <a href="#ValuePosSi">ValuePosSi</a> &mdash; A value and the position after the value in the statement along with the side effect, if any.</li>
<li>type:  <a href="#ValuePosSiOr">ValuePosSiOr</a> &mdash; A ValuePosSi object or a warning.</li>
<li> <a href="#newSignature">newSignature</a> &mdash; Create a Signature object.</li>
<li> <a href="#newSignatureOr">newSignatureOr</a> &mdash; Create a new SignatureOr with a message.</li>
<li> <a href="#newSignatureOr-1">newSignatureOr</a> &mdash; Create a new SignatureOr with a message.</li>
<li> <a href="#newSignatureOr-2">newSignatureOr</a> &mdash; Create a new SignatureOr with a value.</li>
<li> <a href="#newSignatureOr-3">newSignatureOr</a> &mdash; Create a SignatureOr object.</li>
<li> <a href="#newParam">newParam</a> &mdash; Create a new Param object.</li>
<li> <a href="#newVarsDict">newVarsDict</a> &mdash; Create a new empty variables dictionary.</li>
<li> <a href="#newVarsDictOr">newVarsDictOr</a> &mdash; Return a new varsDictOr object containing a warning.</li>
<li> <a href="#newVarsDictOr-1">newVarsDictOr</a> &mdash; Return a new VarsDict object containing a dictionary.</li>
<li> <a href="#newDictType">newDictType</a> &mdash; </li>
<li> <a href="#newListType">newListType</a> &mdash; </li>
<li> <a href="#newValue">newValue</a> &mdash; Create a string value.</li>
<li> <a href="#newValue-1">newValue</a> &mdash; Create an integer value.</li>
<li> <a href="#newValue-2">newValue</a> &mdash; Create a bool value.</li>
<li> <a href="#newValue-3">newValue</a> &mdash; Create a float value.</li>
<li> <a href="#newValue-4">newValue</a> &mdash; Create a list value.</li>
<li> <a href="#newValue-5">newValue</a> &mdash; Create a dictionary value from a VarsDict.</li>
<li> <a href="#newValue-6">newValue</a> &mdash; New value from an existing value.</li>
<li> <a href="#newValue-7">newValue</a> &mdash; New list value from an array of items of the same kind.</li>
<li> <a href="#newValue-8">newValue</a> &mdash; New dict value from an array of pairs where the pairs are the
same type which may be Value type.</li>
<li> <a href="#newFunc">newFunc</a> &mdash; Create a new func which is a FunctionSpec.</li>
<li> <a href="#newValue-9">newValue</a> &mdash; Create a new func value.</li>
<li> <a href="#newEmptyListValue">newEmptyListValue</a> &mdash; Return an empty list value.</li>
<li> <a href="#newEmptyDictValue">newEmptyDictValue</a> &mdash; Create a dictionary value from a VarsDict.</li>
<li> <a href="#a___">`==`</a> &mdash; Return true when two variables are equal.</li>
<li> <a href="#newStatement">newStatement</a> &mdash; Create a new statement.</li>
<li> <a href="#a__">`$`</a> &mdash; Return a string representation of a signature.</li>
<li> <a href="#a__-1">`$`</a> &mdash; Return a string representation of a function.</li>
<li> <a href="#jsonStringRepr">jsonStringRepr</a> &mdash; Return the JSON string representation.</li>
<li> <a href="#dictToString">dictToString</a> &mdash; Return a string representation of a dict Value in JSON format.</li>
<li> <a href="#listToString">listToString</a> &mdash; Return a string representation of a list variable in JSON format.</li>
<li> <a href="#valueToString">valueToString</a> &mdash; Return a string representation of a variable in JSON format.</li>
<li> <a href="#valueToStringRB">valueToStringRB</a> &mdash; Return the string representation of the variable for use in the replacement blocks.</li>
<li> <a href="#a__-2">`$`</a> &mdash; Return a string representation of a Value.</li>
<li> <a href="#a__-3">`$`</a> &mdash; Return a string representation of a VarsDict.</li>
<li> <a href="#dotNameRep">dotNameRep</a> &mdash; Return a dot name string representation of a dictionary.</li>
<li> <a href="#newValueOr">newValueOr</a> &mdash; Create a new ValueOr containing a warning.</li>
<li> <a href="#newValueOr-1">newValueOr</a> &mdash; Create a new ValueOr containing a warning.</li>
<li> <a href="#newValueOr-2">newValueOr</a> &mdash; Create a new ValueOr containing a value.</li>
<li> <a href="#newFunResultWarn">newFunResultWarn</a> &mdash; Return a new FunResult object containing a warning.</li>
<li> <a href="#newFunResultWarn-1">newFunResultWarn</a> &mdash; Return a new FunResult object containing a warning created from a WarningData object.</li>
<li> <a href="#newFunResult">newFunResult</a> &mdash; Return a new FunResult object containing a value.</li>
<li> <a href="#a___-1">`==`</a> &mdash; Compare two FunResult objects and return true when equal.</li>
<li> <a href="#a___-2">`!=`</a> &mdash; Compare two FunResult objects and return false when equal.</li>
<li> <a href="#a__-4">`$`</a> &mdash; Return a string representation of a FunResult object.</li>
<li> <a href="#newValuePosSi">newValuePosSi</a> &mdash; Create a newValuePosSi object.</li>
<li> <a href="#newValuePosSiOr">newValuePosSiOr</a> &mdash; Create a ValuePosSiOr warning.</li>
<li> <a href="#newValuePosSiOr-1">newValuePosSiOr</a> &mdash; Create a ValuePosSiOr warning.</li>
<li> <a href="#a___-3">`==`</a> &mdash; Return true when a equals b.</li>
<li> <a href="#a___-4">`==`</a> &mdash; Return true when a equals b.</li>
<li> <a href="#a___-5">`!=`</a> &mdash; Compare two ValuePosSi objects and return false when equal.</li>
<li> <a href="#a___-6">`!=`</a> &mdash; Compare two ValuePosSiOr objects and return false when equal.</li>
<li> <a href="#newValuePosSiOr-2">newValuePosSiOr</a> &mdash; Create a ValuePosSiOr from a value, pos and exit.</li>
<li> <a href="#newValuePosSiOr-3">newValuePosSiOr</a> &mdash; Create a ValuePosSiOr value from a number or string.</li>
<li> <a href="#newValuePosSiOr-4">newValuePosSiOr</a> &mdash; Create a ValuePosSiOr from a ValuePosSi.</li>
<li> <a href="#codeToParamType">codeToParamType</a> &mdash; Convert a parameter code letter to a ParamType.</li>
<li> <a href="#strToParamType">strToParamType</a> &mdash; Return the parameter type for the given string, e.</li>
<li> <a href="#shortName">shortName</a> &mdash; Return a short name based on the given index value.</li>
<li> <a href="#newSignatureO">newSignatureO</a> &mdash; Return a new signature for the function name and signature code.</li>
</ul>

<h3 id="variableStartChars">variableStartChars</h3>

<pre class="description">
The characters that make up a variable dotname.  A variable starts with an ascii letter.
</pre>

<pre class="nim-code">
variableStartChars: set[char] =
</pre>

<h3 id="variableMiddleChars">variableMiddleChars</h3>

<pre class="description">
A variable contains ascii letters, digits, underscores and hypens.
</pre>

<pre class="nim-code">
variableMiddleChars: set[char] =
</pre>

<h3 id="variableChars">variableChars</h3>

<pre class="description">
A variable contains ascii letters, digits, underscores and hypens. Variables are connected with dots to make a dot name.
</pre>

<pre class="nim-code">
variableChars: set[char] =
</pre>

<h3 id="startTFVarNumber">startTFVarNumber</h3>

<pre class="description">
A character that starts true, false, a variable or a number.
</pre>

<pre class="nim-code">
startTFVarNumber: set[char] =
</pre>

<h3 id="VarsDict">VarsDict</h3>

<pre class="description">
This is a ref type. Create a new VarsDict with newVarsDict procedure.
</pre>

<pre class="nim-code">
VarsDict = OrderedTableRef[string, Value]
</pre>

<h3 id="Mutable">Mutable</h3>

<pre class="description">
The mutable state of lists and dictionaries.
* immutable -- you cannot change it
* append -- you can append to the end
* full -- you can change everything
</pre>

<pre class="nim-code">
Mutable
</pre>

<h3 id="DictType">DictType</h3>

<pre class="description">
The statictea dictionary type.

* dict -- an ordered dictionary.
* mutable -- whether you can append to the dictionary or not.
</pre>

<pre class="nim-code">
DictType = object
  dict*: VarsDict
  mutable*: Mutable

</pre>

<h3 id="ListType">ListType</h3>

<pre class="description">
The statictea list type.

* list -- a list of values.
* mutable -- whether you can append to the dictionary or not.
</pre>

<pre class="nim-code">
ListType = object
  list*: seq[Value]
  mutable*: Mutable

</pre>

<h3 id="Variables">Variables</h3>

<pre class="description">
Dictionary holding all statictea variables in multiple distinct logical dictionaries.
</pre>

<pre class="nim-code">
Variables = VarsDict
</pre>

<h3 id="VarsDictOr">VarsDictOr</h3>

<pre class="description">
A VarsDict object or a warning.
</pre>

<pre class="nim-code">
VarsDictOr = OpResultWarn[VarsDict]
</pre>

<h3 id="ValueKind">ValueKind</h3>

<pre class="description">
The statictea variable types.
* vkString -- string of UTF-8 characters
* vkInt -- 64 bit signed integer
* vkFloat -- 64 bit floating point number
* vkDict -- hash table mapping strings to any value
* vkList -- a list of values of any type
* vkBool -- true or false
* vkFunc -- reference to a function
</pre>

<pre class="nim-code">
ValueKind = enum
  vkString = "string", vkInt = "int", vkFloat = "float", vkDict = "dict",
  vkList = "list", vkBool = "bool", vkFunc = "func"
</pre>

<h3 id="Value">Value</h3>

<pre class="description">
A variable's value reference.
</pre>

<pre class="nim-code">
Value = ref ValueObj
</pre>

<h3 id="ValueOr">ValueOr</h3>

<pre class="description">
A Value object or a warning.
</pre>

<pre class="nim-code">
ValueOr = OpResultWarn[Value]
</pre>

<h3 id="Statement">Statement</h3>

<pre class="description">
Statement object stores the statement text, the line number and its line ending.

* text -- a line containing a statement without the line ending
* lineNum -- line number in the file where the statement starts (the first line is 1)
statement starts.
* ending -- the line ending, either linefeed (\n) or carriage return and linefeed (\r\n).
</pre>

<pre class="nim-code">
Statement = object
  text*: string
  lineNum*: Natural
  ending*: string

</pre>

<h3 id="FunctionPtr">FunctionPtr</h3>

<pre class="description">
Signature of a statictea built in function. It takes any number of values and returns a value or a warning message.
</pre>

<pre class="nim-code">
FunctionPtr = proc (variables: Variables; parameters: seq[Value]): FunResult
</pre>

<h3 id="ParamCode">ParamCode</h3>

<pre class="description">
Parameter type, one character of "ifsldpa" corresponding to int, float, string, list, dict, func, any.
</pre>

<pre class="nim-code">
ParamCode = char
</pre>

<h3 id="ParamType">ParamType</h3>

<pre class="description">
The statictea parameter types. The same as the variable types ValueKind with an extra for "any".
* ptString -- string parameter type
* ptInt -- integer
* ptFloat -- floating point number
* ptDict -- dictionary
* ptList -- list
* ptBool -- boolean
* ptFunc -- function pointer
* ptAny -- any parameter type
</pre>

<pre class="nim-code">
ParamType = enum
  ptString = "string", ptInt = "int", ptFloat = "float", ptDict = "dict",
  ptList = "list", ptBool = "bool", ptFunc = "func", ptAny = "any"
</pre>

<h3 id="Param">Param</h3>

<pre class="description">
Holds attributes for one parameter.
* name -- the parameter name
* paramType -- the parameter type
</pre>

<pre class="nim-code">
Param = object
  name*: string
  paramType*: ParamType

</pre>

<h3 id="Signature">Signature</h3>

<pre class="description">
Holds the function signature.
* optional -- true when the last parameter is optional
* name -- the function name
* params -- a list of the function parameter names and types
* returnType -- the function return type
</pre>

<pre class="nim-code">
Signature = object
  optional*: bool
  name*: string
  params*: seq[Param]
  returnType*: ParamType

</pre>

<h3 id="SignatureOr">SignatureOr</h3>

<pre class="description">
A signature or message.
</pre>

<pre class="nim-code">
SignatureOr = OpResultWarn[Signature]
</pre>

<h3 id="FunctionSpec">FunctionSpec</h3>

<pre class="description">
Holds the function details.

* builtIn -- true for the built-in functions, false for user functions
* signature -- the function signature
* docComment -- the function document comment
* filename -- the filename where the function is defined either the code file or functions.nim
* lineNum -- the line number where the function definition starts
* numLines -- the number of lines to define the function
* statements -- a list of the function statements for user functions
* functionPtr -- pointer to the function for built-in functions
</pre>

<pre class="nim-code">
FunctionSpec = object
  builtIn*: bool
  signature*: Signature
  docComment*: string
  filename*: string
  lineNum*: Natural
  numLines*: Natural
  statements*: seq[Statement]
  functionPtr*: FunctionPtr

</pre>

<h3 id="FunResultKind">FunResultKind</h3>

<pre class="description">
The kind of a FunResult object, either a value or warning.
* frValue -- a value
* frWarning -- a warning message
</pre>

<pre class="nim-code">
FunResultKind = enum
  frValue, frWarning
</pre>

<h3 id="FunResult">FunResult</h3>

<pre class="description">
Contains the result of calling a function, either a value or a warning.

The parameter field is the index of the problem argument or
-1 to point at the function itself.
</pre>

<pre class="nim-code">
FunResult = object
  case kind*: FunResultKind
  of frValue:
      value*: Value

  of frWarning:
      parameter*: int
      warningData*: WarningData


</pre>

<h3 id="SideEffect">SideEffect</h3>

<pre class="description">
The kind of side effect for a statement.

* seNone -- no side effect, the normal case
* seReturn -- the return function; stop the command and
either skip the replacement block or stop iterating
* seLogMessage -- the log function; write a message to the log file
* seIf2False -- the two parameter IF condition was false
</pre>

<pre class="nim-code">
SideEffect = enum
  seNone = "none", seReturn = "return", seLogMessage = "log",
  seIf2False = "if2False"
</pre>

<h3 id="ValuePosSi">ValuePosSi</h3>

<pre class="description">
A value and the position after the value in the statement along with the side effect, if any. The position includes the trailing whitespace.  For the example statement below, the value 567 starts at index 6 and ends at position 10.

~~~
0123456789 123456789
var = 567 # test
      ^ start
          ^ end position
~~~
</pre>

<pre class="nim-code">
ValuePosSi = object
  value*: Value
  pos*: Natural
  sideEffect*: SideEffect

</pre>

<h3 id="ValuePosSiOr">ValuePosSiOr</h3>

<pre class="description">
A ValuePosSi object or a warning.
</pre>

<pre class="nim-code">
ValuePosSiOr = OpResultWarn[ValuePosSi]
</pre>

<h3 id="newSignature">newSignature</h3>

<pre class="description">
Create a Signature object.
</pre>

<pre class="nim-code">
proc newSignature(optional: bool; name: string; params: seq[Param];
                  returnType: ParamType): Signature
</pre>

<h3 id="newSignatureOr">newSignatureOr</h3>

<pre class="description">
Create a new SignatureOr with a message.
</pre>

<pre class="nim-code">
func newSignatureOr(warning: MessageId; p1 = ""; pos = 0): SignatureOr
</pre>

<h3 id="newSignatureOr-1">newSignatureOr</h3>

<pre class="description">
Create a new SignatureOr with a message.
</pre>

<pre class="nim-code">
func newSignatureOr(warningData: WarningData): SignatureOr
</pre>

<h3 id="newSignatureOr-2">newSignatureOr</h3>

<pre class="description">
Create a new SignatureOr with a value.
</pre>

<pre class="nim-code">
func newSignatureOr(signature: Signature): SignatureOr
</pre>

<h3 id="newSignatureOr-3">newSignatureOr</h3>

<pre class="description">
Create a SignatureOr object.
</pre>

<pre class="nim-code">
proc newSignatureOr(optional: bool; name: string; params: seq[Param];
                    returnType: ParamType): SignatureOr
</pre>

<h3 id="newParam">newParam</h3>

<pre class="description">
Create a new Param object.
</pre>

<pre class="nim-code">
func newParam(name: string; paramType: ParamType): Param
</pre>

<h3 id="newVarsDict">newVarsDict</h3>

<pre class="description">
Create a new empty variables dictionary. VarsDict is a ref type.
</pre>

<pre class="nim-code">
proc newVarsDict(): VarsDict
</pre>

<h3 id="newVarsDictOr">newVarsDictOr</h3>

<pre class="description">
Return a new varsDictOr object containing a warning.
</pre>

<pre class="nim-code">
func newVarsDictOr(warning: MessageId; p1: string = ""; pos = 0): VarsDictOr
</pre>

<h3 id="newVarsDictOr-1">newVarsDictOr</h3>

<pre class="description">
Return a new VarsDict object containing a dictionary.
</pre>

<pre class="nim-code">
func newVarsDictOr(varsDict: VarsDict): VarsDictOr
</pre>

<h3 id="newDictType">newDictType</h3>

<pre class="description">

</pre>

<pre class="nim-code">
func newDictType(varsDict: VarsDict; mutable = Mutable.immutable): DictType
</pre>

<h3 id="newListType">newListType</h3>

<pre class="description">

</pre>

<pre class="nim-code">
func newListType(valueList: seq[Value]; mutable = Mutable.immutable): ListType
</pre>

<h3 id="newValue">newValue</h3>

<pre class="description">
Create a string value.
</pre>

<pre class="nim-code">
proc newValue(str: string): Value
</pre>

<h3 id="newValue-1">newValue</h3>

<pre class="description">
Create an integer value.
</pre>

<pre class="nim-code">
proc newValue(num: int | int64): Value
</pre>

<h3 id="newValue-2">newValue</h3>

<pre class="description">
Create a bool value.
</pre>

<pre class="nim-code">
proc newValue(a: bool): Value
</pre>

<h3 id="newValue-3">newValue</h3>

<pre class="description">
Create a float value.
</pre>

<pre class="nim-code">
proc newValue(num: float): Value
</pre>

<h3 id="newValue-4">newValue</h3>

<pre class="description">
Create a list value.
</pre>

<pre class="nim-code">
proc newValue(valueList: seq[Value]; mutable = Mutable.immutable): Value
</pre>

<h3 id="newValue-5">newValue</h3>

<pre class="description">
Create a dictionary value from a VarsDict.
</pre>

<pre class="nim-code">
proc newValue(varsDict: VarsDict; mutable = Mutable.immutable): Value
</pre>

<h3 id="newValue-6">newValue</h3>

<pre class="description">
New value from an existing value. Since values are ref types, the
new value is an alias to the same value.
</pre>

<pre class="nim-code">
proc newValue(value: Value): Value
</pre>

<h3 id="newValue-7">newValue</h3>

<pre class="description">
New list value from an array of items of the same kind.

~~~
let listValue = newValue([1, 2, 3])
let listValue = newValue(["a", "b", "c"])
let listValue = newValue([newValue(1), newValue("b")])
~~~
</pre>

<pre class="nim-code">
proc newValue[T](list: openArray[T]; mutable = Mutable.immutable): Value
</pre>

<h3 id="newValue-8">newValue</h3>

<pre class="description">
New dict value from an array of pairs where the pairs are the
same type which may be Value type.

~~~
 let dictValue = newValue([("a", 1), ("b", 2), ("c", 3)])
 let dictValue = newValue([("a", 1.1), ("b", 2.2), ("c", 3.3)])
 let dictValue = newValue([("a", newValue(1.1)), ("b", newValue("a"))])
~~~
</pre>

<pre class="nim-code">
proc newValue[T](dictPairs: openArray[(string, T)]; mutable = Mutable.immutable): Value
</pre>

<h3 id="newFunc">newFunc</h3>

<pre class="description">
Create a new func which is a FunctionSpec.
</pre>

<pre class="nim-code">
func newFunc(builtIn: bool; signature: Signature; docComment: string;
             filename: string; lineNum: Natural; numLines: Natural;
             statements: seq[Statement]; functionPtr: FunctionPtr): FunctionSpec
</pre>

<h3 id="newValue-9">newValue</h3>

<pre class="description">
Create a new func value.
</pre>

<pre class="nim-code">
func newValue(function: FunctionSpec): Value
</pre>

<h3 id="newEmptyListValue">newEmptyListValue</h3>

<pre class="description">
Return an empty list value.
</pre>

<pre class="nim-code">
proc newEmptyListValue(mutable = Mutable.immutable): Value
</pre>

<h3 id="newEmptyDictValue">newEmptyDictValue</h3>

<pre class="description">
Create a dictionary value from a VarsDict.
</pre>

<pre class="nim-code">
proc newEmptyDictValue(mutable = Mutable.immutable): Value
</pre>

<h3 id="a___">`==`</h3>

<pre class="description">
Return true when two variables are equal.
</pre>

<pre class="nim-code">
proc `==`(a: Value; b: Value): bool
</pre>

<h3 id="newStatement">newStatement</h3>

<pre class="description">
Create a new statement.
</pre>

<pre class="nim-code">
func newStatement(text: string; lineNum: Natural = 1; ending = "\n"): Statement
</pre>

<h3 id="a__">`$`</h3>

<pre class="description">
Return a string representation of a signature.
</pre>

<pre class="nim-code">
func `$`(signature: Signature): string
</pre>

<h3 id="a__-1">`$`</h3>

<pre class="description">
Return a string representation of a function.
</pre>

<pre class="nim-code">
func `$`(function: FunctionSpec): string
</pre>

<h3 id="jsonStringRepr">jsonStringRepr</h3>

<pre class="description">
Return the JSON string representation. It is assumed the string is a valid UTF-8 encoded string.
</pre>

<pre class="nim-code">
proc jsonStringRepr(str: string): string
</pre>

<h3 id="dictToString">dictToString</h3>

<pre class="description">
Return a string representation of a dict Value in JSON format.
</pre>

<pre class="nim-code">
func dictToString(value: Value): string
</pre>

<h3 id="listToString">listToString</h3>

<pre class="description">
Return a string representation of a list variable in JSON format.
</pre>

<pre class="nim-code">
func listToString(value: Value): string
</pre>

<h3 id="valueToString">valueToString</h3>

<pre class="description">
Return a string representation of a variable in JSON format.
</pre>

<pre class="nim-code">
func valueToString(value: Value): string
</pre>

<h3 id="valueToStringRB">valueToStringRB</h3>

<pre class="description">
Return the string representation of the variable for use in the replacement blocks.
</pre>

<pre class="nim-code">
func valueToStringRB(value: Value): string
</pre>

<h3 id="a__-2">`$`</h3>

<pre class="description">
Return a string representation of a Value.
</pre>

<pre class="nim-code">
func `$`(value: Value): string
</pre>

<h3 id="a__-3">`$`</h3>

<pre class="description">
Return a string representation of a VarsDict.
</pre>

<pre class="nim-code">
proc `$`(varsDict: VarsDict): string
</pre>

<h3 id="dotNameRep">dotNameRep</h3>

<pre class="description">
Return a dot name string representation of a dictionary. The top variables tells whether the dict is the variables dictionary.
</pre>

<pre class="nim-code">
func dotNameRep(dict: VarsDict; leftSide: string = ""; top = false): string
</pre>

<h3 id="newValueOr">newValueOr</h3>

<pre class="description">
Create a new ValueOr containing a warning.
</pre>

<pre class="nim-code">
func newValueOr(warning: MessageId; p1 = ""; pos = 0): ValueOr
</pre>

<h3 id="newValueOr-1">newValueOr</h3>

<pre class="description">
Create a new ValueOr containing a warning.
</pre>

<pre class="nim-code">
func newValueOr(warningData: WarningData): ValueOr
</pre>

<h3 id="newValueOr-2">newValueOr</h3>

<pre class="description">
Create a new ValueOr containing a value.
</pre>

<pre class="nim-code">
func newValueOr(value: Value): ValueOr
</pre>

<h3 id="newFunResultWarn">newFunResultWarn</h3>

<pre class="description">
Return a new FunResult object containing a warning. It takes a message id, the index of the problem parameter, and the optional string that goes with the warning.
</pre>

<pre class="nim-code">
func newFunResultWarn(warning: MessageId; parameter: int = 0; p1: string = "";
                      pos = 0): FunResult
</pre>

<h3 id="newFunResultWarn-1">newFunResultWarn</h3>

<pre class="description">
Return a new FunResult object containing a warning created from a WarningData object.
</pre>

<pre class="nim-code">
func newFunResultWarn(warningData: WarningData; parameter: int = 0): FunResult
</pre>

<h3 id="newFunResult">newFunResult</h3>

<pre class="description">
Return a new FunResult object containing a value.
</pre>

<pre class="nim-code">
func newFunResult(value: Value): FunResult
</pre>

<h3 id="a___-1">`==`</h3>

<pre class="description">
Compare two FunResult objects and return true when equal.
</pre>

<pre class="nim-code">
func `==`(r1: FunResult; r2: FunResult): bool
</pre>

<h3 id="a___-2">`!=`</h3>

<pre class="description">
Compare two FunResult objects and return false when equal.
</pre>

<pre class="nim-code">
proc `!=`(a: FunResult; b: FunResult): bool
</pre>

<h3 id="a__-4">`$`</h3>

<pre class="description">
Return a string representation of a FunResult object.
</pre>

<pre class="nim-code">
func `$`(funResult: FunResult): string
</pre>

<h3 id="newValuePosSi">newValuePosSi</h3>

<pre class="description">
Create a newValuePosSi object.
</pre>

<pre class="nim-code">
proc newValuePosSi(value: Value; pos: Natural; sideEffect: SideEffect = seNone): ValuePosSi
</pre>

<h3 id="newValuePosSiOr">newValuePosSiOr</h3>

<pre class="description">
Create a ValuePosSiOr warning.
</pre>

<pre class="nim-code">
func newValuePosSiOr(warning: MessageId; p1 = ""; pos = 0): ValuePosSiOr
</pre>

<h3 id="newValuePosSiOr-1">newValuePosSiOr</h3>

<pre class="description">
Create a ValuePosSiOr warning.
</pre>

<pre class="nim-code">
func newValuePosSiOr(warningData: WarningData): ValuePosSiOr
</pre>

<h3 id="a___-3">`==`</h3>

<pre class="description">
Return true when a equals b.
</pre>

<pre class="nim-code">
proc `==`(a: ValuePosSi; b: ValuePosSi): bool
</pre>

<h3 id="a___-4">`==`</h3>

<pre class="description">
Return true when a equals b.
</pre>

<pre class="nim-code">
proc `==`(a: ValuePosSiOr; b: ValuePosSiOr): bool
</pre>

<h3 id="a___-5">`!=`</h3>

<pre class="description">
Compare two ValuePosSi objects and return false when equal.
</pre>

<pre class="nim-code">
proc `!=`(a: ValuePosSi; b: ValuePosSi): bool
</pre>

<h3 id="a___-6">`!=`</h3>

<pre class="description">
Compare two ValuePosSiOr objects and return false when equal.
</pre>

<pre class="nim-code">
proc `!=`(a: ValuePosSiOr; b: ValuePosSiOr): bool
</pre>

<h3 id="newValuePosSiOr-2">newValuePosSiOr</h3>

<pre class="description">
Create a ValuePosSiOr from a value, pos and exit.
</pre>

<pre class="nim-code">
func newValuePosSiOr(value: Value; pos: Natural; sideEffect: SideEffect = seNone): ValuePosSiOr
</pre>

<h3 id="newValuePosSiOr-3">newValuePosSiOr</h3>

<pre class="description">
Create a ValuePosSiOr value from a number or string.
</pre>

<pre class="nim-code">
proc newValuePosSiOr(number: int | int64 | float64 | string; pos: Natural): ValuePosSiOr
</pre>

<h3 id="newValuePosSiOr-4">newValuePosSiOr</h3>

<pre class="description">
Create a ValuePosSiOr from a ValuePosSi.
</pre>

<pre class="nim-code">
func newValuePosSiOr(val: ValuePosSi): ValuePosSiOr
</pre>

<h3 id="codeToParamType">codeToParamType</h3>

<pre class="description">
Convert a parameter code letter to a ParamType.
</pre>

<pre class="nim-code">
func codeToParamType(code: ParamCode): ParamType
</pre>

<h3 id="strToParamType">strToParamType</h3>

<pre class="description">
Return the parameter type for the given string, e.g. "int" to ptInt.
</pre>

<pre class="nim-code">
func strToParamType(str: string): ParamType
</pre>

<h3 id="shortName">shortName</h3>

<pre class="description">
Return a short name based on the given index value. Return a for 0, b for 1, etc.  It returns names a, b, c, ..., z then repeats a0, b0, c0,....
</pre>

<pre class="nim-code">
proc shortName(index: Natural): string
</pre>

<h3 id="newSignatureO">newSignatureO</h3>

<pre class="description">
Return a new signature for the function name and signature code. The parameter names come from the shortName function for letters a through z in order. The last letter in the code is the function's return type.

Example:

~~~
var signatureO = newSignatureO("myname", "ifss")
echo $signatureO.get()
=>
myname(a: int, b: float, c: string) string
~~~
</pre>

<pre class="nim-code">
func newSignatureO(functionName: string; signatureCode: string): Option[
    Signature]
</pre>


<p>⦿ This page was generated
by <a href="https://github.com/flenniken/statictea/">statictea</a>
from nim doc comments. ⦿</p>

</body>
</html>
