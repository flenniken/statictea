<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>functions.nim</title>
<style>
body {
    max-width: 40em;
    font-size: 2em;
    margin-left: 1em;
}

#staticteadep {
    width: 100%;
}

.signature {
    color: green;
}

.description {
    white-space: pre-wrap;
}

.nim-code {
    border-left: 6px solid green;
    padding: 16px;
    background-color: #f6f8fa;
    overflow: auto;
}
</style>
</head>
<body>
<h1>functions.nim</h1>

<pre class="description">
This module contains the StaticTea functions and supporting types. The StaticTea language functions start with "fun", for example, the "fun_cmp_ffi" function implements on of the StaticTea "cmp" functions.
</pre>

Nim source code: <a href="../../src/functions.nim">functions.nim</a>

<h1>Index</h1>

<ul>
<li>type:  <a href="#StringOr">StringOr</a> &mdash; StringOr holds a string or a warning.</li>
<li>type:  <a href="#PathComponents">PathComponents</a> &mdash; PathComponents holds the components of the file path components.</li>
<li> <a href="#newStringOr">newStringOr</a> &mdash; Create a new StringOr object containing a warning.</li>
<li> <a href="#newStringOr-1">newStringOr</a> &mdash; Create a new StringOr object containing a warning.</li>
<li> <a href="#newStringOr-2">newStringOr</a> &mdash; Create a new StringOr object containing a string.</li>
<li> <a href="#newPathComponents">newPathComponents</a> &mdash; Create a new PathComponents object from its pieces.</li>
<li> <a href="#signatureDetails">signatureDetails</a> &mdash; Convert the signature object to a dictionary value.</li>
<li> <a href="#functionDetails">functionDetails</a> &mdash; Convert the function spec to a dictionary value.</li>
<li> <a href="#cmpBaseValues">cmpBaseValues</a> &mdash; Compares two values a and b.</li>
<li> <a href="#parseNumber">parseNumber</a> &mdash; Return the literal number value and position after it.</li>
<li> <a href="#formatString">formatString</a> &mdash; Format a string by filling in the variable placeholders with their values.</li>
<li> <a href="#fun_cmp_iii">fun_cmp_iii</a> &mdash; Compare two ints.</li>
<li> <a href="#fun_cmp_ffi">fun_cmp_ffi</a> &mdash; Compare two floats.</li>
<li> <a href="#fun_cmp_ssobi">fun_cmp_ssobi</a> &mdash; Compare two strings.</li>
<li> <a href="#fun_concat_sss">fun_concat_sss</a> &mdash; Concatenate two strings.</li>
<li> <a href="#fun_len_si">fun_len_si</a> &mdash; Number of unicode characters in a string.</li>
<li> <a href="#fun_len_li">fun_len_li</a> &mdash; Number of elements in a list.</li>
<li> <a href="#fun_len_di">fun_len_di</a> &mdash; Number of elements in a dictionary.</li>
<li> <a href="#fun_get_lioaa">fun_get_lioaa</a> &mdash; Get a list value by its index.</li>
<li> <a href="#fun_get_dsoaa">fun_get_dsoaa</a> &mdash; Get a dictionary value by its key.</li>
<li> <a href="#fun_if0_iaoaa">fun_if0_iaoaa</a> &mdash; If the condition is 0, return the second argument, else return the third argument.</li>
<li> <a href="#fun_if_baoaa">fun_if_baoaa</a> &mdash; If the condition is true, return the second argument, else return the third argument.</li>
<li> <a href="#fun_add_iii">fun_add_iii</a> &mdash; Add two integers.</li>
<li> <a href="#fun_add_fff">fun_add_fff</a> &mdash; Add two floats.</li>
<li> <a href="#fun_sub_iii">fun_sub_iii</a> &mdash; Subtract two integers.</li>
<li> <a href="#fun_sub_fff">fun_sub_fff</a> &mdash; Subtract two floats.</li>
<li> <a href="#fun_exists_dsb">fun_exists_dsb</a> &mdash; Determine whether a key exists in a dictionary.</li>
<li> <a href="#fun_case_iloaa">fun_case_iloaa</a> &mdash; Compare integer cases and return the matching value.</li>
<li> <a href="#fun_case_sloaa">fun_case_sloaa</a> &mdash; Compare string cases and return the matching value.</li>
<li> <a href="#parseVersion">parseVersion</a> &mdash; Parse a StaticTea version number and return its three components.</li>
<li> <a href="#fun_cmpVersion_ssi">fun_cmpVersion_ssi</a> &mdash; Compare two StaticTea version numbers.</li>
<li> <a href="#fun_float_if">fun_float_if</a> &mdash; Create a float from an int.</li>
<li> <a href="#fun_float_sf">fun_float_sf</a> &mdash; Create a float from a number string.</li>
<li> <a href="#fun_float_saa">fun_float_saa</a> &mdash; Create a float from a number string.</li>
<li> <a href="#fun_int_fosi">fun_int_fosi</a> &mdash; Create an int from a float.</li>
<li> <a href="#fun_int_sosi">fun_int_sosi</a> &mdash; Create an int from a number string.</li>
<li> <a href="#fun_int_ssaa">fun_int_ssaa</a> &mdash; Create an int from a number string.</li>
<li> <a href="#if0Condition">if0Condition</a> &mdash; Convert the value to a boolean.</li>
<li> <a href="#fun_bool_ab">fun_bool_ab</a> &mdash; Create an bool from a value.</li>
<li> <a href="#fun_find_ssoaa">fun_find_ssoaa</a> &mdash; Find the position of a substring in a string.</li>
<li> <a href="#fun_slice_siois">fun_slice_siois</a> &mdash; Extract a substring from a string by its position and length.</li>
<li> <a href="#fun_dup_sis">fun_dup_sis</a> &mdash; Duplicate a string x times.</li>
<li> <a href="#fun_dict_old">fun_dict_old</a> &mdash; Create a dictionary from a list of key, value pairs.</li>
<li> <a href="#fun_list_al">fun_list_al</a> &mdash; Create a list of variables.</li>
<li> <a href="#fun_listLoop_lapoab">fun_listLoop_lapoab</a> &mdash; Loop over items in a list and fill in a container.</li>
<li> <a href="#fun_replace_siiss">fun_replace_siiss</a> &mdash; Replace a substring specified by its position and length with another string.</li>
<li> <a href="#fun_replaceRe_sls">fun_replaceRe_sls</a> &mdash; Replace multiple parts of a string using regular expressions.</li>
<li> <a href="#parsePath">parsePath</a> &mdash; Parse the given file path into its component pieces.</li>
<li> <a href="#fun_path_sosd">fun_path_sosd</a> &mdash; Split a file path into its component pieces.</li>
<li> <a href="#fun_lower_ss">fun_lower_ss</a> &mdash; Lowercase a string.</li>
<li> <a href="#fun_keys_dl">fun_keys_dl</a> &mdash; Create a list from the keys in a dictionary.</li>
<li> <a href="#fun_values_dl">fun_values_dl</a> &mdash; Create a list out of the values in the specified dictionary.</li>
<li> <a href="#fun_sort_lsosl">fun_sort_lsosl</a> &mdash; Sort a list of values of the same type.</li>
<li> <a href="#fun_sort_lssil">fun_sort_lssil</a> &mdash; Sort a list of lists.</li>
<li> <a href="#fun_sort_lsssl">fun_sort_lsssl</a> &mdash; Sort a list of dictionaries.</li>
<li> <a href="#fun_anchors_lsl">fun_anchors_lsl</a> &mdash; Create anchor names from heading names.</li>
<li> <a href="#fun_type_as">fun_type_as</a> &mdash; Return the argument type, one of: int, float, string, list, dict, bool or func.</li>
<li> <a href="#fun_joinPath_loss">fun_joinPath_loss</a> &mdash; Join the path components with a path separator.</li>
<li> <a href="#fun_join_lsois">fun_join_lsois</a> &mdash; Join a list of strings with a separator.</li>
<li> <a href="#fun_warn_ss">fun_warn_ss</a> &mdash; Return a warning message and skip the current statement.</li>
<li> <a href="#fun_log_ss">fun_log_ss</a> &mdash; Log a message to the log file.</li>
<li> <a href="#fun_return_aa">fun_return_aa</a> &mdash; Return is a special function that returns the value passed in and has has side effects.</li>
<li> <a href="#fun_string_aoss">fun_string_aoss</a> &mdash; Convert a variable to a string.</li>
<li> <a href="#fun_string_sds">fun_string_sds</a> &mdash; Convert the dictionary variable to dot names.</li>
<li> <a href="#fun_format_ss">fun_format_ss</a> &mdash; Format a string using replacement variables similar to a replacement block.</li>
<li> <a href="#fun_func_sp">fun_func_sp</a> &mdash; Define a function.</li>
<li> <a href="#fun_functionDetails_pd">fun_functionDetails_pd</a> &mdash; Return the function details in a dictionary.</li>
<li> <a href="#fun_startsWith_ssb">fun_startsWith_ssb</a> &mdash; Check whether a strings starts with the given prefix.</li>
<li> <a href="#fun_not_bb">fun_not_bb</a> &mdash; Boolean not.</li>
<li> <a href="#fun_and_bbb">fun_and_bbb</a> &mdash; Boolean AND with short circuit.</li>
<li> <a href="#fun_or_bbb">fun_or_bbb</a> &mdash; Boolean OR with short circuit.</li>
<li> <a href="#fun_eq_iib">fun_eq_iib</a> &mdash; Return true when the two ints are equal.</li>
<li> <a href="#fun_eq_ffb">fun_eq_ffb</a> &mdash; Return true when two floats are equal.</li>
<li> <a href="#fun_eq_ssb">fun_eq_ssb</a> &mdash; Return true when two strings are equal.</li>
<li> <a href="#fun_ne_iib">fun_ne_iib</a> &mdash; Return true when two ints are not equal.</li>
<li> <a href="#fun_ne_ffb">fun_ne_ffb</a> &mdash; Return true when two floats are not equal.</li>
<li> <a href="#fun_ne_ssb">fun_ne_ssb</a> &mdash; Return true when two strings are not equal.</li>
<li> <a href="#fun_gt_iib">fun_gt_iib</a> &mdash; Return true when an int is greater then another int.</li>
<li> <a href="#fun_gt_ffb">fun_gt_ffb</a> &mdash; Return true when one float is greater than another float.</li>
<li> <a href="#fun_gte_iib">fun_gte_iib</a> &mdash; Return true when an int is greater then or equal to another int.</li>
<li> <a href="#fun_gte_ffb">fun_gte_ffb</a> &mdash; Return true when a float is greater than or equal to another float.</li>
<li> <a href="#fun_lt_iib">fun_lt_iib</a> &mdash; Return true when an int is less than another int.</li>
<li> <a href="#fun_lt_ffb">fun_lt_ffb</a> &mdash; Return true when a float is less then another float.</li>
<li> <a href="#fun_lte_iib">fun_lte_iib</a> &mdash; Return true when an int is less than or equal to another int.</li>
<li> <a href="#fun_lte_ffb">fun_lte_ffb</a> &mdash; Return true when a float is less than or equal to another float.</li>
<li> <a href="#fun_readJson_sa">fun_readJson_sa</a> &mdash; Convert a JSON string to a variable.</li>
<li> <a href="#fun_markdownLite_sl">fun_markdownLite_sl</a> &mdash; Parse a simple subset of markdown which contains paragraphs, bullets and code blocks.</li>
<li> <a href="#functionsDict">functionsDict</a> &mdash; Maps a built-in function name to a function pointer you can call.</li>
<li>type:  <a href="#BuiltInInfo">BuiltInInfo</a> &mdash; The built-in function information.</li>
<li> <a href="#newBuiltInInfo">newBuiltInInfo</a> &mdash; Return a BuiltInInfo object.</li>
<li> <a href="#getBestFunction">getBestFunction</a> &mdash; Given a function variable or a list of function variables and a list of arguments, return the one that best matches the arguments.</li>
<li> <a href="#splitFuncName">splitFuncName</a> &mdash; Split a funcName like "fun_cmp_ffi" to its name and signature like: "cmp" and "ffi".</li>
<li> <a href="#makeFuncDictionary">makeFuncDictionary</a> &mdash; Create the f dictionary from the built in functions.</li>
<li> <a href="#funcsVarDict">funcsVarDict</a> &mdash; The f dictionary of built-in functions.</li>
</ul>

<h3 id="StringOr">StringOr</h3>

<pre class="description">
StringOr holds a string or a warning.
</pre>

<pre class="nim-code">
StringOr = OpResultWarn[string]
</pre>

<h3 id="PathComponents">PathComponents</h3>

<pre class="description">
PathComponents holds the components of the file path components.
</pre>

<pre class="nim-code">
PathComponents = object
  dir: string
  filename: string
  basename: string
  ext: string

</pre>

<h3 id="newStringOr">newStringOr</h3>

<pre class="description">
Create a new StringOr object containing a warning.
</pre>

<pre class="nim-code">
func newStringOr(warning: MessageId; p1: string = ""; pos = 0): StringOr
</pre>

<h3 id="newStringOr-1">newStringOr</h3>

<pre class="description">
Create a new StringOr object containing a warning.
</pre>

<pre class="nim-code">
func newStringOr(warningData: WarningData): StringOr
</pre>

<h3 id="newStringOr-2">newStringOr</h3>

<pre class="description">
Create a new StringOr object containing a string.
</pre>

<pre class="nim-code">
func newStringOr(str: string): StringOr
</pre>

<h3 id="newPathComponents">newPathComponents</h3>

<pre class="description">
Create a new PathComponents object from its pieces.
</pre>

<pre class="nim-code">
func newPathComponents(dir, filename, basename, ext: string): PathComponents
</pre>

<h3 id="signatureDetails">signatureDetails</h3>

<pre class="description">
Convert the signature object to a dictionary value.
</pre>

<pre class="nim-code">
func signatureDetails(signature: Signature): Value
</pre>

<h3 id="functionDetails">functionDetails</h3>

<pre class="description">
Convert the function spec to a dictionary value.
</pre>

<pre class="nim-code">
func functionDetails(fs: FunctionSpec): Value
</pre>

<h3 id="cmpBaseValues">cmpBaseValues</h3>

<pre class="description">
Compares two values a and b.  When a equals b return 0, when a is greater than b return 1 and when a is less than b return -1. The values must be the same kind and either int, float or string.
</pre>

<pre class="nim-code">
func cmpBaseValues(a, b: Value; insensitive: bool = false): int
</pre>

<h3 id="parseNumber">parseNumber</h3>

<pre class="description">
Return the literal number value and position after it.  The start index points at a digit or minus sign. The position includes the trailing whitespace.
</pre>

<pre class="nim-code">
func parseNumber(line: string; start: Natural): ValuePosSiOr
</pre>

<h3 id="formatString">formatString</h3>

<pre class="description">
Format a string by filling in the variable placeholders with their values. Generate a warning when the variable doesn't exist. No space around the bracketed variables.

~~~
let first = "Earl"
let last = "Grey"
"name: {first} {last}" => "name: Earl Grey"
~~~

To enter a left bracket use two in a row.

~~~
"{{" => "{"
~~~
</pre>

<pre class="nim-code">
proc formatString(variables: Variables; text: string): StringOr
</pre>

<h3 id="fun_cmp_iii">fun_cmp_iii</h3>

<pre class="description">
Compare two ints. Returns -1 for less, 0 for equal and 1 for greater than.

~~~
cmp(a: int, b: int) int
~~~

Examples:

~~~
cmp(7, 9) => -1
cmp(8, 8) => 0
cmp(9, 2) => 1
~~~
</pre>

<pre class="nim-code">
func fun_cmp_iii(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_cmp_ffi">fun_cmp_ffi</h3>

<pre class="description">
Compare two floats. Returns -1 for less, 0 for equal and 1 for greater than.

~~~
cmp(a: float, b: float) int
~~~

Examples:

~~~
cmp(7.8, 9.1) => -1
cmp(8.4, 8.4) => 0
cmp(9.3, 2.2) => 1
~~~
</pre>

<pre class="nim-code">
func fun_cmp_ffi(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_cmp_ssobi">fun_cmp_ssobi</h3>

<pre class="description">
Compare two strings. Returns -1 for less, 0 for equal and 1 for greater than.

You have the option to compare case insensitive. Case sensitive
is the default.

~~~
cmp(a: string, b: string, insensitive: optional bool) int
~~~

Examples:

~~~
cmp("coffee", "tea") => -1
cmp("tea", "tea") => 0
cmp("Tea", "tea") => 1
cmp("Tea", "tea", true) => 1
cmp("Tea", "tea", false) => 0
~~~
</pre>

<pre class="nim-code">
func fun_cmp_ssobi(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_concat_sss">fun_concat_sss</h3>

<pre class="description">
Concatenate two strings. See the join function for more that two arguments.

~~~
concat(a: string, b: string) string
~~~

Examples:

~~~
concat("tea", " time") => "tea time"
concat("a", "b") => "ab"
~~~
</pre>

<pre class="nim-code">
func fun_concat_sss(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_len_si">fun_len_si</h3>

<pre class="description">
Number of unicode characters in a string.

~~~
len(str: string) int
~~~

Examples:

~~~
len("tea") => 3
len("añyóng") => 6
~~~
</pre>

<pre class="nim-code">
func fun_len_si(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_len_li">fun_len_li</h3>

<pre class="description">
Number of elements in a list.

~~~
len(list: list) int
~~~

Examples:

~~~
len(list()) => 0
len(list(1)) => 1
len(list(4, 5)) => 2
~~~
</pre>

<pre class="nim-code">
func fun_len_li(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_len_di">fun_len_di</h3>

<pre class="description">
Number of elements in a dictionary.

~~~
len(dictionary: dict) int
~~~

Examples:

~~~
len(dict()) => 0
len(dict("a", 4)) => 1
len(dict("a", 4, "b", 3)) => 2
~~~
</pre>

<pre class="nim-code">
func fun_len_di(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_get_lioaa">fun_get_lioaa</h3>

<pre class="description">
Get a list value by its index.  If the index is invalid, the default value is returned when specified, else a warning is generated. You can use negative index values. Index -1 gets the last element. It is short hand for len - 1. Index -2 is len - 2, etc.

~~~
get(list: list, index: int, default: optional any) any
~~~

Examples:

~~~
list = list(4, "a", 10)
get(list, 0) => 4
get(list, 1) => "a"
get(list, 2) => 10
get(list, 3, 99) => 99
get(list, -1) => 10
get(list, -2) => "a"
get(list, -3) => 4
get(list, -4, 11) => 11
~~~

You can also use bracket notation to access list items.

~~~
a = teas[0]
~~~
</pre>

<pre class="nim-code">
func fun_get_lioaa(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_get_dsoaa">fun_get_dsoaa</h3>

<pre class="description">
Get a dictionary value by its key.  If the key doesn't exist, the default value is returned if specified, else a warning is generated.

~~~
get(dictionary: dict, key: string, default: optional any) any
~~~

Note: For dictionary lookup you can use dot notation. It's the
same as get without the default.

Examples:

~~~
d = dict("tea", "Earl Grey")
get(d, "tea") => "Earl Grey"
get(d, "coffee", "Tea") => "Tea"
~~~

Using dot notation:
~~~
d = dict("tea", "Earl Grey")
d.tea => "Earl Grey"
~~~
</pre>

<pre class="nim-code">
func fun_get_dsoaa(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_if0_iaoaa">fun_if0_iaoaa</h3>

<pre class="description">
If the condition is 0, return the second argument, else return the third argument.  You can use any type for the condition.  The condition is 0 for strings, lists and dictionaries when their length is 0.

The condition types and what is considered 0:

* bool -- false
* int -- 0
* float -- 0.0
* string -- when the length of the string is 0
* list -- when the length of the list is 0
* dict -- when the length of the dictionary is 0
* func -- always 0

The IF functions are special in a couple of ways, see
the If Functions section.

~~~
if0(condition: any, then: any, else: optional any) any
~~~

Examples:

~~~
a = if0(0, "tea", "beer") => tea
a = if0(1, "tea", "beer") => beer
a = if0(4, "tea", "beer") => beer
a = if0("", "tea", "beer") => tea
a = if0("abc", "tea", "beer") => beer
a = if0([], "tea", "beer") => tea
a = if0([1,2], "tea", "beer") => beer
a = if0(dict(), "tea", "beer") => tea
a = if0(dict("a",1), "tea", "beer") => beer
a = if0(false, "tea", "beer") => tea
a = if0(true, "tea", "beer") => beer

a = if0(true, "tea")
a = if0(false, "tea")
~~~

You don't have to assign the result of an if0 function which is
useful when using a warn or return function for its side effects.
The if takes two arguments when there is no assignment.

~~~
if0(c, warn("got zero value"))
~~~
</pre>

<pre class="nim-code">
func fun_if0_iaoaa(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_if_baoaa">fun_if_baoaa</h3>

<pre class="description">
If the condition is true, return the second argument, else return the third argument.

The IF functions are special in a couple of ways, see
the If Functions section.  You usually use boolean infix
expressions for the condition, see:
the Boolean Expressions section.

~~~
if(condition: bool, then: any, else: optional any) any
~~~

Examples:

~~~
a = if(true, "tea", "beer") # => tea
b = if(false, "tea", "beer") # => beer
c = if((v < 5), "tea", "beer")
d = if((v < 5), "tea")
~~~

You don't have to assign the result of an if function which is
useful when using a warn or return function for its side effects.
The if takes two arguments when there is no assignment.

~~~
if(c, warn("c is true"))
if(c, return("skip"))
~~~
</pre>

<pre class="nim-code">
func fun_if_baoaa(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_add_iii">fun_add_iii</h3>

<pre class="description">
Add two integers. A warning is generated on overflow.

~~~
add(a: int, b: int) int
~~~

Examples:

~~~
add(1, 2) => 3
add(3, -2) => 1
add(-2, -5) => -7
~~~
</pre>

<pre class="nim-code">
func fun_add_iii(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_add_fff">fun_add_fff</h3>

<pre class="description">
Add two floats. A warning is generated on overflow.

~~~
add(a: float, b: float) float
~~~

Examples:

~~~
add(1.5, 2.3) => 3.8
add(3.2, -2.2) => 1.0
~~~
</pre>

<pre class="nim-code">
func fun_add_fff(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_sub_iii">fun_sub_iii</h3>

<pre class="description">
Subtract two integers. A warning is generated on overflow.

~~~
sub(a: int, b: int) int
~~~

Examples:

~~~
sub(3, 1) => 2
add(3, -2) => 5
add(1, 5) => -4
~~~
</pre>

<pre class="nim-code">
func fun_sub_iii(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_sub_fff">fun_sub_fff</h3>

<pre class="description">
Subtract two floats. A warning is generated on overflow.

~~~
sub(a: float, b: float) float
~~~

Examples:

~~~
sub(4.5, 2.3) => 2.2
sub(1.0, 2.2) => -1.2
~~~
</pre>

<pre class="nim-code">
func fun_sub_fff(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_exists_dsb">fun_exists_dsb</h3>

<pre class="description">
Determine whether a key exists in a dictionary. Return true when it exists, else false.

~~~
exists(dictionary: dict, key: string) bool
~~~

Examples:

~~~
d = dict("tea", "Earl")
exists(d, "tea") => true
exists(d, "coffee") => false
~~~
</pre>

<pre class="nim-code">
func fun_exists_dsb(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_case_iloaa">fun_case_iloaa</h3>

<pre class="description">
Compare integer cases and return the matching value.  It takes a main integer condition, a list of case pairs and an optional value when none of the cases match.

The first element of a case pair is the condition and the
second is the return value when that condition matches the main
condition. The function compares the conditions left to right and
returns the first match.

When none of the cases match the main condition, the default
value is returned if it is specified, otherwise a warning is
generated.  The conditions must be integers. The return values
can be any type.

~~~
case(condition: int, pairs: list, default: optional any) any
~~~

Examples:

~~~
cases = list(0, "tea", 1, "water", 2, "beer")
case(0, cases) => "tea"
case(1, cases) => "water"
case(2, cases) => "beer"
case(2, cases, "wine") => "beer"
case(3, cases, "wine") => "wine"
~~~
</pre>

<pre class="nim-code">
func fun_case_iloaa(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_case_sloaa">fun_case_sloaa</h3>

<pre class="description">
Compare string cases and return the matching value.  It takes a main string condition, a list of case pairs and an optional value when none of the cases match.

The first element of a case pair is the condition and the
second is the return value when that condition matches the main
condition. The function compares the conditions left to right and
returns the first match.

When none of the cases match the main condition, the default
value is returned if it is specified, otherwise a warning is
generated.  The conditions must be strings. The return values
can be any type.

~~~
case(condition: string, pairs: list, default: optional any) any
~~~

Examples:

~~~
cases = list("tea", 15, "water", 2.3, "beer", "cold")
case("tea", cases) => 15
case("water", cases) => 2.3
case("beer", cases) => "cold"
case("bunch", cases, "other") => "other"
~~~
</pre>

<pre class="nim-code">
func fun_case_sloaa(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="parseVersion">parseVersion</h3>

<pre class="description">
Parse a StaticTea version number and return its three components.
</pre>

<pre class="nim-code">
func parseVersion(version: string): Option[(int, int, int)]
</pre>

<h3 id="fun_cmpVersion_ssi">fun_cmpVersion_ssi</h3>

<pre class="description">
Compare two StaticTea version numbers. Returns -1 for less, 0 for equal and 1 for greater than.

~~~
cmpVersion(versionA: string, versionB: string) int
~~~

StaticTea uses [[https://semver.org/][Semantic Versioning]]
with the added restriction that each version component has one
to three digits (no letters).

Examples:

~~~
cmpVersion("1.2.5", "1.1.8") => 1
cmpVersion("1.2.5", "1.3.0") => -1
cmpVersion("1.2.5", "1.2.5") => 0
~~~
</pre>

<pre class="nim-code">
func fun_cmpVersion_ssi(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_float_if">fun_float_if</h3>

<pre class="description">
Create a float from an int.

~~~
float(num: int) float
~~~

Examples:

~~~
float(2) => 2.0
float(-33) => -33.0
~~~
</pre>

<pre class="nim-code">
func fun_float_if(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_float_sf">fun_float_sf</h3>

<pre class="description">
Create a float from a number string.

~~~
float(numString: string) float
~~~

Examples:

~~~
float("2") => 2.0
float("2.4") => 2.4
float("33") => 33.0
~~~
</pre>

<pre class="nim-code">
func fun_float_sf(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_float_saa">fun_float_saa</h3>

<pre class="description">
Create a float from a number string. If the string is not a number, return the default.

~~~
float(numString: string, default: optional any) any
~~~

Examples:

~~~
float("2") => 2.0
float("notnum", "nan") => nan
~~~
</pre>

<pre class="nim-code">
func fun_float_saa(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_int_fosi">fun_int_fosi</h3>

<pre class="description">
Create an int from a float.

~~~
int(num: float, roundOption: optional string) int
~~~

Round options:

* "round" - nearest integer, the default.
* "floor" - integer below (to the left on number line)
* "ceiling" - integer above (to the right on number line)
* "truncate" - remove decimals

Examples:

~~~
int(2.34) => 2
int(2.34, "round") => 2
int(-2.34, "round") => -2
int(6.5, "round") => 7
int(-6.5, "round") => -7
int(4.57, "floor") => 4
int(-4.57, "floor") => -5
int(6.3, "ceiling") => 7
int(-6.3, "ceiling") => -6
int(6.3456, "truncate") => 6
int(-6.3456, "truncate") => -6
~~~
</pre>

<pre class="nim-code">
func fun_int_fosi(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_int_sosi">fun_int_sosi</h3>

<pre class="description">
Create an int from a number string.

~~~
int(numString: string, roundOption: optional string) int
~~~

Round options:

* "round" - nearest integer, the default
* "floor" - integer below (to the left on number line)
* "ceiling" - integer above (to the right on number line)
* "truncate" - remove decimals

Examples:

~~~
int("2") => 2
int("2.34") => 2
int("-2.34", "round") => -2
int("6.5", "round") => 7
int("-6.5", "round") => -7
int("4.57", "floor") => 4
int("-4.57", "floor") => -5
int("6.3", "ceiling") => 7
int("-6.3", "ceiling") => -6
int("6.3456", "truncate") => 6
int("-6.3456", "truncate") => -6
~~~
</pre>

<pre class="nim-code">
func fun_int_sosi(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_int_ssaa">fun_int_ssaa</h3>

<pre class="description">
Create an int from a number string. If the string is not a number, return the default value.

~~~
int(numString: string, roundOption: string, default: optional any) any
~~~

Round options:

* "round" - nearest integer, the default
* "floor" - integer below (to the left on number line)
* "ceiling" - integer above (to the right on number line)
* "truncate" - remove decimals

Examples:

~~~
int("2", "round", "nan") => 2
int("notnum", "round", "nan") => nan
~~~
</pre>

<pre class="nim-code">
func fun_int_ssaa(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="if0Condition">if0Condition</h3>

<pre class="description">
Convert the value to a boolean.
</pre>

<pre class="nim-code">
func if0Condition(cond: Value): bool
</pre>

<h3 id="fun_bool_ab">fun_bool_ab</h3>

<pre class="description">
Create an bool from a value.

~~~
bool(value: Value) bool
~~~

False values by variable types:

* bool -- false
* int -- 0
* float -- 0.0
* string -- when the length of the string is 0
* list -- when the length of the list is 0
* dict -- when the length of the dictionary is 0
* func -- always false

Examples:

~~~
bool(0) => false
bool(0.0) => false
bool([]) => false
bool("") => false
bool(dict()) => false

bool(5) => true
bool(3.3) => true
bool([8]) => true
bool("tea") => true
bool(dict("tea", 2)) => true
~~~
</pre>

<pre class="nim-code">
func fun_bool_ab(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_find_ssoaa">fun_find_ssoaa</h3>

<pre class="description">
Find the position of a substring in a string.  When the substring is not found, return an optional default value.  A warning is generated when the substring is missing and you don't specify a default value.

~~~
find(str: string, substring: string, default: optional any) any
~~~

Examples:

~~~
       0123456789 1234567
msg = "Tea time at 3:30."
find(msg, "Tea") = 0
find(msg, "time") = 4
find(msg, "me") = 6
find(msg, "party", -1) = -1
find(msg, "party", len(msg)) = 17
find(msg, "party", 0) = 0
~~~
</pre>

<pre class="nim-code">
func fun_find_ssoaa(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_slice_siois">fun_slice_siois</h3>

<pre class="description">
Extract a substring from a string by its position and length. You pass the string, the substring's start index and its length.  The length is optional. When not specified, the slice returns the characters from the start to the end of the string.

The start index and length are by unicode characters not bytes.

~~~
slice(str: string, start: int, length: optional int) string
~~~

Examples:

~~~
slice("Earl Grey", 1, 3) => "arl"
slice("Earl Grey", 6) => "rey"
slice("añyóng", 0, 3) => "añy"
~~~
</pre>

<pre class="nim-code">
func fun_slice_siois(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_dup_sis">fun_dup_sis</h3>

<pre class="description">
Duplicate a string x times.  The result is a new string built by concatenating the string to itself the specified number of times.

~~~
dup(pattern: string, count: int) string
~~~

Examples:

~~~
dup("=", 3) => "==="
dup("abc", 0) => ""
dup("abc", 1) => "abc"
dup("abc", 2) => "abcabc"
dup("", 3) => ""
~~~
</pre>

<pre class="nim-code">
func fun_dup_sis(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_dict_old">fun_dict_old</h3>

<pre class="description">
Create a dictionary from a list of key, value pairs.  The keys must be strings and the values can be any type.

~~~
dict(pairs: optional list) dict
~~~

Examples:

~~~
dict() => {}
dict(["a", 5]) => {"a": 5}
dict(["a", 5, "b", 33, "c", 0]) =>
  {"a": 5, "b": 33, "c": 0}
~~~
</pre>

<pre class="nim-code">
func fun_dict_old(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_list_al">fun_list_al</h3>

<pre class="description">
Create a list of variables. You can also create a list with brackets.

~~~
list(...) list
~~~

Examples:

~~~
a = list()
a = list(1)
a = list(1, 2, 3)
a = list("a", 5, "b")
a = []
a = [1]
a = [1, 2, 3]
a = ["a", 5, "b"]
~~~
</pre>

<pre class="nim-code">
func fun_list_al(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_listLoop_lapoab">fun_listLoop_lapoab</h3>

<pre class="description">
Loop over items in a list and fill in a container. A callback function is called for each item in the list and it decides what goes in the container.

You pass a list to loop over, a container to fill in, a callback
function, and an optional state variable. The function returns
whether the callback stopped early or not.

~~~
listLoop(a: list, container: any, listCallback: func, state: optional any) bool
~~~

The callback gets passed the index to the item, its value, the
container and the state variable.  The callback looks at the
information and adds to the container when appropriate. The
callback returns true to stop iterating.

~~~
listCallback(ix: int, item: any, container: any, state: optional any) bool
~~~

The following example makes a new list [6, 8] from the list
[2,4,6,8].  The callback is called b5.

~~~
o.container = []
list = [2,4,6,8]
stopped = listLoop(list, o.container, b5)
# o.container => [6, 8]
~~~

Below is the definition of the b5 callback function.

~~~
b5 = func(ix: int, value: int, container: list) bool
  ## Collect values greater than 5.
  container &= if( (value > 5), value)
  return(false)
~~~
</pre>

<pre class="nim-code">
func fun_listLoop_lapoab(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_replace_siiss">fun_replace_siiss</h3>

<pre class="description">
Replace a substring specified by its position and length with another string.  You can use the function to insert and append to a string as well.

~~~
replace(str: string, start: int, length: int, replacement: string) string
~~~

* str: string
* start: substring start index
* length: substring length
* replacement: substring replacement

Examples:

Replace:
~~~
replace("Earl Grey", 5, 4, "of Sandwich")
  => "Earl of Sandwich"
replace("123", 0, 1, "abcd") => abcd23
replace("123", 0, 2, "abcd") => abcd3

replace("123", 1, 1, "abcd") => 1abcd3
replace("123", 1, 2, "abcd") => 1abcd

replace("123", 2, 1, "abcd") => 12abcd
~~~
Insert:
~~~
replace("123", 0, 0, "abcd") => abcd123
replace("123", 1, 0, "abcd") => 1abcd23
replace("123", 2, 0, "abcd") => 12abcd3
replace("123", 3, 0, "abcd") => 123abcd
~~~
Append:
~~~
replace("123", 3, 0, "abcd") => 123abcd
~~~
Delete:
~~~
replace("123", 0, 1, "") => 23
replace("123", 0, 2, "") => 3
replace("123", 0, 3, "") => ""

replace("123", 1, 1, "") => 13
replace("123", 1, 2, "") => 1

replace("123", 2, 1, "") => 12
~~~
Edge Cases:
~~~
replace("", 0, 0, "") =>
replace("", 0, 0, "a") => a
replace("", 0, 0, "ab") => ab
replace("", 0, 0, "abc") => abc
replace("", 0, 0, "abcd") => abcd
~~~
</pre>

<pre class="nim-code">
func fun_replace_siiss(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_replaceRe_sls">fun_replaceRe_sls</h3>

<pre class="description">
Replace multiple parts of a string using regular expressions.

You specify one or more pairs of regex patterns and their string
replacements.

~~~
replaceRe(str: string, pairs: list) string
~~~

Examples:

~~~
list = list("abc", "456", "def", "")
replaceRe("abcdefabc", list))
  => "456456"
~~~

For developing and debugging regular expressions see the
website: https://regex101.com/
</pre>

<pre class="nim-code">
func fun_replaceRe_sls(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="parsePath">parsePath</h3>

<pre class="description">
Parse the given file path into its component pieces.
</pre>

<pre class="nim-code">
func parsePath(path: string; separator = '/'): PathComponents
</pre>

<h3 id="fun_path_sosd">fun_path_sosd</h3>

<pre class="description">
Split a file path into its component pieces. Return a dictionary with the filename, basename, extension and directory.

You pass a path string and the optional path separator, forward
slash or or backslash. When no separator, the current
system separator is used.

~~~
path(filename: string, separator: optional string) dict
~~~

Examples:

~~~
path("src/functions.nim") => {
  "filename": "functions.nim",
  "basename": "functions",
  "ext": ".nim",
  "dir": "src/",
}

path("src\functions.nim", "\") => {
  "filename": "functions.nim",
  "basename": "functions",
  "ext": ".nim",
  "dir": "src\",
}
~~~
</pre>

<pre class="nim-code">
func fun_path_sosd(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_lower_ss">fun_lower_ss</h3>

<pre class="description">
Lowercase a string.

~~~
lower(str: string) string
~~~

Examples:

~~~
lower("Tea") => "tea"
lower("TEA") => "tea"
lower("TEĀ") => "teā"
~~~
</pre>

<pre class="nim-code">
func fun_lower_ss(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_keys_dl">fun_keys_dl</h3>

<pre class="description">
Create a list from the keys in a dictionary.

~~~
keys(dictionary: dict) list
~~~

Examples:

~~~
d = dict("a", 1, "b", 2, "c", 3)
keys(d) => ["a", "b", "c"]
values(d) => [1, 2, 3]
~~~
</pre>

<pre class="nim-code">
func fun_keys_dl(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_values_dl">fun_values_dl</h3>

<pre class="description">
Create a list out of the values in the specified dictionary.

~~~
values(dictionary: dict) list
~~~

Examples:

~~~
d = dict("a", "apple", "b", 2, "c", 3)
keys(d) => ["a", "b", "c"]
values(d) => ["apple", 2, 3]
~~~
</pre>

<pre class="nim-code">
func fun_values_dl(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_sort_lsosl">fun_sort_lsosl</h3>

<pre class="description">
Sort a list of values of the same type.  The values are ints, floats, or strings.

You specify the sort order, "ascending" or "descending".

You have the option of sorting strings case "insensitive". Case
"sensitive" is the default.

~~~
sort(values: list, order: string, insensitive: optional string) list
~~~

Examples:

~~~
ints = list(4, 3, 5, 5, 2, 4)
sort(list, "ascending") => [2, 3, 4, 4, 5, 5]
sort(list, "descending") => [5, 5, 4, 4, 3, 2]

floats = list(4.4, 3.1, 5.9)
sort(floats, "ascending") => [3.1, 4.4, 5.9]
sort(floats, "descending") => [5.9, 4.4, 3.1]

strs = list("T", "e", "a")
sort(strs, "ascending") => ["T", "a", "e"]
sort(strs, "ascending", "sensitive") => ["T", "a", "e"]
sort(strs, "ascending", "insensitive") => ["a", "e", "T"]
~~~
</pre>

<pre class="nim-code">
func fun_sort_lsosl(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_sort_lssil">fun_sort_lssil</h3>

<pre class="description">
Sort a list of lists.

You specify the sort order, "ascending" or "descending".

You specify how to sort strings either case "sensitive" or
"insensitive".

You specify which index to compare by.  The compare index value
must exist in each list, be the same type and be an int, float,
or string.

~~~
sort(lists: list, order: string, case: string, index: int) list
~~~

Examples:

~~~
l1 = list(4, 3, 1)
l2 = list(2, 3, 4)
listOfLists = list(l1, l2)
sort(listOfLists, "ascending", "sensitive", 0) => [l2, l1]
sort(listOfLists, "ascending", "sensitive", 2) => [l1, l2]
~~~
</pre>

<pre class="nim-code">
func fun_sort_lssil(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_sort_lsssl">fun_sort_lsssl</h3>

<pre class="description">
Sort a list of dictionaries.

You specify the sort order, "ascending" or "descending".

You specify how to sort strings either case "sensitive" or
"insensitive".

You specify the compare key.  The key value must exist in
each dictionary, be the same type and be an int, float or
string.

~~~
sort(dicts: list, order: string, case: string, key: string) list
~~~

Examples:

~~~
d1 = dict("name", "Earl Gray", "weight", 1.2)
d2 = dict("name", "Tea Pot", "weight", 3.5)
dicts = list(d1, d2)
sort(dicts, "ascending", "sensitive", "weight") => [d1, d2]
sort(dicts, "descending", "sensitive", "name") => [d2, d1]
~~~
</pre>

<pre class="nim-code">
func fun_sort_lsssl(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_anchors_lsl">fun_anchors_lsl</h3>

<pre class="description">
Create anchor names from heading names. Use it for HTML class names or Github markdown internal links. It handles duplicate heading names.

~~~
anchors(names: list, type: string) list
~~~

type:

* html -- HTML class names
* github -- GitHub markdown anchor links

Examples:

~~~
list = list("Tea", "Water", "Tea")
anchores(list, "github") =>
  ["tea", "water", "tea-1"]
~~~
</pre>

<pre class="nim-code">
func fun_anchors_lsl(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_type_as">fun_type_as</h3>

<pre class="description">
Return the argument type, one of: int, float, string, list, dict, bool or func.

~~~
type(variable: any) string
~~~

Examples:

~~~
type(2) => "int"
type(3.14159) => "float"
type("Tea") => "string"
type(list(1,2)) => "list"
type(dict("a", 1)) => "dict"
type(true) => "bool"
type(f.cmp[0]) => "func"
~~~
</pre>

<pre class="nim-code">
func fun_type_as(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_joinPath_loss">fun_joinPath_loss</h3>

<pre class="description">
Join the path components with a path separator.

You pass a list of components to join. For the second optional
parameter you specify the separator to use, either "/", "" or
"". If you specify "" or leave off the parameter, the current
platform separator is used.

If the separator already exists between components, a new one
is not added. If a component is "", the platform separator is
used for it.

~~~
joinPath(components: list, separator: optional string) string
~~~

Examples:

~~~
joinPath(["images", "tea"]) =>
  "images/tea"

joinPath(["images", "tea"], "/") =>
  "images/tea"

joinPath(["images", "tea"], "\") =>
  "images\tea"

joinPath(["images/", "tea"]) =>
  "images/tea"

joinPath(["", "tea"]) =>
  "/tea"

joinPath(["/", "tea"]) =>
  "/tea"
~~~
</pre>

<pre class="nim-code">
func fun_joinPath_loss(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_join_lsois">fun_join_lsois</h3>

<pre class="description">
Join a list of strings with a separator.  An optional parameter determines whether you skip empty strings or not. You can use an empty separator to concatenate the arguments.

~~~
join(strs: list, sep: string, skipEmpty: optional bool) string
~~~

Examples:

~~~
join(["a", "b"], ", ") => "a, b"
join(["a", "b"], "") => "ab"
join(["a", "b", "c"], "") => "abc"
join(["a"], ", ") => "a"
join([""], ", ") => ""
join(["a", "b"], "") => "ab"
join(["a", "", "c"], "|") => "a||c"
join(["a", "", "c"], "|", true) => "a|c"
~~~
</pre>

<pre class="nim-code">
func fun_join_lsois(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_warn_ss">fun_warn_ss</h3>

<pre class="description">
Return a warning message and skip the current statement. You can call the warn function without an assignment.

~~~
warn(message: string) string
~~~

You can warn conditionally in a bare if statement:

~~~
if0(c, warn("message is 0"))
~~~

You can warn unconditionally using a bare warn statement:

~~~
warn("always warn")
~~~
</pre>

<pre class="nim-code">
func fun_warn_ss(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_log_ss">fun_log_ss</h3>

<pre class="description">
Log a message to the log file.  You can call the log function without an assignment.

~~~
log(message: string) string
~~~

You can log conditionally in a bare if statement:

~~~
if0(c, log("log this message when c is 0"))
~~~

You can log unconditionally using a bare log statement:

~~~
log("always log")
~~~
</pre>

<pre class="nim-code">
func fun_log_ss(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_return_aa">fun_return_aa</h3>

<pre class="description">
Return is a special function that returns the value passed in and has has side effects.

In a function, the return completes the function and returns
the value of it.

~~~
return(false)
~~~

You can also use it with a bare IF statement to conditionally
return a function value.

~~~
if(c, return(5))
~~~

In a template command a return controls the replacement block
looping by returning “skip” and “stop”.

~~~
if(c, return("stop"))
if(c, return("skip"))
~~~

* “stop” – stops processing the command
* “skip” – skips this replacement block and continues with the next iteration

The following block command repeats 4 times but skips when t.row is 2.

~~~
$$ block t.repeat = 4
$$ : if((t.row == 2), return(“skip”))
{t.row}
$$ endblock

output:

0
1
3
~~~
</pre>

<pre class="nim-code">
func fun_return_aa(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_string_aoss">fun_string_aoss</h3>

<pre class="description">
Convert a variable to a string. You specify the variable and optionally the type of output you want.

~~~
string(var: any, stype: optional string) string
~~~

The default stype is "rb" which is used for replacement blocks.

stype:

* json -- returns JSON
* rb — replacement block (rb) returns JSON except strings are
not quoted and special characters are not escaped.
* dn -- dot name (dn) returns JSON except dictionary elements
are printed one per line as "key = value". See string(dotName, string).

Examples variables:

~~~
str = "Earl Grey"
pi = 3.14159
one = 1
a = [1, 2, 3]
d = dict(["x", 1, "y", 2])
fn = cmp[[0]
found = true
~~~

json:

~~~
str => "Earl Grey"
pi => 3.14159
one => 1
a => [1,2,3]
d => {"x":1,"y":2}
fn => "cmp"
found => true
~~~

rb:

Same as JSON except the following.

~~~
str => Earl Grey
fn => cmp
~~~

dn:

Same as JSON except the following.

~~~
d =>
x = 1
y = 2
~~~
</pre>

<pre class="nim-code">
func fun_string_aoss(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_string_sds">fun_string_sds</h3>

<pre class="description">
Convert the dictionary variable to dot names. You specify the name of the dictionary and the dict variable.

~~~
string(dictName: string: d: dict) string
~~~

Example:

~~~
d = {"x",1, "y":"tea", "z":{"a":8}}
string("teas", d) =>

teas.x = 1
teas.y = "tea"
teas.z.a = 8
~~~
</pre>

<pre class="nim-code">
func fun_string_sds(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_format_ss">fun_format_ss</h3>

<pre class="description">
Format a string using replacement variables similar to a replacement block. To enter a left bracket use two in a row.

~~~
format(str: string) string
~~~

Example:

~~~
let first = "Earl"
let last = "Grey"
str = format("name: {first} {last}")

str => "name: Earl Grey"
~~~

To enter a left bracket use two in a row.

~~~
str = format("use two {{ to get one")

str => "use two { to get one"
~~~
</pre>

<pre class="nim-code">
func fun_format_ss(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_func_sp">fun_func_sp</h3>

<pre class="description">
Define a function.

~~~
func(signature: string) func
~~~

Example:

~~~
mycmp = func(numStr1: string, numStr2: string) int
  ## Compare two number strings
  ## and return 1, 0, or -1.
  num1 = int(numStr1)
  num2 = int(numStr2)
  return(cmp(num1, num2))
~~~
</pre>

<pre class="nim-code">
func fun_func_sp(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_functionDetails_pd">fun_functionDetails_pd</h3>

<pre class="description">
Return the function details in a dictionary.

~~~
functionDetails(funcVar: func) dict
~~~

The following example defines a simple function then gets its
function details.

~~~
mycmp = func(numStr1: string, numStr2: string) int
  ## Compare two number strings and return 1, 0, or -1.
  return(cmp(int(numStr1), int(numStr2)))

fd = functionDetails(mycmp)

fd =>
fd.builtIn = false
fd.signature.optional = false
fd.signature.name = "strNumCmp"
fd.signature.paramNames = ["numStr1","numStr2"]
fd.signature.paramTypes = ["string","string"]
fd.signature.returnType = "int"
fd.docComment = "  ## Compare two number strings and return 1, 0, or -1.\n"
fd.filename = "testcode.tea"
fd.lineNum = 3
fd.numLines = 2
fd.statements = ["  return(cmp(int(numStr1), int(numStr2)))"]
~~~
</pre>

<pre class="nim-code">
func fun_functionDetails_pd(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_startsWith_ssb">fun_startsWith_ssb</h3>

<pre class="description">
Check whether a strings starts with the given prefix. Return true when it does, else false.

~~~
startsWith(str: string, str: prefix) bool
~~~

Examples:

~~~
a = startsWith("abcdef", "abc")
b = startsWith("abcdef", "abf")

a => true
b => false
~~~
</pre>

<pre class="nim-code">
func fun_startsWith_ssb(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_not_bb">fun_not_bb</h3>

<pre class="description">
Boolean not.

~~~
not(value: bool) bool
~~~

Examples:

~~~
not(true) => false
not(false) => true
~~~
</pre>

<pre class="nim-code">
func fun_not_bb(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_and_bbb">fun_and_bbb</h3>

<pre class="description">
Boolean AND with short circuit. If the first argument is false, the second argument is not evaluated.

~~~
and(a: bool, b: bool) bool
~~~

Examples:

~~~
and(true, true) => true
and(false, true) => false
and(true, false) => false
and(false, false) => false
and(false, warn("not hit")) => false
~~~
</pre>

<pre class="nim-code">
func fun_and_bbb(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_or_bbb">fun_or_bbb</h3>

<pre class="description">
Boolean OR with short circuit. If the first argument is true, the second argument is not evaluated.

~~~
or(a: bool, b: bool) bool
~~~

Examples:

~~~
or(true, true) => true
or(false, true) => true
or(true, false) => true
or(false, false) => false
or(true, warn("not hit")) => true
~~~
</pre>

<pre class="nim-code">
func fun_or_bbb(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_eq_iib">fun_eq_iib</h3>

<pre class="description">
Return true when the two ints are equal.

~~~
eq(a: int, b: int) bool
~~~

Examples:

~~~
eq(1, 1) => true
eq(2, 3) => false
~~~
</pre>

<pre class="nim-code">
func fun_eq_iib(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_eq_ffb">fun_eq_ffb</h3>

<pre class="description">
Return true when two floats are equal.

~~~
eq(a: float, b: float) bool
~~~

Examples:

~~~
eq(1.2, 1.2) => true
eq(1.2, 3.2) => false
~~~
</pre>

<pre class="nim-code">
func fun_eq_ffb(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_eq_ssb">fun_eq_ssb</h3>

<pre class="description">
Return true when two strings are equal.  See cmp function for case insensitive compare.

~~~
eq(a: string, b: string) bool
~~~

Examples:

~~~
eq("tea", "tea") => true
eq("1.2", "3.2") => false
~~~
</pre>

<pre class="nim-code">
func fun_eq_ssb(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_ne_iib">fun_ne_iib</h3>

<pre class="description">
Return true when two ints are not equal.

~~~
ne(a: int, b: int) bool
~~~

Examples:

~~~
ne(1, 1) => false
ne(2, 3) => true
~~~
</pre>

<pre class="nim-code">
func fun_ne_iib(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_ne_ffb">fun_ne_ffb</h3>

<pre class="description">
Return true when two floats are not equal.

~~~
ne(a: float, b: float) bool
~~~

Examples:

~~~
ne(1.2, 1.2) => false
ne(1.2, 3.2) => true
~~~
</pre>

<pre class="nim-code">
func fun_ne_ffb(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_ne_ssb">fun_ne_ssb</h3>

<pre class="description">
Return true when two strings are not equal.

~~~
ne(a: string, b: string) bool
~~~

Examples:

~~~
ne("tea", "tea") => false
ne("earl", "grey") => true
~~~
</pre>

<pre class="nim-code">
func fun_ne_ssb(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_gt_iib">fun_gt_iib</h3>

<pre class="description">
Return true when an int is greater then another int.

~~~
gt(a: int, b: int) bool
~~~

Examples:

~~~
gt(2, 4) => false
gt(3, 2) => true
~~~
</pre>

<pre class="nim-code">
func fun_gt_iib(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_gt_ffb">fun_gt_ffb</h3>

<pre class="description">
Return true when one float is greater than another float.

~~~
gt(a: float, b: float) bool
~~~

Examples:

~~~
gt(2.8, 4.3) => false
gt(3.1, 2.5) => true
~~~
</pre>

<pre class="nim-code">
func fun_gt_ffb(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_gte_iib">fun_gte_iib</h3>

<pre class="description">
Return true when an int is greater then or equal to another int.

~~~
gte(a: int, b: int) bool
~~~

Examples:

~~~
gte(2, 4) => false
gte(3, 3) => true
~~~
</pre>

<pre class="nim-code">
func fun_gte_iib(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_gte_ffb">fun_gte_ffb</h3>

<pre class="description">
Return true when a float is greater than or equal to another float.

~~~
gte(a: float, b: float) bool
~~~

Examples:

~~~
gte(2.8, 4.3) => false
gte(3.1, 3.1) => true
~~~
</pre>

<pre class="nim-code">
func fun_gte_ffb(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_lt_iib">fun_lt_iib</h3>

<pre class="description">
Return true when an int is less than another int.

~~~
lt(a: int, b: int) bool
~~~

Examples:

~~~
gt(2, 4) => true
gt(3, 2) => false
~~~
</pre>

<pre class="nim-code">
func fun_lt_iib(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_lt_ffb">fun_lt_ffb</h3>

<pre class="description">
Return true when a float is less then another float.

~~~
lt(a: float, b: float) bool
~~~

Examples:

~~~
lt(2.8, 4.3) => true
lt(3.1, 2.5) => false
~~~
</pre>

<pre class="nim-code">
func fun_lt_ffb(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_lte_iib">fun_lte_iib</h3>

<pre class="description">
Return true when an int is less than or equal to another int.

~~~
lte(a: int, b: int) bool
~~~

Examples:

~~~
lte(2, 4) => true
lte(3, 3) => true
lte(4, 3) => false
~~~
</pre>

<pre class="nim-code">
func fun_lte_iib(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_lte_ffb">fun_lte_ffb</h3>

<pre class="description">
Return true when a float is less than or equal to another float.

~~~
lte(a: float, b: float) bool
~~~

Examples:

~~~
lte(2.3, 4.4) => true
lte(3.0, 3.0) => true
lte(4.0, 3.0) => false
~~~
</pre>

<pre class="nim-code">
func fun_lte_ffb(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_readJson_sa">fun_readJson_sa</h3>

<pre class="description">
Convert a JSON string to a variable.

~~~
readJson(json: string) any
~~~

Examples:

~~~
a = readJson(""tea"") => "tea"
b = readJson("4.5") => 4.5
c = readJson("[1,2,3]") => [1, 2, 3]
d = readJson("{"a":1, "b": 2}")
  => {"a": 1, "b", 2}
~~~
</pre>

<pre class="nim-code">
func fun_readJson_sa(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="fun_markdownLite_sl">fun_markdownLite_sl</h3>

<pre class="description">
Parse a simple subset of markdown which contains paragraphs, bullets and code blocks. This subset is used to document all StaticTea functions. Return a list of lists.

list elements:

* p -- A paragraph element is one string, possibly containing
newlines.

* code -- A code element is three strings. The first string is
the code start line, for example “~~~” or “~~~nim”.  The second
string (with newlines) contains the text of the block.  The third
string is the ending line, for example “~~~”.

* bullets -- A bullets element contains a string (with newlines)
for each bullet point.  The leading “* “ is not part of the
string.

~~~
elements = markdownLite(description)
elements => [
  ["p", ["the paragraph which may contain newlines"]]
  ["code", ["~~~", "code text with newlines", "~~~"]]
  ["bullets", ["bullet (newlines) 1", "point 2", "3", ...]
]
~~~
</pre>

<pre class="nim-code">
func fun_markdownLite_sl(variables: Variables; arguments: seq[Value]): FunResult
</pre>

<h3 id="functionsDict">functionsDict</h3>

<pre class="description">
Maps a built-in function name to a function pointer you can call.
</pre>

<pre class="nim-code">
functionsDict = newTable(32)
</pre>

<h3 id="BuiltInInfo">BuiltInInfo</h3>

<pre class="description">
The built-in function information.

* funcName -- the function name in the nim file, e.g.: fun_add_ii
* docComment -- the function documentation
* numLines -- the number of function code lines
</pre>

<pre class="nim-code">
BuiltInInfo = object
  funcName*: string
  docComment*: string
  numLines*: Natural

</pre>

<h3 id="newBuiltInInfo">newBuiltInInfo</h3>

<pre class="description">
Return a BuiltInInfo object.
</pre>

<pre class="nim-code">
func newBuiltInInfo(funcName: string; docComment: string; numLines: Natural): BuiltInInfo
</pre>

<h3 id="getBestFunction">getBestFunction</h3>

<pre class="description">
Given a function variable or a list of function variables and a list of arguments, return the one that best matches the arguments.
</pre>

<pre class="nim-code">
proc getBestFunction(funcValue: Value; arguments: seq[Value]): ValueOr
</pre>

<h3 id="splitFuncName">splitFuncName</h3>

<pre class="description">
Split a funcName like "fun_cmp_ffi" to its name and signature like: "cmp" and "ffi".
</pre>

<pre class="nim-code">
func splitFuncName(funcName: string): (string, string)
</pre>

<h3 id="makeFuncDictionary">makeFuncDictionary</h3>

<pre class="description">
Create the f dictionary from the built in functions.
</pre>

<pre class="nim-code">
proc makeFuncDictionary(): VarsDict
</pre>

<h3 id="funcsVarDict">funcsVarDict</h3>

<pre class="description">
The f dictionary of built-in functions.
</pre>

<pre class="nim-code">
funcsVarDict = makeFuncDictionary()
</pre>


<p>⦿ This page was generated
by <a href="https://github.com/flenniken/statictea/">statictea</a>
from nim doc comments. ⦿</p>

</body>
</html>
