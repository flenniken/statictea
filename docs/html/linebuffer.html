<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>linebuffer.nim</title>
<style>
body {
    max-width: 40em;
    font-size: 2em;
    margin-left: 1em;
}

#staticteadep {
    width: 100%;
}

.signature {
    color: green;
}

.description {
    white-space: pre-wrap;
}

.nim-code {
    border-left: 6px solid green;
    padding: 16px;
    background-color: #f6f8fa;
    border-radius: 6px;
}
</style>
</head>
<body>
<h1>linebuffer.nim</h1>

Read lines from a stream without exceeding the maximum line length. The returned lines contain the line ending, either crlf or lf.

Example:

~~~
let lbO = newLineBuffer(stream)
check lbO.isSome == true
var lb = lbO.get()
while line = lb.readLine():
  processLine(line)
~~~

Nim source code: <a href="../../src/linebuffer.nim">linebuffer.nim</a>

<h1>Index</h1>

<ul>
<li>const:  <a href="#minMaxLineLen">minMaxLineLen</a> &mdash; The minimum line length supported.</li>
<li>const:  <a href="#maxMaxLineLen">maxMaxLineLen</a> &mdash; The maximum line length supported.</li>
<li>const:  <a href="#defaultMaxLineLen">defaultMaxLineLen</a> &mdash; The maximum line length.</li>
<li>const:  <a href="#defaultBufferSize">defaultBufferSize</a> &mdash; The buffer size for reading lines.</li>
<li>type:  <a href="#LineBuffer">LineBuffer</a> &mdash; The LineBuffer holds information about reading lines from a buffer.</li>
<li> <a href="#getLineNum">getLineNum</a> &mdash; Return the current line number.</li>
<li> <a href="#getMaxLineLen">getMaxLineLen</a> &mdash; Return the maximum line length.</li>
<li> <a href="#getFilename">getFilename</a> &mdash; Return the filename of the stream, if there is one.</li>
<li> <a href="#getStream">getStream</a> &mdash; Return the associated stream.</li>
<li> <a href="#newLineBuffer">newLineBuffer</a> &mdash; Return a new LineBuffer for the given stream.</li>
<li> <a href="#reset">reset</a> &mdash; Clear the buffer and set the read position at the start of the stream.</li>
<li> <a href="#readline">readline</a> &mdash; Return the next line from the LineBuffer.</li>
<li> <a href="#yieldContentLine">yieldContentLine</a> &mdash; Yield one line at a time from the content string and keep the line endings.</li>
</ul>

<h3 id="minMaxLineLen">minMaxLineLen</h3>

<pre class="description">
The minimum line length supported.
</pre>

<pre class="nim-code">
minMaxLineLen = 8
</pre>

<h3 id="maxMaxLineLen">maxMaxLineLen</h3>

<pre class="description">
The maximum line length supported.
</pre>

<pre class="nim-code">
maxMaxLineLen = 8192
</pre>

<h3 id="defaultMaxLineLen">defaultMaxLineLen</h3>

<pre class="description">
The maximum line length.
</pre>

<pre class="nim-code">
defaultMaxLineLen = 1024
</pre>

<h3 id="defaultBufferSize">defaultBufferSize</h3>

<pre class="description">
The buffer size for reading lines.
</pre>

<pre class="nim-code">
defaultBufferSize = 16384
</pre>

<h3 id="LineBuffer">LineBuffer</h3>

<pre class="description">
The LineBuffer holds information about reading lines from a buffer.
* stream -- a stream containing lines to read processed sequentially
* maxLineLen -- the maximum line length
* bufferSize -- the buffer size for reading lines
* lineNum -- he current line number in the file starting at 1
* pos -- current byte position in the buffer
* charsRead -- number of bytes in the buffer
* buffer -- memory allocated for the buffer
* filename -- the optional stream's filename
</pre>

<pre class="nim-code">
LineBuffer = object
  stream: Stream
  maxLineLen: int
  bufferSize: int
  lineNum: int
  pos: int
  charsRead: int
  buffer: string
  filename: string

</pre>

<h3 id="getLineNum">getLineNum</h3>

<pre class="description">
Return the current line number.
</pre>

<pre class="nim-code">
proc getLineNum(lineBuffer: LineBuffer): int
</pre>

<h3 id="getMaxLineLen">getMaxLineLen</h3>

<pre class="description">
Return the maximum line length.
</pre>

<pre class="nim-code">
proc getMaxLineLen(lineBuffer: LineBuffer): int
</pre>

<h3 id="getFilename">getFilename</h3>

<pre class="description">
Return the filename of the stream, if there is one.
</pre>

<pre class="nim-code">
proc getFilename(lineBuffer: LineBuffer): string
</pre>

<h3 id="getStream">getStream</h3>

<pre class="description">
Return the associated stream.
</pre>

<pre class="nim-code">
proc getStream(lineBuffer: LineBuffer): Stream
</pre>

<h3 id="newLineBuffer">newLineBuffer</h3>

<pre class="description">
Return a new LineBuffer for the given stream.
</pre>

<pre class="nim-code">
proc newLineBuffer(stream: Stream; maxLineLen: int = defaultMaxLineLen;
                   bufferSize: int = defaultBufferSize; filename: string = ""): Option[
    LineBuffer]
</pre>

<h3 id="reset">reset</h3>

<pre class="description">
Clear the buffer and set the read position at the start of the stream.
</pre>

<pre class="nim-code">
proc reset(lb: var LineBuffer)
</pre>

<h3 id="readline">readline</h3>

<pre class="description">
Return the next line from the LineBuffer. Reading starts from the
current position in the stream and advances the amount read.

A line end is defined by either a crlf or lf and they get
returned with the line bytes. A line is returned when the line
ending is found, when the stream runs out of bytes or when the
maximum line length is reached.

You cannot tell whether the line was truncated or not without
reading the next line. When no more data exists in the stream, an
empty string is returned.
</pre>

<pre class="nim-code">
proc readline(lb: var LineBuffer): string
</pre>

<h3 id="yieldContentLine">yieldContentLine</h3>

<pre class="description">
Yield one line at a time from the content string and keep the line endings.
</pre>

<pre class="nim-code">
iterator yieldContentLine(content: string): string
</pre>


<p>⦿ This page was generated
by <a href="https://github.com/flenniken/statictea/">statictea</a>
from nim doc comments. ⦿</p>

</body>
</html>
