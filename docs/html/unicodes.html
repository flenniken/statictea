<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
</head>
<style>
body {
    max-width: 40em;
    font-size: 2em;
    margin-left: 1em;
}

#staticteadep {
    width: 100%;
}

.signature {
    color: green;
}

.code {
    border-left: 6px solid green;
}
</style>
<body>
<h1>unicodes.nim</h1>

<p>Functions that deal with Unicode.</p>

Nim source code: <a href="../../src/unicodes.nim">unicodes.nim</a>

<h1>Index</h1>

<ul>
<li> <a href="#cmpString">cmpString</a> &mdash; Compares two UTF-8 strings a and b.</li>
<li> <a href="#stringLen">stringLen</a> &mdash; Return the number of unicode characters in the string (not bytes).</li>
<li> <a href="#githubAnchor">githubAnchor</a> &mdash; Convert the name to a github anchor name.</li>
<li> <a href="#parseHexUnicode16">parseHexUnicode16</a> &mdash; Return the unicode code point given a 4 character unicode escape string like u1234.</li>
<li> <a href="#parseHexUnicode">parseHexUnicode</a> &mdash; Return the unicode code point given a 4 or 8 character unicode escape string.</li>
<li> <a href="#codePointToString">codePointToString</a> &mdash; Convert a code point to a one character UTF-8 string.</li>
<li> <a href="#codePointsToString">codePointsToString</a> &mdash; Convert a list of code points to a string.</li>
<li> <a href="#parseHexUnicodeToString">parseHexUnicodeToString</a> &mdash; Return a one character string given a 4 or 8 character unicode escape string.</li>
<li> <a href="#slice">slice</a> &mdash; Extract a substring from a string by its Unicode character position (not byte index).</li>
<li> <a href="#visibleControl">visibleControl</a> &mdash; Return a new string with the tab and line endings and other control characters visible.</li>
<li> <a href="#startColumn">startColumn</a> &mdash; Return enough spaces to point at the start byte position of the given text.</li>
</ul>

<h3 id=cmpString>cmpString</h3>

<p>Compares two UTF-8 strings a and b.  When a equals b return 0, when a is greater than b return 1 and when a is less than b return -1. Optionally ignore case.</p>

<pre class="signature">
func cmpString(a, b: string; insensitive: bool = false): int
</pre>

<h3 id=stringLen>stringLen</h3>

<p>Return the number of unicode characters in the string (not bytes). If there are invalid byte sequences, they are counted too.</p>

<pre class="signature">
func stringLen(str: string): Natural
</pre>

<h3 id=githubAnchor>githubAnchor</h3>

<p>Convert the name to a github anchor name.</p>

<pre class="signature">
func githubAnchor(name: string): string
</pre>

<h3 id=parseHexUnicode16>parseHexUnicode16</h3>

<p>Return the unicode code point given a 4 character unicode escape string like u1234. Start is pointing at the u. On error, return a message id telling what went wrong.</p>

<pre class="signature">
func parseHexUnicode16(text: string; start: Natural): OpResultId[uint32]
</pre>

<h3 id=parseHexUnicode>parseHexUnicode</h3>

<p>Return the unicode code point given a 4 or 8 character unicode escape string. For example like u1234 or u1234u1234. Advance the pos past the end of the escape string. Pos is initially pointing at the u. On error, return the message id telling what went wrong and pos points at the error.</p>

<pre class="signature">
func parseHexUnicode(text: string; pos: var Natural): OpResultId[uint32]
</pre>

<h3 id=codePointToString>codePointToString</h3>

<p>Convert a code point to a one character UTF-8 string.</p>

<pre class="signature">
func codePointToString(codePoint: uint32): OpResultId[string]
</pre>

<h3 id=codePointsToString>codePointsToString</h3>

<p>Convert a list of code points to a string.</p>

<pre class="signature">
func codePointsToString(codePoints: seq[uint32]): OpResultId[string]
</pre>

<h3 id=parseHexUnicodeToString>parseHexUnicodeToString</h3>

<p>Return a one character string given a 4 or 8 character unicode escape string. For example like u1234 or u1234u1234. Advance the pos past the end of the escape string. Pos is initially pointing at the u. On error, return the message id telling what went wrong and pos points at the error.</p>

<pre class="signature">
func parseHexUnicodeToString(text: string; pos: var Natural): OpResultId[string]
</pre>

<h3 id=slice>slice</h3>

<p>Extract a substring from a string by its Unicode character position (not byte index). You pass the string, the substring's start index, and its length. If the length is negative, return all the characters from start to the end of the string. If the str is "" or the length is 0, return "".</p>

<pre class="signature">
func slice(str: string; start: int; length: int): FunResult
</pre>

<h3 id=visibleControl>visibleControl</h3>

<p>Return a new string with the tab and line endings and other control characters visible.</p>

<pre class="signature">
func visibleControl(str: string): string
</pre>

<h3 id=startColumn>startColumn</h3>

<p>Return enough spaces to point at the start byte position of the given text.  This accounts for multibyte UTF-8 sequences that might be in the text.</p>

<pre class="signature">
func startColumn(text: string; start: Natural; message: string = "^"): string
</pre>


<p>⦿ This page was generated
by <a href="https://github.com/flenniken/statictea/">statictea</a>
from nim doc comments. ⦿</p>

</body>
</html>
