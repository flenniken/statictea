<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>runCommand.nim</title>
<style>
body {
    max-width: 40em;
    font-size: 2em;
    margin-left: 1em;
}

#staticteadep {
    width: 100%;
}

.signature {
    color: green;
}

.description {
    white-space: pre-wrap;
}

.nim-code {
    border-left: 6px solid green;
    padding: 16px;
    background-color: #f6f8fa;
    overflow: auto;
}
</style>
</head>
<body>
<h1>runCommand.nim</h1>

<pre class="description">
Run a command and fill in the variables dictionaries.
</pre>

Nim source code: <a href="../../src/runCommand.nim">runCommand.nim</a>

<h1>Index</h1>

<ul>
<li>const:  <a href="#tripleQuotes">tripleQuotes</a> &mdash; Triple quotes for building strings.</li>
<li>const:  <a href="#maxNameLength">maxNameLength</a> &mdash; The maximum length of a variable or dotname.</li>
<li>type:  <a href="#PosOr">PosOr</a> &mdash; A position in a string or a message.</li>
<li>type:  <a href="#SpecialFunction">SpecialFunction</a> &mdash; The special functions.</li>
<li>type:  <a href="#SpecialFunctionOr">SpecialFunctionOr</a> &mdash; A SpecialFunction or a warning message.</li>
<li>type:  <a href="#Found">Found</a> &mdash; The line endings found.</li>
<li>type:  <a href="#LinesOr">LinesOr</a> &mdash; A list of lines or a warning.</li>
<li>type:  <a href="#LoopControl">LoopControl</a> &mdash; Controls whether to output the current replacement block iteration and whether to stop or not.</li>
<li> <a href="#newLinesOr">newLinesOr</a> &mdash; Return a new LinesOr object containing a warning.</li>
<li> <a href="#newLinesOr-1">newLinesOr</a> &mdash; Return a new LinesOr object containing a warning.</li>
<li> <a href="#newLinesOr-2">newLinesOr</a> &mdash; Return a new LinesOr object containing a list of lines.</li>
<li> <a href="#newPosOr">newPosOr</a> &mdash; Create a PosOr warning.</li>
<li> <a href="#newPosOr-1">newPosOr</a> &mdash; Create a PosOr value.</li>
<li> <a href="#newSpecialFunctionOr">newSpecialFunctionOr</a> &mdash; Create a PosOr warning.</li>
<li> <a href="#newSpecialFunctionOr-1">newSpecialFunctionOr</a> &mdash; Create a SpecialFunctionOr value.</li>
<li> <a href="#a__">`$`</a> &mdash; Return a string representation of a Statement.</li>
<li> <a href="#a___">`==`</a> &mdash; Return true when the two statements are equal.</li>
<li> <a href="#a___-1">`==`</a> &mdash; Return true when a equals b.</li>
<li> <a href="#a___-2">`!=`</a> &mdash; Compare whether two PosOr are not equal.</li>
<li>type:  <a href="#VariableNameKind">VariableNameKind</a> &mdash; The variable name type.</li>
<li>type:  <a href="#VariableName">VariableName</a> &mdash; A variable name in a statement.</li>
<li>type:  <a href="#VariableNameOr">VariableNameOr</a> &mdash; </li>
<li>type:  <a href="#RightType">RightType</a> &mdash; The type of the right hand side of a statement.</li>
<li> <a href="#newVariableName">newVariableName</a> &mdash; Create a new VariableName object.</li>
<li> <a href="#newVariableNameOr">newVariableNameOr</a> &mdash; Create a PosOr warning.</li>
<li> <a href="#newVariableNameOr-1">newVariableNameOr</a> &mdash; Create a new VariableNameOr object.</li>
<li> <a href="#getRightType">getRightType</a> &mdash; Return the type of the right hand side of the statement at the start position.</li>
<li> <a href="#getVariableNameOr">getVariableNameOr</a> &mdash; Get a variable name from the statement.</li>
<li> <a href="#getVariableName">getVariableName</a> &mdash; Get a variable name from the statement.</li>
<li> <a href="#matchTripleOrPlusSign">matchTripleOrPlusSign</a> &mdash; Match the optional """ or + at the end of the line.</li>
<li> <a href="#addText">addText</a> &mdash; Add the line up to the line-ending to the text string.</li>
<li> <a href="#getFragmentAndPos">getFragmentAndPos</a> &mdash; Split up a long statement around the given position.</li>
<li> <a href="#getWarnStatement">getWarnStatement</a> &mdash; Return a multiline error message.</li>
<li> <a href="#warnStatement">warnStatement</a> &mdash; Show an invalid statement with a pointer pointing at the start of the problem.</li>
<li> <a href="#warnStatement-1">warnStatement</a> &mdash; </li>
<li> <a href="#removeLineEnd">removeLineEnd</a> &mdash; Return a new string with the n or rn removed from the end of the line.</li>
<li> <a href="#yieldStatements">yieldStatements</a> &mdash; Iterate through the command's statements.</li>
<li> <a href="#readStatement">readStatement</a> &mdash; Read the next statement from the code file reading multiple lines if needed.</li>
<li> <a href="#getMultilineStr">getMultilineStr</a> &mdash; Return the triple quoted string literal.</li>
<li> <a href="#getString">getString</a> &mdash; Return a literal string value and position after it.</li>
<li> <a href="#getNumber">getNumber</a> &mdash; Return the literal number value and position after it.</li>
<li> <a href="#skipArgument">skipArgument</a> &mdash; Skip past the argument.</li>
<li> <a href="#ifFunctions">ifFunctions</a> &mdash; Return the if/if0 function's value and position after.</li>
<li> <a href="#bareIfAndIf0">bareIfAndIf0</a> &mdash; Handle the bare if/if0.</li>
<li> <a href="#andOrFunctions">andOrFunctions</a> &mdash; Return the and/or function's value and the position after.</li>
<li> <a href="#getArguments">getArguments</a> &mdash; Get the function arguments and the position of each.</li>
<li> <a href="#getFunctionValuePosSi">getFunctionValuePosSi</a> &mdash; Return the function's value and the position after it.</li>
<li> <a href="#runBoolOp">runBoolOp</a> &mdash; Evaluate the bool expression and return a bool value.</li>
<li> <a href="#runCompareOp">runCompareOp</a> &mdash; Evaluate the comparison and return a bool value.</li>
<li> <a href="#getCondition">getCondition</a> &mdash; Return the bool value of the condition expression and the position after it.</li>
<li> <a href="#getBracketedVarValue">getBracketedVarValue</a> &mdash; Return the value of the bracketed variable and the position after the trailing whitespace.</li>
<li> <a href="#listLoop">listLoop</a> &mdash; Make a new list from an existing list.</li>
<li> <a href="#getValuePosSi">getValuePosSi</a> &mdash; Return the value and position of the item that the start parameter points at which is a string, number, variable, list, or condition.</li>
<li> <a href="#runBareFunction">runBareFunction</a> &mdash; Handle bare function: if, if0, return, warn and log.</li>
<li> <a href="#getBracketDotName">getBracketDotName</a> &mdash; Convert var[key] to a dot name.</li>
<li> <a href="#runStatement">runStatement</a> &mdash; Run one statement and return the variable dot name string, operator and value.</li>
<li> <a href="#skipSpaces">skipSpaces</a> &mdash; </li>
<li> <a href="#callUserFunction">callUserFunction</a> &mdash; Run the given user function.</li>
<li> <a href="#runStatementAssignVar">runStatementAssignVar</a> &mdash; Run a statement and assign the variable if appropriate.</li>
<li> <a href="#parseSignature">parseSignature</a> &mdash; Parse the signature and return the list of parameters or a message.</li>
<li> <a href="#isFunctionDefinition">isFunctionDefinition</a> &mdash; If the statement is the first line of a function definition, return true and fill in the return parameters.</li>
<li> <a href="#defineUserFunctionAssignVar">defineUserFunctionAssignVar</a> &mdash; If the statement starts a function definition, define it and assign the variable.</li>
<li> <a href="#runCommand">runCommand</a> &mdash; Run a command and fill in the variables dictionaries.</li>
<li> <a href="#runCodeFile">runCodeFile</a> &mdash; Run the code file and fill in the variables.</li>
<li> <a href="#runCodeFiles">runCodeFiles</a> &mdash; Run each code file and populate the variables.</li>
</ul>

<h3 id="tripleQuotes">tripleQuotes</h3>

<pre class="description">
Triple quotes for building strings.
</pre>

<pre class="nim-code">
tripleQuotes = "\"\"\""
</pre>

<h3 id="maxNameLength">maxNameLength</h3>

<pre class="description">
The maximum length of a variable or dotname.
</pre>

<pre class="nim-code">
maxNameLength = 64
</pre>

<h3 id="PosOr">PosOr</h3>

<pre class="description">
A position in a string or a message.
</pre>

<pre class="nim-code">
PosOr = OpResultWarn[Natural]
</pre>

<h3 id="SpecialFunction">SpecialFunction</h3>

<pre class="description">
The special functions.

* spNotSpecial -- not a special function
* spIf -- if function
* spIf0 -- if0 function
* spWarn -- warn function
* spLog -- log function
* spReturn -- return function
* spAnd -- and function
* spOr -- or function
* spFunc -- func function
* spListLoop -- list with callback function
</pre>

<pre class="nim-code">
SpecialFunction
</pre>

<h3 id="SpecialFunctionOr">SpecialFunctionOr</h3>

<pre class="description">
A SpecialFunction or a warning message.
</pre>

<pre class="nim-code">
SpecialFunctionOr = OpResultWarn[SpecialFunction]
</pre>

<h3 id="Found">Found</h3>

<pre class="description">
The line endings found.

* nothing = no special ending
* plus = +
* triple = """
* newline = \n
* plus_n = +\n
* triple_n = """\n
* crlf = \r\n
* plus_crlf = +\r\n
* triple_crlf = """\r\n
</pre>

<pre class="nim-code">
Found = enum
  nothing, plus, triple, newline, plus_n, triple_n, crlf, plus_crlf, triple_crlf
</pre>

<h3 id="LinesOr">LinesOr</h3>

<pre class="description">
A list of lines or a warning.
</pre>

<pre class="nim-code">
LinesOr = OpResultWarn[seq[string]]
</pre>

<h3 id="LoopControl">LoopControl</h3>

<pre class="description">
Controls whether to output the current replacement block iteration and whether to stop or not.

* lcStop -- do not output this replacement block and stop iterating
* lcSkip -- do not output this replacement block and continue with the next iteration
* lcAdd -- output the replacment block and continue with the next iteration
</pre>

<pre class="nim-code">
LoopControl = enum
  lcStop = "stop", lcSkip = "skip", lcAdd = "add"
</pre>

<h3 id="newLinesOr">newLinesOr</h3>

<pre class="description">
Return a new LinesOr object containing a warning.
</pre>

<pre class="nim-code">
func newLinesOr(warning: MessageId; p1: string = ""; pos = 0): LinesOr
</pre>

<h3 id="newLinesOr-1">newLinesOr</h3>

<pre class="description">
Return a new LinesOr object containing a warning.
</pre>

<pre class="nim-code">
func newLinesOr(warningData: WarningData): LinesOr
</pre>

<h3 id="newLinesOr-2">newLinesOr</h3>

<pre class="description">
Return a new LinesOr object containing a list of lines.
</pre>

<pre class="nim-code">
func newLinesOr(lines: seq[string]): LinesOr
</pre>

<h3 id="newPosOr">newPosOr</h3>

<pre class="description">
Create a PosOr warning.
</pre>

<pre class="nim-code">
func newPosOr(warning: MessageId; p1 = ""; pos = 0): PosOr
</pre>

<h3 id="newPosOr-1">newPosOr</h3>

<pre class="description">
Create a PosOr value.
</pre>

<pre class="nim-code">
func newPosOr(pos: Natural): PosOr
</pre>

<h3 id="newSpecialFunctionOr">newSpecialFunctionOr</h3>

<pre class="description">
Create a PosOr warning.
</pre>

<pre class="nim-code">
func newSpecialFunctionOr(warning: MessageId; p1 = ""; pos = 0): SpecialFunctionOr
</pre>

<h3 id="newSpecialFunctionOr-1">newSpecialFunctionOr</h3>

<pre class="description">
Create a SpecialFunctionOr value.
</pre>

<pre class="nim-code">
func newSpecialFunctionOr(specialFunction: SpecialFunction): SpecialFunctionOr
</pre>

<h3 id="a__">`$`</h3>

<pre class="description">
Return a string representation of a Statement.
</pre>

<pre class="nim-code">
func `$`(s: Statement): string
</pre>

<h3 id="a___">`==`</h3>

<pre class="description">
Return true when the two statements are equal.
</pre>

<pre class="nim-code">
func `==`(s1: Statement; s2: Statement): bool
</pre>

<h3 id="a___-1">`==`</h3>

<pre class="description">
Return true when a equals b.
</pre>

<pre class="nim-code">
func `==`(a: PosOr; b: PosOr): bool
</pre>

<h3 id="a___-2">`!=`</h3>

<pre class="description">
Compare whether two PosOr are not equal.
</pre>

<pre class="nim-code">
func `!=`(a: PosOr; b: PosOr): bool
</pre>

<h3 id="VariableNameKind">VariableNameKind</h3>

<pre class="description">
The variable name type.

vtNormal -- a variable with whitespace following it
vtFunction -- a variable with ( following it
vtGet -- a variable with [ following it
</pre>

<pre class="nim-code">
VariableNameKind = enum
  vnkNormal, vnkFunction, vnkGet
</pre>

<h3 id="VariableName">VariableName</h3>

<pre class="description">
A variable name in a statement.

* dotName -- the dot name string
* kind -- the kind of name defined by the character following the name
* pos -- the position after the trailing whitespace
</pre>

<pre class="nim-code">
VariableName = object
  dotName*: string
  kind*: VariableNameKind
  pos*: Natural

</pre>

<h3 id="VariableNameOr">VariableNameOr</h3>

<pre class="description">

</pre>

<pre class="nim-code">
VariableNameOr = OpResultWarn[VariableName]
</pre>

<h3 id="RightType">RightType</h3>

<pre class="description">
The type of the right hand side of a statement.

rtNothing -- not a valid right hand side
rtString -- a literal string starting with a quote
rtNumber -- a literal number starting with a digit or minus sign
rtVariable -- a variable starting with a-zA-Z
rtFunction -- a function variable calling a function: len(b)
rtList -- a literal list: [1, 2, 3, len(b), 5]
rtCondition -- a condition: (a < b)
rtGet -- a index into a list or dictionary: teas[2], teas["green"]
</pre>

<pre class="nim-code">
RightType = enum
  rtNothing, rtString, rtNumber, rtVariable, rtList, rtCondition
</pre>

<h3 id="newVariableName">newVariableName</h3>

<pre class="description">
Create a new VariableName object.
</pre>

<pre class="nim-code">
func newVariableName(dotName: string; kind: VariableNameKind; pos: Natural): VariableName
</pre>

<h3 id="newVariableNameOr">newVariableNameOr</h3>

<pre class="description">
Create a PosOr warning.
</pre>

<pre class="nim-code">
func newVariableNameOr(warning: MessageId; p1 = ""; pos = 0): VariableNameOr
</pre>

<h3 id="newVariableNameOr-1">newVariableNameOr</h3>

<pre class="description">
Create a new VariableNameOr object.
</pre>

<pre class="nim-code">
func newVariableNameOr(dotName: string; kind: VariableNameKind; pos: Natural): VariableNameOr
</pre>

<h3 id="getRightType">getRightType</h3>

<pre class="description">
Return the type of the right hand side of the statement at the start position.
</pre>

<pre class="nim-code">
func getRightType(statement: Statement; start: Natural): RightType
</pre>

<h3 id="getVariableNameOr">getVariableNameOr</h3>

<pre class="description">
Get a variable name from the statement. Start points at a name.

~~~
a = var-name( 1 )
    ^         ^
a = abc # comment
    ^   ^
a = o.def.bbb # comment
    ^         ^
~~~
</pre>

<pre class="nim-code">
proc getVariableNameOr(text: string; startPos: Natural): VariableNameOr
</pre>

<h3 id="getVariableName">getVariableName</h3>

<pre class="description">
Get a variable name from the statement. Skip leading whitespace.
</pre>

<pre class="nim-code">
proc getVariableName(text: string; start: Natural): VariableNameOr
</pre>

<h3 id="matchTripleOrPlusSign">matchTripleOrPlusSign</h3>

<pre class="description">
Match the optional """ or + at the end of the line. This tells whether the statement continues on the next line for code files.
</pre>

<pre class="nim-code">
func matchTripleOrPlusSign(line: string): Found
</pre>

<h3 id="addText">addText</h3>

<pre class="description">
Add the line up to the line-ending to the text string.
</pre>

<pre class="nim-code">
func addText(line: string; found: Found; text: var string)
</pre>

<h3 id="getFragmentAndPos">getFragmentAndPos</h3>

<pre class="description">
Split up a long statement around the given position.  Return the statement fragment, and the position where the fragment starts in the statement.
</pre>

<pre class="nim-code">
func getFragmentAndPos(statement: Statement; start: Natural): (string, Natural)
</pre>

<h3 id="getWarnStatement">getWarnStatement</h3>

<pre class="description">
Return a multiline error message.
</pre>

<pre class="nim-code">
func getWarnStatement(filename: string; statement: Statement;
                      warningData: WarningData): string
</pre>

<h3 id="warnStatement">warnStatement</h3>

<pre class="description">
Show an invalid statement with a pointer pointing at the start of the problem. Long statements are trimmed around the problem area.
</pre>

<pre class="nim-code">
proc warnStatement(env: var Env; statement: Statement; warningData: WarningData;
                   sourceFilename = "")
</pre>

<h3 id="warnStatement-1">warnStatement</h3>

<pre class="description">

</pre>

<pre class="nim-code">
proc warnStatement(env: var Env; statement: Statement; messageId: MessageId;
                   p1: string; pos: Natural; sourceFilename = "")
</pre>

<h3 id="removeLineEnd">removeLineEnd</h3>

<pre class="description">
Return a new string with the n or rn removed from the end of the line.
</pre>

<pre class="nim-code">
func removeLineEnd(s: string): string
</pre>

<h3 id="yieldStatements">yieldStatements</h3>

<pre class="description">
Iterate through the command's statements. A statement can be blank or all whitespace.
</pre>

<pre class="nim-code">
iterator yieldStatements(cmdLines: CmdLines): Statement
</pre>

<h3 id="readStatement">readStatement</h3>

<pre class="description">
Read the next statement from the code file reading multiple lines if needed. When there is an error, show the warning and return nothing. When no more statements, return nothing.
</pre>

<pre class="nim-code">
proc readStatement(env: var Env; lb: var LineBuffer): Option[Statement]
</pre>

<h3 id="getMultilineStr">getMultilineStr</h3>

<pre class="description">
Return the triple quoted string literal. The startPos points one
past the leading triple quote.  Return the parsed
string value and the ending position one past the trailing
whitespace.
</pre>

<pre class="nim-code">
func getMultilineStr(text: string; start: Natural): ValuePosSiOr
</pre>

<h3 id="getString">getString</h3>

<pre class="description">
Return a literal string value and position after it. The start parameter is the index of the first quote in the statement and the return position is after the optional trailing white space following the last quote.

~~~
var = "hello" # asdf
      ^       ^
~~~
</pre>

<pre class="nim-code">
func getString(statement: Statement; start: Natural): ValuePosSiOr
</pre>

<h3 id="getNumber">getNumber</h3>

<pre class="description">
Return the literal number value and position after it.  The start index points at a digit or minus sign. The position includes the trailing whitespace.
</pre>

<pre class="nim-code">
func getNumber(statement: Statement; start: Natural): ValuePosSiOr
</pre>

<h3 id="skipArgument">skipArgument</h3>

<pre class="description">
Skip past the argument.  startPos points at the first character of a function argument.  Return the first non-whitespace character after the argument or a message when there is a problem.
~~~
a = fn( 1 )
        ^ ^
          ^^
a = fn( 1 , 2 )
        ^ ^
~~~
</pre>

<pre class="nim-code">
func skipArgument(statement: Statement; startPos: Natural): PosOr
</pre>

<h3 id="ifFunctions">ifFunctions</h3>

<pre class="description">
Return the if/if0 function's value and position after. It conditionally runs one of its arguments and skips the other. Start points at the first argument of the function. The position includes the trailing whitespace after the ending ).

This handles the three parameter form with an assignment.

~~~
a = if(cond, then, else)
       ^                ^
a = if(cond, then)
       ^          ^
~~~
</pre>

<pre class="nim-code">
proc ifFunctions(env: var Env; specialFunction: SpecialFunction;
                 statement: Statement; start: Natural; variables: Variables;
                 topLevel = false): ValuePosSiOr
</pre>

<h3 id="bareIfAndIf0">bareIfAndIf0</h3>

<pre class="description">
Handle the bare if/if0. Return the resulting value and the position in the statement after the if.

~~~
if(cond, return("stop"))
   ^                    ^
if(c, warn("c is true"))
   ^                    ^
~~~
</pre>

<pre class="nim-code">
proc bareIfAndIf0(env: var Env; specialFunction: SpecialFunction;
                  statement: Statement; start: Natural; variables: Variables): ValuePosSiOr
</pre>

<h3 id="andOrFunctions">andOrFunctions</h3>

<pre class="description">
Return the and/or function's value and the position after. The and function stops on the first false. The or function stops on the first true. The rest of the arguments are skipped. Start points at the first parameter of the function. The position includes the trailing whitespace after the ending ).
</pre>

<pre class="nim-code">
proc andOrFunctions(env: var Env; specialFunction: SpecialFunction;
                    statement: Statement; start: Natural; variables: Variables;
                    listCase = false): ValuePosSiOr
</pre>

<h3 id="getArguments">getArguments</h3>

<pre class="description">
Get the function arguments and the position of each. If an argument has a side effect, the return value and pos and side effect is returned, else a 0 value and seNone is returned.
~~~
newList = listLoop(list, callback, state)  # comment
                   ^                       ^
newList = listLoop(return(3), callback, state)  # comment
                          ^ ^
~~~
</pre>

<pre class="nim-code">
proc getArguments(env: var Env; statement: Statement; start: Natural;
                  variables: Variables; listCase = false;
                  arguments: var seq[Value]; argumentStarts: var seq[Natural]): ValuePosSiOr
</pre>

<h3 id="getFunctionValuePosSi">getFunctionValuePosSi</h3>

<pre class="description">
Return the function's value and the position after it. Start points at the first argument of the function. The position includes the trailing whitespace after the ending ).

~~~
a = get(b, 2, c) # condition
        ^        ^
a = get(b, len("hi"), c)
               ^    ^
~~~
</pre>

<pre class="nim-code">
proc getFunctionValuePosSi(env: var Env; functionName: string;
                           functionPos: Natural; statement: Statement;
                           start: Natural; variables: Variables;
                           listCase = false; topLevel = false): ValuePosSiOr
</pre>

<h3 id="runBoolOp">runBoolOp</h3>

<pre class="description">
Evaluate the bool expression and return a bool value.
</pre>

<pre class="nim-code">
func runBoolOp(left: Value; op: string; right: Value): Value
</pre>

<h3 id="runCompareOp">runCompareOp</h3>

<pre class="description">
Evaluate the comparison and return a bool value.
</pre>

<pre class="nim-code">
func runCompareOp(left: Value; op: string; right: Value): Value
</pre>

<h3 id="getCondition">getCondition</h3>

<pre class="description">
Return the bool value of the condition expression and the position after it.  The start index points at the ( left parentheses. The position includes the trailing whitespace after the ending ).

~~~
a = (5 < 3) # condition
    ^       ^
~~~
</pre>

<pre class="nim-code">
proc getCondition(env: var Env; statement: Statement; start: Natural;
                  variables: Variables): ValuePosSiOr
</pre>

<h3 id="getBracketedVarValue">getBracketedVarValue</h3>

<pre class="description">
Return the value of the bracketed variable and the position after the trailing whitespace.. Start points at the the first argument.

~~~
a = list[ 4 ]
          ^  ^
a = dict[ "abc" ]
          ^      ^
~~~
</pre>

<pre class="nim-code">
proc getBracketedVarValue(env: var Env; statement: Statement; start: Natural;
                          container: Value; variables: Variables): ValuePosSiOr
</pre>

<h3 id="listLoop">listLoop</h3>

<pre class="description">
Make a new list from an existing list. The callback function is called for each item in the list and determines what goes in the new list.  See funList_lpoal in functions.nim for more information.

Return the listLoop value and the ending position.  Start
points at the first parameter of the function. The position
includes the trailing whitespace after the ending right
parentheses.

~~~
stopped = listLoop(list, new, callback, state)
                   ^                          ^
~~~
</pre>

<pre class="nim-code">
proc listLoop(env: var Env; specialFunction: SpecialFunction;
              statement: Statement; start: Natural; variables: Variables;
              listCase = false): ValuePosSiOr
</pre>

<h3 id="getValuePosSi">getValuePosSi</h3>

<pre class="description">
Return the value and position of the item that the start parameter points at which is a string, number, variable, list, or condition.  The position returned includes the trailing whitespace after the item. The ending position is pointing at the end of the statement, or at the first non-whitespace character after the argument. A true topLevel parameter means the item pointed to by start is the first item after the equal sign (not an argument).

~~~
a = "tea" # string
    ^     ^
a = cmp(b, c) # calling variable
    ^         ^
a = if( bool(len(b)), d, e) # if
        ^             ^
~~~
</pre>

<pre class="nim-code">
proc getValuePosSi(env: var Env; statement: Statement; start: Natural;
                   variables: Variables; topLevel = false): ValuePosSiOr
</pre>

<h3 id="runBareFunction">runBareFunction</h3>

<pre class="description">
Handle bare function: if, if0, return, warn and log. A bare function does not assign a variable.

~~~
if( true, warn("tea time")) # test
^                           ^
return(5)
^        ^
~~~
</pre>

<pre class="nim-code">
proc runBareFunction(env: var Env; statement: Statement; start: Natural;
                     variables: Variables; leftName: VariableName): ValuePosSiOr
</pre>

<h3 id="getBracketDotName">getBracketDotName</h3>

<pre class="description">
Convert var[key] to a dot name.

~~~
key = "hello"
name[key] = 20
^         ^
=> name.hello, pos

name["hello"] = 20
^             ^
~~~
</pre>

<pre class="nim-code">
proc getBracketDotName(env: var Env; statement: Statement; start: Natural;
                       variables: Variables; leftName: VariableName): ValuePosSiOr
</pre>

<h3 id="runStatement">runStatement</h3>

<pre class="description">
Run one statement and return the variable dot name string, operator and value.
</pre>

<pre class="nim-code">
proc runStatement(env: var Env; statement: Statement; variables: Variables): VariableDataOr
</pre>

<h3 id="skipSpaces">skipSpaces</h3>

<pre class="description">

</pre>

<pre class="nim-code">
proc skipSpaces(text: string): Natural
</pre>

<h3 id="callUserFunction">callUserFunction</h3>

<pre class="description">
Run the given user function.
</pre>

<pre class="nim-code">
proc callUserFunction(env: var Env; funcVar: Value; variables: Variables;
                      arguments: seq[Value]): FunResult
</pre>

<h3 id="runStatementAssignVar">runStatementAssignVar</h3>

<pre class="description">
Run a statement and assign the variable if appropriate. Return skip, stop or continue to control the loop.
</pre>

<pre class="nim-code">
proc runStatementAssignVar(env: var Env; statement: Statement;
                           variables: var Variables; sourceFilename: string): LoopControl
</pre>

<h3 id="parseSignature">parseSignature</h3>

<pre class="description">
Parse the signature and return the list of parameters or a message.

~~~
cmp = func(numStr1: string, numStr2: string) int
           ^
~~~
</pre>

<pre class="nim-code">
proc parseSignature(dotName: string; signature: string; start: Natural): SignatureOr
</pre>

<h3 id="isFunctionDefinition">isFunctionDefinition</h3>

<pre class="description">
If the statement is the first line of a function definition, return true and fill in the return parameters.  Return quickly when not a function definition. The retPos points at the first non-whitespace after the "func(".
</pre>

<pre class="nim-code">
proc isFunctionDefinition(statement: Statement; retLeftName: var string;
                          retOperator: var Operator; retPos: var Natural): bool
</pre>

<h3 id="defineUserFunctionAssignVar">defineUserFunctionAssignVar</h3>

<pre class="description">
If the statement starts a function definition, define it and assign the variable. A true return value means the statement(s) were processed and maybe errors output. A false means the statement should be processed as a regular statement.
</pre>

<pre class="nim-code">
proc defineUserFunctionAssignVar(env: var Env; lb: var LineBuffer;
                                 statement: Statement; variables: var Variables;
                                 sourceFilename: string; codeFile: bool): bool
</pre>

<h3 id="runCommand">runCommand</h3>

<pre class="description">
Run a command and fill in the variables dictionaries.
</pre>

<pre class="nim-code">
proc runCommand(env: var Env; cmdLines: CmdLines; variables: var Variables): LoopControl
</pre>

<h3 id="runCodeFile">runCodeFile</h3>

<pre class="description">
Run the code file and fill in the variables.
</pre>

<pre class="nim-code">
proc runCodeFile(env: var Env; variables: var Variables; filename: string)
</pre>

<h3 id="runCodeFiles">runCodeFiles</h3>

<pre class="description">
Run each code file and populate the variables.
</pre>

<pre class="nim-code">
proc runCodeFiles(env: var Env; variables: var Variables; codeList: seq[string])
</pre>


<p>⦿ This page was generated
by <a href="https://github.com/flenniken/statictea/">statictea</a>
from nim doc comments. ⦿</p>

</body>
</html>
