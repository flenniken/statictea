# cmdline.nim

Parse the command line.

* [cmdline.nim](../src/cmdline.nim) &mdash; Nim source code.
# Index

* type: [ArgsOrMessageKind](#argsormessagekind) &mdash; The kind of an ArgsOrMessage object, either args or a message.
* type: [CmlArgs](#cmlargs) &mdash; CmlArgs holds the parsed command line arguments in an ordered dictionary.
* type: [ArgsOrMessage](#argsormessage) &mdash; Contains the command line args or a message.
* type: [CmlOptionType](#cmloptiontype) &mdash; The option type.
* const: [cmlMessages](#cmlmessages) &mdash; Possible message numbers returned by cmdline.
* [newCmlOption](#newcmloption) &mdash; Create a new CmlOption object.
* [`$`](#) &mdash; Return a string representation of an CmlOption object.
* [`$`](#-1) &mdash; Return a string representation of a ArgsOrMessage object.
* [commandLineEcho](#commandlineecho) &mdash; Show the command line arguments.
* [collectParams](#collectparams) &mdash; Get the command line parameters from the system and return a list.
* [cmdLine](#cmdline) &mdash; Parse the command line parameters.

# ArgsOrMessageKind

The kind of an ArgsOrMessage object, either args or a message.

```nim
ArgsOrMessageKind = enum
  cmlArgs, cmlMessage
```

# CmlArgs

CmlArgs holds the parsed command line arguments in an ordered dictionary. The keys are the supported options found on the command line and each value is a list of associated parameters. An option without parameters will have an empty list.

```nim
CmlArgs = OrderedTable[string, seq[string]]
```

# ArgsOrMessage

Contains the command line args or a message.

```nim
ArgsOrMessage = object
  case kind*: ArgsOrMessageKind
  of cmlArgs:
      args*: CmlArgs

  of cmlMessage:
      messageId*: CmlMessageId
      problemParam*: string


```

# CmlOptionType

The option type.

```nim
CmlOptionType = enum
  cmlParameter,             ## option with a parameter
  cmlNoParameter,           ## option without a parameter
  cmlOptionalParameter,     ## option with an optional parameter
  cmlBareParameter           ## a parameter without an option
```

# cmlMessages

Possible message numbers returned by cmdline.

```nim
cmlMessages: array[low(CmlMessageId) .. high(CmlMessageId), string] = [
    "Two dashes must be followed by an option name.",
    "The option \'--$1\' is not supported.",
    "The option \'$1\' needs a parameter.",
    "One dash must be followed by a short option name.",
    "The option \'--$1\' is not supported.",
    "The option \'-$1\' needs a parameter; use it by itself.",
    "Duplicate short option: \'-$1\'.", "Duplicate long option: \'-$1\'.",
    "Use the short name \'_\' with a bare parameter.",
    "Use an alphanumeric ascii character for a short option name.",
    "Missing bare parameter: $1.", "Extra bare parameter."]
```

# newCmlOption

Create a new CmlOption object.

```nim
func newCmlOption(long: string; short: char; optionType: CmlOptionType): CmlOption
```

# `$`

Return a string representation of an CmlOption object.

```nim
func `$`(a: CmlOption): string
```

# `$`

Return a string representation of a ArgsOrMessage object.

```nim
func `$`(a: ArgsOrMessage): string
```

# commandLineEcho

Show the command line arguments.

```nim
proc commandLineEcho()
```

# collectParams

Get the command line parameters from the system and return a list. Don't return the first one which is the app name. This is the list that cmdLine expects.

```nim
proc collectParams(): seq[string]
```

# cmdLine

Parse the command line parameters.  You pass in the list of supported options and the parameters to parse. The arguments found are returned. If there is a problem with the parameters, args contains a message telling the problem. Use collectParams() to generate parameters.

```nim
func cmdLine(options: openArray[CmlOption]; parameters: openArray[string]): ArgsOrMessage
```


---
⦿ Markdown page generated by [StaticTea](https://github.com/flenniken/statictea/) from nim doc comments. ⦿
