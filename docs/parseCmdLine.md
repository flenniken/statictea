# parseCmdLine.nim

Parse a StaticTea language command line.


* [parseCmdLine.nim](../src/parseCmdLine.nim) &mdash; Nim source code.
# Index

* type: [LineParts](#lineparts) &mdash; LineParts holds parsed components of a line.
* type: [LinePartsOr](#linepartsor) &mdash; The line parts or a warning.
* type: [CmdLines](#cmdlines) &mdash; The collected command lines and their parts.
* type: [ExtraLineKind](#extralinekind) &mdash; The ExtraLine type.
* type: [ExtraLine](#extraline) &mdash; The extra line and its type.
* [newNormalLine](#newnormalline) &mdash; Create a normal ExtraLine.
* [newNoLine](#newnoline) &mdash; Create a no line ExtraLine.
* [newOutOfLines](#newoutoflines) &mdash; Create an out of lines ExtraLine.
* [newLinePartsOr](#newlinepartsor) &mdash; Return a new LinePartsOr object containing a warning.
* [newLinePartsOr](#newlinepartsor-1) &mdash; Return a new LinePartsOr object containing a LineParts object.
* [getCodeLength](#getcodelength) &mdash; Return the length of the code in the line.
* [parseCmdLine](#parsecmdline) &mdash; Parse the line and return its parts.

# LineParts

LineParts holds parsed components of a line.

~~~
prefix command  [code]   [comment] [continuation]
|      |        |        |         |[postfix]
|      |        |        |         ||  [ending]
|      |        |        |         ||  |
<!--$  nextline var = 5  # comment +-->\n
     |
     optional spaces
~~~

Whitespace must follow a command except on the last line of the file.
codeStart is 0 when codeLen is 0.


~~~nim
LineParts = object
  prefix*: string
  command*: string
  codeStart*: Natural
  codeLen*: Natural
  commentLen*: Natural
  continuation*: bool
  postfix*: string
  ending*: string
  lineNum*: Natural
~~~

# LinePartsOr

The line parts or a warning.


~~~nim
LinePartsOr = OpResultWarn[LineParts]
~~~

# CmdLines

The collected command lines and their parts.


~~~nim
CmdLines = object
  lines*: seq[string]
  lineParts*: seq[LineParts]
~~~

# ExtraLineKind

The ExtraLine type.

* elkNoLine — there is no line here
* elkOutOfLines — no more lines in the template
* elkNormalLine — we have a line of some type


~~~nim
ExtraLineKind = enum
  elkNoLine, elkOutOfLines, elkNormalLine
~~~

# ExtraLine

The extra line and its type. The line is empty except for the
elkNormalLine type.


~~~nim
ExtraLine = object
  kind*: ExtraLineKind
  line*: string
~~~

# newNormalLine

Create a normal ExtraLine.


~~~nim
func newNormalLine(line: string): ExtraLine
~~~

# newNoLine

Create a no line ExtraLine.


~~~nim
func newNoLine(): ExtraLine
~~~

# newOutOfLines

Create an out of lines ExtraLine.


~~~nim
func newOutOfLines(): ExtraLine
~~~

# newLinePartsOr

Return a new LinePartsOr object containing a warning.


~~~nim
func newLinePartsOr(warning: MessageId; p1: string = ""; pos = 0): LinePartsOr
~~~

# newLinePartsOr

Return a new LinePartsOr object containing a LineParts object.


~~~nim
func newLinePartsOr(lineParts: LineParts): LinePartsOr
~~~

# getCodeLength

Return the length of the code in the line.  The code starts at
codeStart and cannot exceed the given length. The code ends when
there is a comment (a pound sign), or the end is reached.
The input length is returned on errors.


~~~nim
func getCodeLength(line: string; codeStart: Natural; length: Natural): Natural
~~~

# parseCmdLine

Parse the line and return its parts. Return quickly when not a
command line.


~~~nim
proc parseCmdLine(prepostTable: PrepostTable; line: string; lineNum: Natural): LinePartsOr {.
    raises: [ValueError, KeyError], tags: [].}
~~~


---
⦿ Markdown page generated by [StaticTea](https://github.com/flenniken/statictea/) from nim doc comments. ⦿
